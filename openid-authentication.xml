<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="info" ipr="none" docName="openid-authentication-2_0-09.xml">
  <?xml-stylesheet type='text/xsl'
    href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

  <?rfc toc="yes" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc iprnotified="no" ?>
  <?rfc strict="yes" ?>
  <?rfc private="Draft" ?>

  <front>
    <title>OpenID Authentication 2.0 - Draft 09</title>

    <author initials="D.R" surname="Recordon" fullname="David Recordon">
      <organization abbrev="VeriSign">VeriSign, Inc.</organization>
      <address>
    	<postal>
    	  <street>487 E Middlefield Road</street>
    	  <city>Mountain View</city> <region>CA</region>
    	  <code>94109</code>
    	  <country>USA</country>
    	</postal>
    	<email>drecordon@verisign.com</email>
      </address>
    </author>

    <author initials="J.H" surname="Hoyt" fullname="Josh Hoyt">
      <organization abbrev="JanRain">JanRain, Inc.</organization>
      <address>
      	<postal>
      	  <street>5331 SW Macadam Avenue</street>
      	  <street>Suite #375</street>
      	  <city>Portland</city> <region>OR</region>
      	  <code>97239</code>
      	  <country>USA</country>
      	</postal>
    	<email>josh@janrain.com</email>
      </address>
    </author>

    <author initials="D.H" surname="Hardt" fullname="Dick Hardt">
      <organization abbrev="Sxip">Sxip Identity Corporation</organization>
      <address>
      	<postal>
      	  <street>798 Beatty Street</street>
      	  <city>Vancouver</city> <region>BC</region>
      	  <code>V6B 2M1</code>
      	  <country>Canada</country>
      	</postal>
    	<email>dick@sxip.com</email>
      </address>
    </author>

    <author initials="B.F" surname="Fitzpatrick"
            fullname="Brad Fitzpatrick">
      <organization abbrev="Six Apart">Six Apart, Ltd.</organization>
      <address>
      	<postal>
      	  <street>548 4th Street</street>
      	  <city>San Francisco</city> <region>CA</region>
      	  <code>94107</code>
      	  <country>USA</country>
      	</postal>
	    <email>brad@danga.com</email>
      </address>
    </author>

    <date month="August" year="2006"/>

    <abstract>
      <t>
        OpenID Authentication provides a way to prove that an End User
        owns an Identifier. It does this without passing around a
        password, email address, or other sensitive information.
      </t>

      <t>
        OpenID is decentralized. No central authority must approve or
        register Relying Parties or Identity Providers. An End User
        can freely choose which Identity Provider to use. They can
        preserve their Identifier if they switch Identity Providers.
      </t>

      <t>
        While nothing in the protocol requires JavaScript or modern
        browsers, the authentication scheme plays nicely with
        "AJAX"-style setups, so an End User can prove their Identity
        to a Relying Party without having to leave the page they are
        on.
      </t>

      <t>
        Extensions built on top of the foundation created by OpenID
        Authentication provide a mechanism for exchanging arbitrary
        End User-related data.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119"/>.</t>
    </section>

    <section title="Terminology">
      <t>
    <list style="hanging">
      <t hangText="End User:">
        The person who wants to prove ownership of an Identifier to a
        Relying Party.
      </t>

      <t hangText="Identifier:">
        An Identifier is a URL or <eref
        target="http://www.oasis-open.org/committees/download.php/15376"
        >XRI</eref>. The OpenID Authentication
        protocol proves that an End User owns a URL or XRI.
      </t>

      <t hangText="Claimed Identifier:">
        An Identifier that the End User claims to own that has not yet
        been verified by the Relying Party.
      </t>

      <t hangText="Verified Identifier:">
        An Identifier that the End User has proven to a Relying Party
        that they own.
      </t>

      <t hangText="Relying Party:">
        A Web application that wants proof that the End User owns an
        Identifier.
      </t>

      <t hangText="IdP:">
        Identity Provider. This is the OpenID Authentication server
        that a Relying Party contacts for cryptographic proof that the
        End User owns an Identifier.
      </t>

      <t hangText="IdP Identifier:">
        An Identifier which represents an IdP.
      </t>

      <t hangText="User-Agent:">
        The End User's Web browser. See <xref target="RFC2616"/>.
      </t>
    </list>
      </t>
    </section>

    <section title="Overview">

      <t>
        The OpenID Authentication protocol provides a way to prove
        that an End User owns an Identifier. In essence, the protocol
        allows a service to proxy its authentication decisions to
        another service specified by the End User. OpenID uses only
        standard HTTP requests and responses, so does not require any
        special capabilities of the User-Agent or other software.
      </t>

      <t>
        The End User initiates the protocol by providing either a
        Claimed Identifier or an IdP Identifier. If an IdP Identifier
        is provided, the IdP MAY assist the End User in selecting an
        identifier. For example, the IdP might automatically generate
        a different Identifier for each different Relying Party so
        that the End User cannot be tracked across different sites.
      </t>

      <section title="Protocol Flow">
        <t>
          <list style="numbers">
            <t>
              The End User <xref target="initiation">initiates
              authentication</xref> by supplying a Claimed Identifier
              or IdP Identifier to the Relying Party. The
              Relying Party <xref target="discovery">performs
              discovery</xref> on the End User-provided identifier and
              establishes the location of the service that the End User
              uses for authentication.
            </t>

            <t>
              (optional)

              The Relying Party and IdP exchange information on how to
              cryptographically sign the request and responses. This
              information is referred to as an "association." <xref
              target="associations">OpenID associations</xref> consist
              of a "handle," which is an identifier for the
              association, an "association type," and the data that is
              needed by that association type for signing and
              verifying signatures.
            </t>

            <t>
              The Relying Party sends the End User to the IdP
              with an OpenID <xref
              target="requesting_authentication">authentication
              request</xref>.
            </t>

            <t>
              The IdP establishes whether the End User is authorized
              to perform OpenID authentication and wishes to do
              so. Depending on the form of the request, the IdP may be
              able to interact with the End User in order to establish
              that they are authorized to approve OpenID
              authentication.
            </t>

            <t>
              The IdP sends the End User back to the Relying Party
              with a signed assertion if the <xref
              target="positive_assertions">authentication is
              approved</xref> or an indication that OpenID <xref
              target="negative_assertions">authentication
              failed</xref> if it was not approved.
            </t>
          </list>
        </t>
      </section>
    </section>

    <section title="Initiation and Discovery">
      <t>
        The OpenID Authentication protocol starts with an End User
        submitting an <xref target="identifying">Identifier</xref> to
        the Relying Party. The Relying Party examines the user input,
        normalizes it, and performs discovery based on the normalized
        identifier. After successful discovery, the Relying Party has
        sufficient information to submit an authentication request to
        an IdP (see <xref target="requesting_authentication" />).
      </t>

      <section title="Initiation" anchor="initiation">
        <t>
          To initiate OpenID Authentication, the Relying Party SHOULD
          present the End User with a form that has a field for
          entering a Claimed Identifier or an IdP's Identifier.  It is
          RECOMMENDED that every Relying Party places the <eref
          target='http://openid.net/login-bg.gif'>OpenID logo</eref>
          at the beginning of the form field where the End User enters
          their Identifier. The form field's "name" attribute SHOULD
          have the value "openid_identifier" so that User-Agents can
          auto-complete the End User's Identifier.
        </t>

        <t>
          The End User's input MUST be normalized into an
          Identifier. If the End User supplies input that does not
          include a scheme (http, https, or xri), then the application
          needs to determine if the input is an XRI or a URL missing
          the "http://". To do so, the application SHOULD examine the
          first character of the input. If it is an XRI Global Context
          Symbol (<xref target="XRI Syntax 2.0">Section 2.2.1.1 of XRI
          Syntax</xref>), then the input SHOULD be treated as an
          XRI<!-- convert the XRI to URI normal form? -->. If it is
          not, then the input SHOULD be treated as an http URL, and
          prefixed with the string "http://".
        </t>

        <t>
          URL identifiers MUST be further normalized by applying the
          rules in section 6 of RFC 3986, following redirects when
          retrieving their content, and finally applying the rules in
          section 6 of RFC 3986 (Normalization and Comparison) to the
          final destination URL.
        </t>
      </section>

      <section title="Discovery" anchor="discovery">
        <t>
          Discovery consists of taking a Claimed Identifier or IdP
          Identifier and extracting the necessary information for
          initiating authentication. OpenID has three paths through
          which to do discovery. If the identifier is an XRI, <eref
          target="http://www.oasis-open.org/committees/download.php/17293"
          >XRI resolution</eref> will yield an XRDS document that
          contains the necessary information. If it is a URL, the
          <xref target="Yadis">Yadis protocol</xref> is first
          attempted. If it succeeds, the result is again an XRDS
          document. If the Yadis protocol fails, the URL is retrieved
          and HTML-based discovery is attempted on the content located
          by the URL.
        </t>

        <section title="Delegating Authentication"
                 anchor="delegating_authentication">
          <t>
            A "Delegate Identifier" is an alternate Identifier that
            can be included in the discovery response. When it is
            present, the Relying Party requests authentication using
            that identifier rather than the Claimed Identifier. Upon
            successful authentication, the Relying Party recognizes
            the End User using the Claimed Identifier. This mechanism
            is called Delegation.
          </t>

          <t>
            Delegation allows the End User to use a URL or XRI as an
            Identifier without having to perform any configuration
            other than specifying what should be returned by
            discovery. This allows a broad range of URLs and XRIs to
            be used. Delegation allows an End User to keep the same
            Identifier over many years, even as services come and go;
            they'll just keep changing the IdP Endpoint URL and
            Delegate Identifier.
          </t>
        </section>

        <section title="Discovered Information">
          <t>
            Upon successful completion of discovery, the Relying
            Party will have the following information:

            <list style="hanging">
              <t hangText="IdP Endpoint URL:">
                The URL that accepts authentication requests. This
                MUST be an absolute URL.
              </t>

              <t hangText="Claimed Identifier:">
                (optional) The normalized Identifier upon which
                discovery was performed. The Claimed Identifier is
                present unless the End User enters an IdP's
                Identifier. The discovery process allows a Relying
                Party to differentiate the two kinds of identifiers by
                supplying different information in response to the
                discovery request.
              </t>

              <t hangText="Delegate Identifier:">
                (optional) The Identifier that should be sent in the
                authentication request to the IdP. The Delegate
                Identifier can only be present when the End User
                enters a Claimed Identifier.
              </t>
            </list>
          </t>
        </section>

        <section title="Using Yadis or XRI Resolution">
          <t>
            If a URL is supplied, the Relying Party MUST attempt the
            Yadis protocol on that URL. The Yadis protocol and XRI
            resolution both yield an XRDS document. This is an XML
            document with entries for services that are related to the
            identifier.
          </t>

          <t>
            Once the Relying Party has obtained an XRDS document, it
            MUST first check for an &lt;xrd:Service&gt; element
            describing an IdP Endpoint. If no IdP Endpoint is found,
            it MUST check for an &lt;xrd:Service&gt; element
            describing a Claimed Identifier. <!-- XXX: unclear
            wording, as the Service element we're attempting to refer
            to here does in fact have the URI of the IdP
            Endpoint. --><!-- XXX: fallback, round-robin,
            etc... Hopefully the Yadis and XRI Resolution specs can
            shoulder most of this. -->
          </t>

          <section title="IdP Identifiers" toc="exclude">
            <t>
              If the entered Identifier is an IdP
              Identifier, the OpenID information is contained in a
              service element with the following information:

              <list style="symbols">
                <t>An &lt;xrd:Type&gt; tag whose text content is
                "http://openid.net/server/2.0"</t>

                <t>An &lt;xrd:URI&gt; tag whose text content is The
                IdP Endpoint URL</t>
              </list>
            </t>
          </section>

          <section title="Claimed Identifiers" toc="exclude">
            <t>
              If the entered Identifier is a Claimed
              Identifier, the remaining OpenID information is contained
              in a &lt;xrd:Service&gt; element with the following
              information:

              <list style="hanging">
                <t>An &lt;xrd:Type&gt; tag whose text content is
                "http://openid.net/signon/2.0"</t>

                <t>An &lt;xrd:URI&gt; tag whose text content is the
                IdP Endpoint URL</t>

                <t>An &lt;openid:Delegate&gt; tag (optional) whose text
                content is The Delegate Identifier</t>
              </list>

              The "openid" namespace is
              "http://openid.net/signon/2.0". The "xrd" namespace is
              "xri://$xrd*($v*2.0)".
            </t>

            <t>
              For compatibility with deployed code, it is RECOMMENDED
              that a Relying Party also accept
              "http://openid.net/signon/1.0" for the value of
              &lt;xrd:Type&gt;.
            </t>

            <t>
              If an OpenID IdP supports extensions (<xref
              target="extensions" />), the extensions SHOULD be listed
              as additional &lt;xrd:Type&gt; child elements of the
              &lt;xrd:Service&gt; element.
            </t>

            <section title="XRI and the CanonicalID Element" toc="exclude">
              <t>
                When the identifier is an XRI, the &lt;xrd:XRD&gt;
                element that contains the OpenID &lt;xrd:Service&gt;
                element will also contain a &lt;CanonicalID&gt;
                element. The content of this element MUST be preserved
                for use after a successful authentication request. See
                <xref target="identifying" />.
              </t>

              <t>
                The Relying Party MUST confirm that the provider of
                the XRD that contains the &lt;CanonicalID&gt; element
                is authoritative for that canonical ID. The provider
                is identified by the contents of the
                &lt;ProviderID&gt; element that is a child of the
                &lt;XRD&gt; element. If the provider is not
                authoritative for the canonical ID, the Relying Party
                MUST resolve the canonical ID to confirm the OpenID
                Service Endpoint information that was discovered. The
                information discovered when resolving the canonical ID
                MUST match the information discovered when resolving
                the user-supplied identifier.
              </t>

              <t>
                When using XRI resolution, the canonical ID MUST be
                used as the Claimed Identifier. For an XRI to be a
                valid identifier, both the &lt;ProviderID&gt; and
                &lt;CanonicalID&gt; MUST be present in the discovery
                result.
              </t>

              <t>
                When using URL-based identifiers, the CanonicalID
                element SHOULD be ignored.
              </t>
            </section>
          </section>
        </section>

        <section title="HTML-Based Discovery">
          <t>
            In the interests of backward compatibility, the HTML-based
            discovery mechanism from OpenID 1.1 MUST be supported by
            Relying Parties.  The host of the HTML document MAY be
            different from the End User's IdP's host.
          </t>

          <t>
            To use HTML-based discovery, the following markup MUST be
            added to the HEAD section of the HTML document located at
            the identifier URL:
            <list>
              <t>
                A &lt;LINK&gt; tag MUST be included with attributes
                "rel" set to "openid.server", and "href" set to an IdP
                Endpoint URL
              </t>
              <t>
                A &lt;LINK&gt; tag MAY be included with attributes
                "rel" set to "openid.delegate" and "href" set to the
                End User's Delegate Identifier
              </t>
            </list>
          </t>

          <t>
            The "openid.server" and "openid.delegate" URLs MUST NOT
            include entities other than &amp;amp;, &amp;lt;, &amp;gt;,
            and &amp;quot;. Other characters that would not be valid
            in the HTML document or that cannot be represented in the
            document's character encoding MUST be escaped using the
            %xx mechanism as described in <xref target='RFC3986' />.
          </t>
        </section>
      </section>
    </section>

    <section title="Data Formats" anchor="formats">
      <t>
        The OpenID Authentication protocol consists of messages passed
        between the Relying Party and the IdP. These messages consist
        of a mapping of plain-text keys to plain-text values. The keys
        and values are Unicode strings. When the keys and values need
        to be converted to bytes, they MUST be encoded using UTF-8.
        <!-- reference unicode, UTF-8! -->
      </t>
      <section title="Key-Value Form Encoding" anchor="kvform">
        <t>
          Key-Value Form is an encoding of an OpenID message to a byte
          string. It is used for signature calculation and for direct
          responses to relying parties.
        </t>
        <t>
          A Key-Value form message is a sequence of lines, each
          containing a pair of key and value. No key or value can
          contain a newline. No key can contain a colon. Each
          key-value pair is joined with a colon, and then a newline is
          appended. Every line MUST end with a newline, codepoint 10
          ("\n").  Additional characters, including whitespace, MUST
          NOT be added before or after the colon or newline. The
          Key-Value form representation of a mapping is the
          concatenation of all of the lines generated from the pairs
          in the mapping. The message MUST be encoded in UTF-8 to
          produce a byte string.
        </t>
      </section>
      <section title="Encoding Messages to HTTP Servers" anchor="queries">
        <t>
          When a message is sent to an HTTP server, it MUST be encoded
          using a form encoding specified in section 17.13.4 of the
          <xref target='HTML401'>HTML 4.01 specification</xref>.
          Likewise, if the "Content-Type" header is included in the
          request headers, its value MUST also be such an
          encoding.
        </t>
        <t>
          All of the keys in the message are prefixed with
          "openid.". This prefix prevents interference with other
          parameters that are passed along with the OpenID message.
          When a message is sent as a POST, the application processing
          the HTTP request MUST only use the values in the POST body
          and MUST ignore any "openid." parameters that are present on
          the request URL.
        </t>
        <t>
          This model applies to messages from the User Agent to both
          the Relying Party and the IdP, as well as messages from the
          Relying Party to the IdP.
        </t>
      </section>
      <section title="Example">
        <t>
          Non-normative
        </t>
        <t>
          <figure>
            <preamble>
              The following examples encode the following information:
            </preamble>
            <artwork><![CDATA[
Key     | Value
--------+---------------------------
mode    | error
error   | This is an example message
]]></artwork>
          </figure>
        </t>
        <t>
          <figure>
            <preamble>
              Key-Value Form encoded
            </preamble>
            <artwork><![CDATA[mode:error
error:This is an example message
]]></artwork>
          </figure>
          <figure>
            <preamble>
              x-www-urlencoded, as in a HTTP POST body or in a URL's
              query (<xref target="RFC3986" /> section 3).
            </preamble>
            <artwork>openid.mode=error&amp;openid.error=This%20is%20an%20example%20message</artwork>
          </figure>
        </t>
      </section>
    </section>

    <section title="Communication Types" anchor="communication">
      <t>
        Data is transferred between a Relying Party and IdP in two
        different ways. Either the Relying Party directly connects to
        the IdP, or the Relying Party or IdP sends data indirectly via
        the User-Agent.  In no instance does the IdP directly connect
        to the Relying Party.
      </t>
      <section title="Direct Communication"
               anchor="direct_comm">
        <t>
          Direct communication between a Relying Party and IdP is
          accomplished using an HTTP POST (see <xref target='RFC2616'
          />) initiated by a Relying Party to an IdP endpoint URL.
          Direct communication is used for <xref
          target="associations">establishing associations</xref>
          and <xref target="check_auth">verifying authentication
          assertions</xref>.
        </t>
        <section title="Direct Request" anchor="direct_request">
          <t>
            The message MUST be encoded as a POST body, as specified
            by <xref target="queries" />.
          </t>
        </section>
        <section title="Direct Response">
          <t>
            The body of a response to a <xref
            target="direct_request">Direct Request</xref> consists of
            a mapping of keys to values encoded in Key-Value Form, as
            specified by <xref target="kvform" />. The content-type
            header of the response SHOULD be "text/plain".
          </t>

          <section title="Successful Responses">
            <t>
              The HTTP Status Code of a response to a valid request is
              200. The contents of the resulting message depend on the
              mode of the request.
            </t>
          </section>

          <section title="Error Responses">
            <t>
              If a request is malformed or contains invalid arguments,
              the HTTP Status Code of the response is 400. The message
              encoded in the response will have the following form:
            </t>
            <t>
              <list style='symbols'>
                <t>
                  error
                  <list style='empty'>
                    <t>
                      Value: Unstructured text error message
                    </t>
                  </list>
                </t>

                <t>
                  contact
                  <list style='empty'>
                    <t>
                      Value: (optional) Contact address for the
                      administrator of the IdP
                    </t>
                  </list>
                </t>

                <t>
                  reference
                  <list style='empty'>
                    <t>
                      Value: (optional) A reference identifier, such
                      as a support ticket number or a URL to a support
                      ticket
                    </t>
                  </list>
                </t>
              </list>

              The IdP MAY add additional keys to the response.
            </t>
            <t>
              The particular wire format of these messages will depend
              on whether they are responses to direct or indirect
              queries.
            </t>
          </section>
        </section>
      </section>
      <section title="Indirect Communication"
               anchor="indirect_comm">
        <t>
          Indirect communication between Relying Party and IdP passes
          a message through the User-Agent. This can be initiated by
          either the Relying Party or the IdP. Indirect communication
          allows the messages to be associated with the End
          User. There are two methods for indirect communication: HTTP
          redirects and HTML form submission.
        </t>

        <t>
          Both form submission and redirection require that the sender
          know a recipient URL and that the recipient URL expect
          indirect messages, as specified in <xref target="queries"
          />.  The initiator of the communication chooses which method
          of indirect communication is appropriate. <xref
          target="requesting_authentication">Authentication
          requests</xref> and <xref
          target="responding_to_authentication">responses</xref> both
          take the form of indirect communication.
        </t>

        <section title="HTTP Redirect">
          <t>
            Data can be transferred by issuing a 302, 303, or 307 HTTP
            Redirect to the End User's User-Agent. The redirect URL is
            the URL of the receiver with the OpenID message appended
            to the query string, as specified in <xref
            target="queries" />.
          </t>
          <t>This method is deprecated as of OpenID version 2.0.</t>
        </section>

        <section title="HTML FORM Redirection">
          <t>
            A mapping of keys to values can be transferred by
            returning an HTML page to the User-Agent that contains an
            HTML form element. Form submission MAY be automated
            using JavaScript.
          </t>
          <t>
            The &lt;form&gt; element's 'action' attribute value MUST
            be the URL of the receiving Web site. Each Key-Value pair
            MUST be included in the form as an &lt;input&gt;
            element. The key MUST be encoded as the "name" attribute
            and the value as the "value" attribute, such that the User
            Agent will generate a message as specified in
            <xref target="queries" /> when the form is submitted. The
            form MUST include a submit button.
          </t>
        </section>
        <section title="Indirect Error Responses">
          <t>
            If a request is malformed or contains invalid arguments
            and there is an "openid.return_to" argument whose value is
            a valid URL, the IdP SHALL send the User Agent to that URL
            with a message of the following form:
          </t>
          <t>
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "error"
                  </t>
                </list>
              </t>
              <t>
                openid.error
                <list style='empty'>
                  <t>
                    Value: Unstructured text error message
                  </t>
                </list>
              </t>

              <t>
                openid.contact
                <list style='empty'>
                  <t>
                    Value: (optional) Contact address for the
                    administrator of the IdP
                  </t>
                </list>
              </t>

              <t>
                openid.reference
                <list style='empty'>
                  <t>
                    Value: (optional) A reference identifier, such
                    as a support ticket number or a URL to a support
                    ticket
                  </t>
                </list>
              </t>
            </list>

            The IdP MAY add additional keys to the response.
          </t>

          <t>
            If the "openid.return_to" value is missing or not a valid
            URL, the IdP SHOULD return a response to the End User
            indicating the error and that it is unable to return the
            End User to the Relying Party.
          </t>
        </section>
      </section>
    </section>

    <section title="Establishing Associations" anchor="associations">
      <t>
        An "association" is a set of information that allows a Relying
        Party to check the cryptographic signature of a response from
        the IdP.  An association is a relationship between a Relying
        Party and an IdP. If a Relying Party is incapable of creating
        or storing associations, OpenID provides a mechanism
        (<xref target="verifying_signatures"/>) for authentication to
        complete securely by using a back-channel between the Relying
        Party and the IdP to verify the signature on the response
        without of using an association. When a Relying Party is
        operating without creating associations, it is said to be in
        "stateless mode."
      </t>

      <t>
        It is RECOMMENDED that a Relying Party form associations if it is
        possible for it to do so. After the initial request, using an
        association saves one HTTP request per authentication, which
        saves network resources and improves performance.
      </t>

      <t>
        When generating Message Authentication Code (MAC) keys, the
        recommendations in <xref target="RFC1750" /> SHOULD be
        followed.
      </t>

      <section title="Generating Signatures" anchor="generating_signatures">
        <t>
          Successful authentication messages from the Identity
          Provider to the Relying Party MUST be cryptographically
          signed. 
        </t>

        <t>
          Signing a message is a two-phase process. The first phase is
          converting the response into an octet string to sign. The
          second phase is generating a signature for that octet
          string. The precise algorithm used for each phase depends on
          the type of association being used.
        </t>

        <t>
          There are two algorithms for each phase that an IdP SHOULD
          support. The two algorithms for converting the response to
          an octet string are an algorithm with a list of signed
          parameters, and an algorithm that signs all parameters. The
          two algorithms for signing the generated octet string are
          HMAC-SHA1 and HMAC-SHA256. Other algorithms for either phase
          may be defined by extensions and used by Relying Parties and
          IdPs which support them.
        </t>

        <section title="Signed List Algorithm" anchor="signed_list">

          <t>
            When using this algorithm to create an octet string, the
            signed information is a subset of the mapping of keys to
            values as specified in <xref target="formats" />. A signed
            message contains of a list of signed fields, an association
            handle, and a signature. The algorithm for generating the
            signature depends on the type of association.
          </t>

          <t>
            To compute the signature from an association, an ordered
            list of signed fields and a set of query parameters:

            <list style="numbers">
              <t>
                Iterate over the list of signed fields in order,
                taking the field name as the key. For each key, find
                the value in the query parameters whose key is equal
                to the field name prefixed with "openid.".
              </t>
              <t>
                Generate a <xref target="kvform">Key-Value Form
                string</xref> built from the (field name, value) pairs
                in the order that they appear in the sequence of
                key-value pairs. (This results in the "openid." prefix
                being stripped off the the keys from the original
                message.)
              </t>
              <t>
                Generate the signature by evaluating the keyed message
                digest function specified by the association on the
                resulting Key-Value Form string.
              </t>
            </list>
          </t>

        </section>

        <section title="Sign-All Algorithm" anchor="sign_all">

          <t>
            When using this algorithm to create an octet string, the
            signed information is the mapping of keys to values as
            specified in <xref target="formats" />. A signed message
            contains an association handle and a signature. The
            algorithm for generating the signature depends on the type
            of association.
          </t>

          <t>
            To compute the signature from an association and a set of
            query parameters:

            <list style="numbers">
              <t>
                Generate a <xref target="kvform">Key-Value Form
                string</xref> built from all the (key, value) pairs in
                the message sorted in byte order.  (Unlike the Signed
                List Algorithm, this doesn't result in the "openid."
                prefixes being stripped off the keys in this format.)
              </t>
              <t>
                Generate the signature by evaluating the keyed message
                digest function specified by the association on the
                resulting Key-Value Form string.
              </t>
            </list>
          </t>

        </section>

      </section>

      <section title="Association Handles">
        <t>
          Associations are referred to by a handle, which MUST be a
          string 255 characters or less, and consist only of ASCII
          characters in the range 33-126 inclusive (printable
          non-whitespace characters). The handle is used to look up
          stored associations.  A Relying Party SHOULD re-use the
          association for a server until it expires or is instructed
          to stop using it by the IdP.
        </t>
      </section>

      <section title="Association Types" anchor="assoc_types">
        <t>
          An association type indicates the algorithm for computing
          the signature of messages created with that
          association. OpenID associations use keyed message digest
          functions. The key for the message digest function is known
          as a Message Authentication Code (MAC) key.
        </t>

        <section title="HMAC-SHA1 Associations" anchor="hmacsha1">
          <figure>
            <preamble>
              An association of type HMAC-SHA1
              (<xref target="RFC2104" />, <xref target="RFC3174" />) 
              uses the following algorithm to compute a signature of the
              message:
            </preamble>
            <artwork>
  HMAC-SHA1(MAC key, Key-Value Form message)
</artwork>
          </figure> 
          <t>
            HMAC-SHA1 associations have the association type
            "HMAC-SHA1". The size of the MAC key for HMAC-SHA1
            associations is 160 bits. These associations use the
            signed list method to generate the octet string to sign.
          </t>
        </section>

        <section title="HMAC-SHA1-SIGNALL Associations" anchor="hmacsha1signall">
          <figure>
            <preamble>
              An association of type HMAC-SHA1-SIGNALL
              (<xref target="RFC2104" />, <xref target="RFC3174" />) 
              uses the following algorithm to compute a signature of the
              message:
            </preamble>
            <artwork>
  HMAC-SHA1(MAC key, Key-Value Form message)
</artwork>
          </figure> 
          <t>
            HMAC-SHA1 sign-all associations have the association type
            "HMAC-SHA1-SIGNALL". The size of the MAC key for HMAC-SHA1
            associations is 160 bits. These associations use the
            sign-all method to generate the octet string to sign.
          </t>
        </section>

        <section title="HMAC-SHA256-SIGNALL Associations" anchor="hmacsha256signall">
          <figure>
            <preamble>
              An association of type HMAC-SHA256 
              (<xref target="RFC2104" />, <xref target="FIPS180-2" />) 
              uses the following algorithm to compute a signature of the
              message:
            </preamble>
            <artwork>
  HMAC-SHA256(MAC key, Key-Value Form message)
</artwork>
          </figure>
          <t>
            HMAC-SHA256 associations have the association type
            "HMAC-SHA256-SIGNALL". The size of the MAC key for
            HMAC-SHA1 associations is 256 bits. These associations
            use the sign-all method to generate the octet string to
            sign.
          </t>
        </section>

      </section>

      <section title="Association Sessions">
        <t>
          An association session consists of an association request
          from a Relying Party to the IdP Endpoint URL. An association
          session is a direct request as specified in
          <xref target="direct_comm" /> with "openid.mode" set to
          "associate". There are several association session types
          defined. All association session types have a common
          parameter, "openid.assoc_type" that indicates the type of
          the established association.
        </t>

        <t>
          If the IdP supports the association session type and
          association type requested by the Relying Party, an
          association session is successful. If an IdP does not or
          chooses not to support the requested association or
          association session type, the association request is
          unsuccessful.
        </t>

        <section title="Request Parameters" toc="exclude">
          <t>
            These parameters are common to all association requests.
          </t>

          <t>
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "associate"
                  </t>
                </list>
              </t>

              <t>
                openid.session_type
                <list style='empty'>
                  <t>
                    Value: "no-encryption", "DH-SHA1" or "DH-SHA256"
                  </t>
                  <t>
                    Default: "no-encryption"
                  </t>
                  <t>
                    Note: It is RECOMMENDED that DH-SHA1 or DH-SHA256
                    be used to encrypt the MAC key.
                  </t>
                </list>
              </t>

              <t>
                openid.assoc_type
                <list style='empty'>
                  <t>
                    Value: Preferred association type. "HMAC-SHA1" or
                    "HMAC-SHA256"
                  </t>

                  <t>
                    Default: "HMAC-SHA1"
                  </t>

                  <t>
                    Note: If using a <xref
                    target="dh_sessions">Diffie-Hellman session
                    type</xref>, the hash algorithm for the
                    association session MUST have the same number of
                    bits as the hash algorithm for the association.
                  </t>
                </list>
              </t>

            </list>
          </t>
        </section>

        <section title="Successful Response Parameters" toc="exclude">
          <t>
            The format of responses to associate requests is
            <xref target="kvform">Key-Value pairs</xref>.
            All association session responses share the following
            fields:

            <list style='symbols'>
              <t>
                session_type
                <list style='empty'>
                  <t>
                    Value: The method of exchanging association
                    information that the IdP chose.
                  </t>
                  <t>
                    Default: "no-encryption"
                  </t>
                  <t>
                    Note: For backwards-compatibility, omit the
                    session_type when making "no-encryption"
                    responses, since the "no-encryption" session type
                    was implied by an absence of session_type in
                    previous specifications.
                  </t>
                </list>
              </t>

              <t>
                assoc_handle
                <list style='empty'>
                  <t>
                    Value: The handle for the association data
                    exchanged in this session.
                  </t>
                </list>
              </t>

              <t>
                assoc_type
                <list style='empty'>
                  <t>
                    Value: The association type for the returned
                    handle.
                  </t>
                  <t>
                    Note: When storing associations, the Relying Party MUST
                    map an assoc_handle to both its MAC key and its
                    assoc_type in order to be able to check signatures.
                  </t>
                </list>
              </t>

              <t>
                expires_in
                <list style='empty'>
                  <t>
                    Value: The number of seconds this association
                    handle is good for, represented in base 10 ASCII.
                  </t>
                  <t>
                    Note: Relying Parties MUST NOT use the association
                    resulting from this association session after the
                    specified number of seconds has elapsed.
                    <!-- XXX: recommendation on how to choose a value? -->
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Unencrypted Association Sessions">
          <t>
            If the IdP's Endpoint URL is an HTTPS URL, a
            "no-encryption" association session may be
            used. "no-encryption" association sessions also allow for
            Relying Parties or IdPs to be run in environments where
            there is no support for arbitrary precision arithmetic. In
            all other cases, "no-encryption" association sessions
            SHOULD NOT be used.
          </t>

          <t>
            An IdP MAY respond to an association request with a
            "no-encryption" association session response regardless of the
            type of association session requested. For better
            security, a Relying Party MAY choose not to use the
            resulting association on subsequent authentication
            requests.
          </t>

          <section title="Request Parameters" toc="exclude">
            <t>
              There are no extra parameters defined for a no-encryption
              association session request. To request a no-encryption
              association, leave blank the "openid.session_type" query
              parameter on the request.
            </t>
          </section>

          <section title="Response Parameters" toc="exclude">
            <t>
              The response to a no-encryption association session has the
              following extra fields:

              <list style="symbols">
                <t>
                  mac_key
                  <list style='empty'>
                    <t>
                      The MAC key for this association, <xref
                      target="RFC3548">Base 64</xref> encoded. The MAC
                      key MUST be the appropriate size for the
                      association type. For HMAC-SHA1, the MAC key
                      MUST be 20 bytes. For HMAC-SHA256, the MAC key
                      MUST be 32 bytes.
                    </t>
                  </list>

                </t>
              </list>
            </t>
          </section>
        </section>

        <section title="Diffie-Hellman Association Sessions"
                 anchor="dh_sessions">
          <t>
            OpenID supports two different kinds of associations
            based on Diffie-Hellman key exchange, "DH-SHA1" and
            "DH-SHA256". The MAC key MUST be the same
            length as the output of H, the hash function - 160 bits
            (20 bytes) for DH-SHA1 or 256 bits (32 bytes) for
            DH-SHA256.
          </t>

          <t>
            If the IdP does not support Diffie-Hellman,
            it MUST ignore the Diffie-Hellman fields in the request
            and reply with a no-encryption association session response.
            Relying Parties MAY choose to use "stateless mode" in this case.
          </t>

          <t>
            The Relying Party specifies a modulus, p, and a generator,
            g. The Relying Party chooses a random private key xa and
            Identity provider chooses a random private key xb, both in
            the range [1 .. p-1]. The shared secret used to encrypt
            the MAC key is thus g ^ (xa * xb) mod p = (g ^ xa) ^ xb
            mod p = (g ^ xb) ^ xa mod p. For more information, see
            <xref target='RFC2631' />. For information on the
            selection of random values, see <xref target="RFC1750" />.
          </t>

          <section title="Integer Representations" toc="exclude">
            <t>
              Arbitrary precision integers MUST be encoded as
              big-endian signed two's complement binary
              strings. Henceforth, "btwoc" is a function that takes an
              arbitrary precision integer and returns its shortest
              big-endian two's complement representation. All integers
              that are used with Diffie-Hellman are positive. This
              means that the left-most bit of the two's complement
              representation MUST be zero. If it is not, add a zero
              byte at the front of the string.
            </t>
            <t>Non-normative example:</t>
            <figure>
              <preamble />
              <artwork>
Base 10 number | btwoc string representation
---------------+----------------------------
0              | "\x00"
127            | "\x7F"
128            | "\x00\x80"
255            | "\x00\xFF"
32768          | "\x00\x80\x00"
              </artwork>
            </figure>
          </section>

          <section title='Request Parameters' toc="exclude">
            <t>
              <list style="symbols">
                <t>
                  openid.dh_modulus
                  <list style='empty'>
                    <t>Value: base64(btwoc(p))</t>
                    <t>Default: See <xref target='pvalue' /></t>
                  </list>
                </t>

                <t>
                  openid.dh_gen
                  <list style='empty'>
                    <t>Value: base64(btwoc(g))</t>
                    <t>Default: g = 2</t>
                  </list>
                </t>

                <t>
                  openid.dh_consumer_public
                  <list style='empty'>
                    <t>Value: base64(btwoc(g ^ xa mod p))</t>
                  </list>
                </t>
              </list>
            </t>
          </section>

          <section title='Response Parameters' toc="exclude">
            <t>
              <list>
                <t>
                  dh_server_public
                  <list style='empty'>
                    <t>
                      Value: base64(btwoc(g ^ xb mod p))
                    </t>
                    <t>
                      Description: The Provider's Diffie-Hellman
                      public key.
                    </t>
                  </list>
                </t>

                <t>
                  enc_mac_key
                  <list style='empty'>
                    <t>
                      Value: base64(H(btwoc(g ^ (xa * xb) mod p)) XOR MAC key)
                    </t>
                    <t>
                      Description: The MAC key, encrypted with the
                      secret Diffie-Hellman value. H is either SHA1 or
                      SHA256 depending on the session type.
                    </t>
                  </list>
                </t>
              </list>
            </t>
          </section>
        </section>
        <section title="Unsuccessful Response Parameters">
          <t>
            If the IdP does not support an association session type or
            association type, it MUST respond with a message
            indicating that the association session failed. If there
            is another association session type or association type
            that is supported, the IdP MAY include that information in
            the response.
          </t>
          <t>
            <list style='symbols'>
              <t>
                error
                <list style='empty'>
                  <t>
                    Value: (optional) A human-readable message
                    indicating why the association session failed
                  </t>
                </list>
              </t>
              <t>
                error_code
                <list style='empty'>
                  <t>
                    Value: "unsupported-type"
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style='empty'>
                  <t>
                    Value: (optional) A method of exchanging
                    association information that the IdP supports.
                  </t>
                </list>
              </t>

              <t>
                assoc_type
                <list style='empty'>
                  <t>
                    Value: (optional) An association type supported by
                    the IdP
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            Upon receipt of an "unsupported-type" response, the
            Relying Party MAY make another request with the specified
            association session type and association type. If no
            association is established, the Relying Party MAY continue
            the authentication process in stateless mode.
          </t>
        </section>
      </section>
    </section>

    <section title="Requesting Authentication"
             anchor="requesting_authentication">
      <t>
        Once the Relying Party has successfully performed discovery
        and optionally created an association with the discovered IdP
        Endpoint URL, it can send the End User to the IdP to obtain an
        assertion, using one of the mechanisms in <xref
        target="indirect_comm" />.
      </t>

      <section title="Request Parameters">
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  Note: This defines the interpretation of the openid
                  arguments without a namespace.  To be an OpenID 2.0
                  request, the given value must be present.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>
                  Value: "checkid_immediate" or "checkid_setup"
                </t>
                <t>
                  Note: If the Relying Party wishes the End User to be
                  able to interact with the IdP, "checkid_setup"
                  should be used. An example of a situation where
                  interaction between the End User and the IdP is not
                  desired is when the authentication request is
                  happening asynchronously in JavaScript.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) Delegate Identifier when
                  available, otherwise the Claimed Identifier
                </t>
                <t>
                  Note: The IdP MAY choose an identifier that belongs
                  to the End User if this is set to the special value
                  "http://openid.net/identifier_select/2.0".
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: (optional) A handle for an association
                  between the Relying Party and the IdP that should be
                  used to sign the response.
                </t>
                <t>
                  Note: If no association handle is sent,
                  the transaction will take place in "stateless mode."
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: URL to which the Provider SHOULD return the
                  User-Agent with additional responses indicating the
                  status of the request.
                </t>
              </list>
            </t>

            <t>
              openid.trust_root
              <list style='empty'>
                <t>
                  Value: (optional) URL pattern the Provider SHALL ask the End
                  User to trust. See <xref target="trust_roots" />.
                </t>
                <t>
                  Default: return_to URL
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      
      <section title="Trust Roots" anchor="trust_roots">
        <t>
          A "trust root" is a pattern that represents the part of
          URL-space for which an OpenID authentication request is
          valid. A trust root SHOULD give the End User an indication
          of the scope of the authentication request. IdPs SHOULD
          present the trust root when requesting the End User's
          approval for an authentication request. IdPs MAY use the
          trust root to allow the End User to automate approval of
          authentication requests.
        </t>

        <t>
          A trust root pattern is a URL, with the following changes:
          <list style="symbols">
            <t>
              A trust root MUST NOT contain a URI fragment
            </t>
            <t>
              A trust root MAY contain a wild-card at the beginning of
              the URL authority section.  A wild-card consists of the
              characters "*." prepended to the DNS name in the
              authority section of the URL.
            </t>
          </list>
        </t>

        <t>
          The "openid.return_to" URL MUST match the
          "openid.trust_root", or the IdP MUST return an error. A URL
          matches a trust root if:

          <list style="symbols">
            <t>
              The URL scheme (<xref target="RFC3986">RFC 3986, section
              3.1</xref>) and port of the URL are identical to
              those in the trust root.
            </t>

            <t>
              The URL's path is equal to or a sub-directory of the
              trust root's path.
            </t>

            <t>
              If the trust root's domain does not have a wild-card,
              the character "*", the URL's domain is identical to the
              trust root's domain. Otherwise, the trailing components
              of the URL's domain is identical to the components of
              the trust root following the wild-card.
            </t>
          </list>
                
        </t>

        <t>
          It is RECOMMENDED that IdP's protect their End Users from
          requests with overly-general trust roots, like http://*.com/
          or http://*.co.uk/. Whether a trust root is overly-general
          is at the discretion of the IdP.
        </t>
      </section>

      <section title="Immediate Requests">
        <t>
          When requesting authentication, the Relying Party MAY
          request that the IdP not interact with the End User, and
          instead respond immediately with either an assertion that
          they can and wants to proceed or a response indicating that
          the request cannot be completed without further user
          interaction.  This is accomplished by an authentication
          request with "openid.mode" set to "checkid_immediate".
        </t>
      </section>
    </section>

    <section title="Responding to Authentication Requests"
             anchor="responding_to_authentication">
      <t>
        An authentication request comes from the User-Agent. The IdP
        SHOULD identify the User-Agent, through some method of
        authentication or by browser session state, such as cookies.
        How the End User authenticates to the IdP is outside of the
        scope of OpenID Authentication. Once the End User has been
        identified, the IdP should determine if the End User wishes
        for this authentication request to complete. This
        determination is also out of the scope of OpenID
        Authentication. If the End User wishes for it to complete, the
        End User has approved authentication, and a positive assertion
        SHOULD be issued.
      </t>

      <t>
        Once the End User is known to the IdP, the IdP decides whether
        to issue an assertion as specified in
        <xref target="positive_assertions" />. If no Identifier was specified
        and there are Identifiers that are in the control of the End User,
        the IdP SHOULD allow the End User to choose an identifier to
        assert control over to the Relying Party.  If an Identifier
        was specified, the IdP SHOULD only issue assertions about the
        specified Identifier.
      </t>

      <t>
        In order to make an assertion, the IdP needs to have an
        association for the response. If the Relying Party supplied an
        association handle, the association information SHOULD be
        looked up based on that handle. If the association is expired
        or missing, the IdP SHOULD indicate to the Relying Party that
        the association was invalid by setting the value of
        "openid.invalidate_handle" to the Relying Party-specified
        handle. If an invalid association was sent, aside from
        including the "openid.invalidate_handle" parameter in the
        response, the IdP should treat the request the same as a
        request without an association handle specified.
      </t>

      <t>
        If no association handle is specified, the request is a "stateless
        mode" request. The IdP will create a private
        association for signing the response, and will respond to
        later requests to check the signature of that response.
      </t>

      <section title="Positive Assertions" anchor="positive_assertions">
        <t>
          If the End User approves the authentication, the Identity
          Provider sends a response back through the User-Agent with
          the following information as specified in
          <xref target="indirect_comm" />:

          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  Note: This defines the interpretation of the openid
                  arguments without a namespace.  To be an OpenID 2.0
                  response, the given value must be present.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>Value: "id_res"</t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The Identifier about which the IdP
                  is making a positive authentication assertion.
                </t>
                <t>
                  Note: The Identifier MAY be omitted if an extension
                  is in use that makes the response meaningful without
                  it.
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: Verbatim copy of the return_to URL parameter
                  sent in the request.
                </t>

                <t>
                  Note: Because the "openid.return_to" URL is signed
                  by the IdP, a Relying Party can make sure outside
                  parties haven't sent responses with query parameters
                  that were not included in the "openid.return_to"
                  URL.
                </t>

              </list>
            </t>

            <t>
              openid.nonce
              <list style='empty'>
                <t>
                  Value: A string that MUST be unique to this
                  particular successful authentication response. The
                  nonce MUST start with the current time on the
                  server, and MAY have additional characters appended
                  to the end as necessary to make each response
                  unique. The date and time MUST be formatted as
                  specified in section 5.6 of <xref target="RFC3339"
                  />, with the following restrictions: <list
                  style="symbols"> <t> All times must be in the UTC
                  timezone, indicated with a "Z".  </t> <t> No
                  fractional seconds are allowed </t> </list> For
                  example: 2005-05-15T17:11:51ZXXXX
                </t>
              </list>
            </t>

            <t>
              openid.invalidate_handle
              <list style='empty'>
                <t>
                  Value: (optional) If the Relying Party sent an invalid
                  association handle with the request, it should be
                  included here.
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: The handle for the association that was used
                  to sign this assertion.
                </t>
              </list>
            </t>

            <t>
              openid.signed
              <list style='empty'>
                <t>
                  Value: (optional) Comma-separated list of signed
                  fields.
                </t>
                <t>
                  Note: If the association used to sign this response
                  used the Signed-List algorithm, this MUST be
                  present.  If it is present, this entry consists of
                  the fields without the "openid." prefix that the
                  signature covers. This list MUST contain at least
                  "return_to" and "nonce". Additionally, if the server
                  is making an assertion about an identifier, the
                  identity field MUST be present. For example,
                  "identity,return_to,nonce".
                </t>
              </list>
            </t>

            <t>
              openid.sig
              <list style='empty'>
                <t>
                  Value: Base 64 encoded signature calculated as
                  specified in <xref target="generating_signatures"/>.
                </t>
              </list>
            </t>

          </list>
        </t>
      </section>

      <section title="Verifying Assertions">
        <t>
          If the Relying Party receives a positive assertion, it MUST
          verify the following before accepting the assertion:

          <list style="symbols">
            <t>
              An assertion has not yet been accepted from this
              IdP with the same value for "openid.nonce"
            </t>

            <t>
              The signature on the assertion is valid
            </t>

            <t>
              Discovered information from the Identifier matches the
              information in the assertion.
            </t>
          </list>
        </t>

        <section title="Verifying Discovered Information">
          <t>
            Either the Identifier in the assertion points to the
            OpenID IdP making the assertion, or the assertion is being
            made using <xref
            target="delegating_authentication">delegation</xref> and
            the Identifier with the delegate information points to
            that IdP, and specifies the identifier in the assertion as
            a delegate. Specifically, the Relying Party MUST have
            performed <xref target="discovery">discovery</xref> on the
            Identifier that will be used and the information in the
            assertion MUST match the discovered information. When the
            Claimed Identifier was not present in the request
            ("openid.identity" was
            "http://openid.net/identifier_select/2.0"), the Relying
            Party MUST perform discovery on the identifier in the
            response to make sure that the IdP is authorized to make
            assertions about the identifier.
          </t>

          <t>
            To prevent replay attacks, the Relying Party SHOULD keep
            track of the nonce values included in positive assertions
            and never accept the same value more than once for the
            same association. The Relying Party MAY use the time-stamp
            to reject responses that are outside of a range it has
            chosen as accpetable, limiting the amount of time that
            nonces must be stored to prevent replays.
          </t>

        </section>

        <section title="Verifying Signatures"
                 anchor="verifying_signatures">
          <t>
            If the Relying Party has stored an association with the
            association handle specified in the assertion, it MUST
            check the signature on the assertion itself. If no
            association is found, it MUST request that the IdP verify
            the signature.
          </t>

          <section title="Verifying with an Association" toc="exclude">
            <t>
              The Relying Party follows the same procedure that the
              IdP followed in <xref target= "generating_signatures">
              generating the signature</xref>, and then compares the
              signature in the response to the signature it
              generates. If the signatures do not match, the assertion
              is invalid.
            </t>
          </section>

          <section title="Verifying Directly with the Identity Provider"
                   toc="exclude" anchor="check_auth">
            <t>
              If the association handle is not recognized, the Relying Party
              MUST attempt to contact the IdP to verify
              the signature. The Relying Party generates a POST to the
              IdP Endpoint URL with the signed values from
              the assertion and the association information. The
              response to that request indicates whether the signature
              is correct.
            </t>

            <t>
              When the IdP is verifying the signature, the
              "openid.mode" value MUST be changed to "id_res".
            </t>

            <t>
              An IdP MUST NOT verify signatures for associations that
              have shared MAC keys. If an IdP did verify signatures
              for associations with shared MAC keys, it would be
              possible for parties other than the IdP to create valid
              assertions that seemed to come from the IdP.
            </t>

            <t>
              The IdP SHOULD only return is_valid once for each
              authentication request. An authentication request may be
              identified by its "openid.nonce" value.
            </t>

            <t>
              Implementation Note for Stateless Relying Parties:
              The Relying Party must verify the signature at the same
              IdP Endpoint from which it was issued.  In the event
              that there are multiple endpoints defined for a Claimed
              Identifier, this requires the Relying Party to remember
              the endpoint with whom they are conversing.  The Relying
              Party MAY choose to encode this information in a parameter
              on the return_to URL it provides in the id_res request.
              That encoded data MUST be signed to prevent tampering from
              malicious agents.
            </t>

            <section title='Request Parameters' toc="exclude">
              <t>
                <list style='symbols'>
                  <t>
                    openid.mode
                    <list style='empty'>
                      <t>Value: "check_authentication"</t>
                    </list>
                  </t>

                  <t>
                    Exact copies of all fields from the id_res
                    response, except for "openid.mode".
                  </t>
                </list>
              </t>
            </section>

            <section title='Response Parameters' toc="exclude">
              <t>Response format: Key-Value Pairs</t>

              <t>
                <list style='symbols'>
                  <t>
                    is_valid
                    <list style='empty'>
                      <t>Value: "true" or "false"</t>
                      <t>Description: Boolean; whether the signature is
                      valid.</t>
                    </list>
                  </t>

                  <t>
                    invalidate_handle
                    <list style='empty'>
                      <t>
                        Value: (optional) An association handle
                      </t>
                      <t>
                        Description: The association handle sent in
                        the request, if the server confirms that it is
                        invalid. After receiving an invalidate_handle
                        for a particular association handle, the
                        Relying Party SHOULD NOT use the association
                        with that handle again.
                      </t>
                    </list>
                  </t>
                </list>
              </t>
            </section>
          </section>
        </section>
      </section>

      <section title="Identifying the End User" anchor="identifying">
        <t>
          A successful authentication response provides the Relying
          Party with a Verified Identifier, which MAY be used as a
          user-visible identifier.  Identifiers in OpenID MUST be URLs
          or XRIs. If the identifier is a URL, its scheme MUST be
          "http" or "https".  Except in the case that the Verified
          Identifier is an XRI, the Relying Party SHOULD use the
          Verified Identifier as a key for local storage of
          information about the End User.  If the Verified Identifier
          is an XRI, the discovered CanonicalID field from the XRD
          SHOULD be used as a key for local storage of information
          about the End User.
        </t>

        <t>
          If a request is using delegation, the Verified Identifier is
          the Identifier on which discovery was performed, and not the
          identifier that is contained in the assertion. If an
          assertion is made for an Identifier on which discovery has
          not been performed, the Relying Party MUST perform discovery on
          that Identifier and compare the discovered information to
          that in the assertion.
        </t>

        <section title="HTTP and HTTPS URL Identifiers">
          <t>
            Relying Parties MUST differentiate between URL Identifiers
            that have different schemes. When user input is processed
            into a URL, it is processed into a HTTP URL. If the same
            End User controls the same URL, differing only by scheme,
            and it is desired that the Identifier be the HTTPS URL, it
            is RECOMMENDED that a redirect be issued from the HTTP URL
            to the HTTPS URL. Because the HTTP and HTTPS URLs are not
            equivalent and the Identifier that is used is the URL
            after following redirects, there is no reduction in
            security when using this scheme. If an attacker could gain
            control of the HTTP URL, it would have no effect on the
            HTTPS URL, since the HTTP URL is not ever used as an
            Identifier.
          </t>
        </section>
      </section>
        
      <section title="Negative Assertions" anchor="negative_assertions">
        <t>
          The IdP sends a response back through the User-Agent if it
          is unable to identify the End User or the End User does not
          or cannot approve the request.
        </t>

        <section title="In Response to Immediate Requests">
          <t>
            If the request was an immediate request, there is no chance
            for the End User to interact with pages on the IdP to provide
            identifying credentials or approval of a request.
            A negative assertion of an immediate request takes the
            following form:
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>Value: "id_res"</t>
                </list>
              </t>

              <t>
                openid.user_setup_url
                <list style='empty'>
                  <t>
                    Value: A URL that the End User may visit to complete the
                    request. The Relying Party may redirect the End User to
                    this URL, or provide the End User with a link that points
                    to this URL.  The request is no longer immediate.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="In Response to Non-Immediate Requests">
          <t>
            Since the IdP may display pages to the End User and
            request credentials from the End User, a negative response to a
            request that is not immediate is definitive.  It takes the
            following form:
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>Value: "cancel"</t>
                </list>
              </t>
            </list>
          </t>

          <t>
            In a lot of cases, the Relying Party won't get a cancel
            mode response; the End User will just quit or press back
            within their User-Agent. But if it is returned, the
            Relying Party SHOULD return to what it was doing.
          </t>
        </section>
      </section>

    </section>

    <section title="Extensions" anchor="extensions">
      <t>
        An Extension to OpenID is a protocol that rides on top of the
        OpenID authentication request and response. Extensions are
        useful for providing extra information about an authentication
        request or response or providing extra information about the
        subject of the authentication response.
      </t>

      <t>
        OpenID extensions are identified by a URI. The URI MAY be used
        as the value of an &lt;xrd:Type&gt; element of an OpenID
        &lt;xrd:Service&gt; element in an XRDS document associated
        with a Claimed Identifier. It is also used to associate
        key-value pairs in messages with the extension.
      </t>
      
      <t>
        <!-- XXX: openid. only for indirect messages -->
        To associate keys and values in a message with an extension,
        the key MUST be associated with the Type URI. To associate
        keys with a Type URI, establish an alias by adding a key
        prefixed with "openid.ns." and ending with the alias text
        whose value is the Type URI. Once an alias has been
        established, all pairs in the message whose keys start with
        "openid." followed by the alias text, followed by a period or
        the end of the key are associated with that extension.
      </t>

      <t>
        A namespace alias MUST NOT contain a period, MUST NOT be the
        name of a field in a message defined in this specification,
        and MUST NOT be the same as another namespace alias in the
        same message. A namespace MUST NOT be assigned more than one
        alias in the same message. If a message is a response to
        another message, the response MAY use a different alias to
        refer to the same namespace.
      </t>

      <t>
        <!-- XXX: fixme -->
        Non-normative example: An extension's type URI is
        &lt;http://example.com/ext/1.0&gt;.
        
        <list style="empty">
          <t>openid.ns.x=http://example.com/ext/1.0</t>
          <t>openid.x=example</t>
          <t>openid.x.foo=bar</t>
          <t>openid.xx=notx</t>
        </list>
        
        In this example, the keys openid.x and openid.x.foo are
        associated with the extension. The openid.xx key is not.
      </t>
    </section>

    <section title="Discovering OpenID Relying Parties">
      <t>
        Relying Parties are RECOMMENDED to use the Yadis protocol to
        publish their return_to URL. This allows for automated
        discovery of OpenID Relying Parties.
      </t>
      
      <t>
        The Relying Party's XRDS document's &lt;xrd:Service&gt; entry
        should have the return_to URL as the content of the
        &lt;xrd:URI&gt; tag and should have
        http://openid.net/return_to/2.0 as the content of the
        &lt;xrd:Type&gt; tag.
      </t>
      
      <figure>
        <preamble>For example:</preamble>
        <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/return_to/2.0</Type>
  <URI>http://consumer.example.com/return</URI>
</Service>
]]></artwork>
      </figure>
    </section>
    
    <section title="Security Considerations">
      <section title="Preventing Attacks">
        <section title="Eavesdropping Attacks">
          <t>
            There are two places in this specification that are
            vulnerable to eavesdropping attacks. An eavesdropper could
            intercept an unencrypted association session and recover
            the shared secret, allowing an attacker to masquerade as
            the IdP to that relying party. An eavesdropper could also
            intercept a successful authentication assertion and re-use
            it, if the nonce is not checked.
          </t>

          <t>
            Both of these attacks can be prevented by using SSL for
            these connections. The association session can also use
            Diffie-Hellman instead of "no-encryption" to protect from
            eavesdropping. If the nonce is checked in message
            verification, the positive authentication assertion cannot
            be re-used.
          </t>
        </section>

        <section title="Man-in-the-Middle Attcks">
          <t>
            Associations prevent tampering of signed fields by a man
            in the middle, except during discovery, association
            sessions and stateless mode. Altering signed fields
            without the shared secret requires breaking the
            MAC. Currently, there is no tractable attack on the MACs
            used in this protocol. The quality of the protection
            provided by the MAC depends on the randomness of the
            shared MAC key, so it is important that an unguessable
            value be used.
          </t>

          <t>
            If DNS resolution or the transport layer is compromised,
            signatures on messages are not adequate, since the
            attacker can impersonate the IdP and issue its own
            associations, or its own decisions in stateless mode. If
            an attacker can tamper with the discovery process, he can
            specify any IdP, and so does not have to impersonate the
            IdP.
          </t>

          <t>
            SSL with certificates signed by a trusted authority
            prevents these kinds of attacks by verifying the results
            of the DNS lookup against the certificate. Once the
            validity of the certificate has been established,
            tampering is not possible. Impersonating an SSL server
            requires forging or stealing a certificate, which is
            significantly harder than the network attacks.
          </t>

          <t>
            In order to get protection from SSL, SSL must be used for
            all parts of the interaction, including interaction with
            the user through the browser.
          </t>
        </section>
      </section>

      <section title="User Agents">
        <t>
          Since this protocol is intended to be used interactively,
          User Agents will primarily be common Web browsers. Web
          browsers or their hosts may be infected with spyware or
          other malware, which limits the strength of the
          authentication assertion, since untrusted software makes it
          impossible to know whether the authentication decision has
          been made with the End User's approval.
        </t>

        <t>
          Cross-site-scripting attacks against IdPs may be used to the
          same effect. For the best security, IdPs should not depend
          on scripting so that User Agents without scripting enabled
          can make authentication decisions.
        </t>
      </section>

      <section title="User Interface Considerations">
        <t>
          The Relying Party SHOULD redirect the End User to the IdP
          Endpoint URL in a top-level browser window with all controls
          visible. This allows better protection for the End User
          against IdP look-alike sites (phishing).
        </t>
      </section>
    </section>

    <appendix title="Examples">
      <t>Non-normative</t>

      <appendix title="Delegation">
        <t>
          For example, an End User wants to use
          http://www.example.com/ as their Identifier, but
          http://www.example.com/ doesn't have the means, or desire,
          to run an IdP. LiveJournal is an Identity
          Provider, so if the End User has a LiveJournal OpenID
          Identifier, they can delegate their authentication to
          LiveJournal.
        </t>
      </appendix>

      <appendix title="XRDS">
        <t>
          <figure>
            <preamble>
              To use www.example.com as their Identifier, but have
              Relying Parties actually verify
              http://exampleuser.livejournal.com/ with the Identity
              Provider located at
              http://www.livejournal.com/openid/server.bml, the
              following XML snippet should be present in the final XRD
              in the XRDS file:
            </preamble>
            <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/signon/2.0</Type>
  <URI>http://www.livejournal.com/openid/server.bml</URI>
  <Delegate xmlns="http://openid.net/signon/2.0">
    http://exampleuser.livejournal.com/
  </Delegate>
</Service>
]]></artwork>
          </figure> 
        </t>
      </appendix>

      <appendix title="HTML Identifier Markup">
        <figure>
          <preamble>
            To use www.example.com as their Identifier, but have
            Relying Parties actually verify
            http://exampleuser.livejournal.com/ with the Identity
            Provider located at
            http://www.livejournal.com/openid/server.bml, the
            following markup should be present in the &lt;head&gt;
            of the HTML document located by the identifier URL:
          </preamble>
          <artwork><![CDATA[
<link rel="openid.server"
      href="http://www.livejournal.com/openid/server.bml"/>
<link rel="openid.delegate"
      href="http://exampleuser.livejournal.com/"/>
]]></artwork>
        </figure> 
      </appendix>

      <appendix title="Login Form">
        <t>
          Continuing this example, the End User visits a Relying Party site
          which supports OpenID Authentication.  The Relying Party presents
          the End User with a form field for them to enter their
          Identifier or their IdP's identifier.
        </t>

        <t>
          <figure>
            <preamble>For Example:</preamble>
            <artwork>
              ----------------------------------
              |[logo]example.com               | [Login Button]
              ----------------------------------
            </artwork>
          </figure>
        </t>
      </appendix>

      <appendix title="XRI CanonicalID">
        <t>
          For example, if =example and =exmpl both yield an XRD
          document with the CanonicalID xri://(example)!1234 then
          those identifiers should be treated as equivalent. For
          applications with user accounts, those identifiers should
          both be attached to the same account.
        </t>
      </appendix>
    </appendix>

    <appendix title='Diffie-Hellman Default Value' anchor="pvalue">
      <figure>
        <preamble>
          This is a confirmed-prime number, used as the default
          modulus for Diffie-Hellman key exchange. In hexadecimal:
        </preamble>
        <artwork>
DCF93A0B883972EC0E19989AC5A2CE310E1D37717E8D9571BB7623731866E61E
F75A2E27898B057F9891C2E27A639C3F29B60814581CD3B2CA3986D268370557
7D45C2E7E52DC81C7A171876E5CEA74B1448BFDFAF18828EFD2519F14E45E382
6634AF1949E5B535CC829A483B8A76223E5D490A257F05BDFF16F2FB22C583AB
        </artwork>
      </figure>
    </appendix>

    <!-- XXX: An example for Generating Signatures might be nice. -->

    <appendix title="Changes from the Previous OpenID Specification">
      <t>
        This specification is based on the original specification for
        OpenID as written by Brad Fitzpatrick. That specification did
        not have a version number, but was called OpenID 1.0, and then
        OpenID 1.1 when it was revised.  The protocol outlined in this
        specification is intended to be backwards-compatible with the
        revised OpenID protocol.  The most significant changes to the
        specification are outlined in this section.
      </t>
      <appendix title="Updated Initiation and Discovery">
        <t>
          <list style="symbols">
            <t>
              Supports IdP-driven identifier selection. This new
              variation of the protocol flow is initiated by entering
              an Identifier for an IdP instead of an Identifier for an
              End User, and allows the IdP to assist the End User in
              selecting an Identifier.
            </t>
            <t>
              Supports the use of XRIs as Identifiers. XRIs may be
              used as Identifiers for both End Users and IdPs.
            </t>
            <t>
              When URLs are used as Identifiers, they are normalized
              according to RFC 3986, for better compatibility with
              existing Web infrastructure.
            </t>
            <t>
              Uses the Yadis protocol for discovery. This allows for
              using multiple IdPs for a single Identifier, for
              load-balancing and fallback in the case of IdP
              failure. Additionally, it allows for discovery of
              supported extensions.
            </t>
          </list>
        </t>
      </appendix>

      <appendix title="Security improvements">
        <t>
          A nonce is now part of the protocol for built-in protection
          against replay attacks.
        </t>
        <t>
          A new association type, HMAC-SHA256, and a new association
          session type, DH-SHA256, allow for stronger signatures on
          authentication assertions.
        </t>
      </appendix>

      <appendix title="Extensions">
        <t>
          Extensions are a new mechanism to support data exchange and
          other Relying Party-IdP communication along with the
          authentication exchange. Extensions allow for the exchange
          of arbitrary attributes, as well as for protocol extensions,
          such as the inclusion of additional information about the
          Relying Party in the authentication request.
        </t>
        <t>
          Because extensions can transfer arbitrary data, the
          Identifier is now optional in the response.
        </t>
      </appendix>
    </appendix>
  </middle>

  <back>
    <references title='Normative References'>
      <reference anchor='RFC2119'>
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials='B.S' surname='Bradner' fullname='Scott Bradner'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>
      <reference anchor='RFC3986'>
        <front>
          <title>Uniform Resource Identifiers (URI): Generic Syntax</title>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC1750'>
        <front>
          <title>Randomness Recommendations for Security</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Digital Equipment Corporation</organization>
          </author>
          <author initials='S.C' surname='Crocker'
                  fullname='Stephen D. Crocker'>
            <organization>CyberCash, Inc.</organization>
          </author>
          <author initials='J.S' surname='Schiller'
                  fullname='Jeffery I. Schiller'>
            <organization>Massachusetts Institute of Technology</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC2631'>
        <front>
          <title>Diffie-Hellman Key Agreement Method</title>
          <author initials='E.R' surname='Rescorla'
                  fullname='Eric Rescorla'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2631" />
      </reference>
      <reference anchor='RFC3548'>
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials='S.J' surname='Josefsson'
                  fullname='Simon Josefsson'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3548" />
      </reference>
      <reference anchor='RFC2104'>
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>
          <author initials='H.K' surname='Krawczyk' fullname='Hugo Krawczyk'>
            <organization>IBM</organization>
          </author>
          <author initials='M.B' surname='Bellare' fullname='Mihir Bellare'>
            <organization>UCSD</organization>
          </author>
          <author initials='R.C' surname='Canetti' fullname='Ran Canetti'>
            <organization>IBM</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2104" />
      </reference>
      <reference anchor='FIPS180-2'>
        <front>
          <title>Secure Hash Signature Standard</title>
          <author>
            <organization>U.S. Department of Commerce</organization>
          </author>
          <author>
            <organization>National Institute of Standards 
              and Technology</organization>
          </author>
        </front>
        <seriesInfo name="FIPS" value="180-2" />
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf" />
        <annotation>Defines Secure Hash Algorithm 256 (SHA256)</annotation>
      </reference>
      <reference anchor='HTML401'>
        <front>
          <title>HTML 4.01 Specification</title>
          <author>
            <organization>W3C</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.w3.org/TR/html401" />
      </reference>
      <reference anchor='RFC2616'>
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
          <author initials='R.F' surname='Fielding' fullname='R. Fielding'>
            <organization>UC Irvine</organization>
          </author>
          <author initials='J.G' surname='Gettys' fullname='J. Gettys'>
            <organization>Compaq/W3C</organization>
          </author>
          <author initials='J.M' surname='Mogul' fullname='J. Mogul'>
            <organization>Compaq</organization>
          </author>
          <author initials='H.F' surname='Frystyk' fullname='H. Frystyk'>
            <organization>W3C/MIT</organization>
          </author>
          <author initials='L.M' surname='Masinter' fullname='L. Masinter'>
            <organization>Xerox</organization>
          </author>
          <author initials='P.L' surname='Leach' fullname='P. Leach'>
            <organization>Microsoft</organization>
          </author>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization>W3C/MIT</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2616" />
      </reference>
      <reference anchor='RFC3174'>
        <front>
          <title>US Secure Hash Algorithm 1 (SHA1)</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Motorola</organization>
          </author>
          <author initials='P.J' surname='Jones' fullname='Paul E. Jones'>
            <organization>Cisco Systems, Inc.</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor='RFC3339'>
        <front>
          <title>Date and Time on the Internet: Timestamps</title>
          <author initials='C.N' surname='Newman'
                  fullname='Chris Newman'>
            <organization>Sun Microsystems</organization>
          </author>
          <author initials='G.K' surname='Klyne' fullname='Graham Klyne'>
            <organization>Clearswift Corporation</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor="XRI Syntax 2.0"
                 target="http://www.oasis-open.org/committees/download.php/15376#_Toc117301848" >

        <front>
          <title>Extensible Resource Identifier (XRI) Syntax V2.0</title>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='D.M' surname='McAlpin' fullname="Dave McAlpin">
            <organization>Epok</organization>
          </author>
        </front>
        <format type="HTML" target=
                "http://www.oasis-open.org/committees/download.php/15376" />
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/15377" />
      </reference>
      <reference anchor="Yadis"
                 target="http://yadis.org/papers/yadis-v1.0.pdf" >
        <front>
          <title>Yadis Specification 1.0</title>
          <author initials='J.M' surname='Miller' fullname="Joaquin Miller">
            <organization>NetMesh</organization>
          </author>
        </front>
      </reference>
    </references>
  </back>
</rfc>
