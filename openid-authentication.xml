<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="info" ipr="none" docName="openid-authentication-2_0-11.xml">
  <?xml-stylesheet type='text/xsl'
    href='http://xml.resource.org/authoring/rfc2629.xslt' ?>

  <?rfc toc="yes" ?>
  <?rfc tocdepth="2" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc iprnotified="no" ?>
  <?rfc strict="yes" ?>
  <?rfc private="Pre-Draft" ?>

  <front>
    <title>OpenID Authentication 2.0 - Pre-Draft 11</title>

    <author initials="D.R" surname="Recordon" fullname="David Recordon">
      <organization abbrev="VeriSign">VeriSign, Inc.</organization>
      <address>
        <postal>
          <street>487 E Middlefield Road</street>
          <city>Mountain View</city> <region>CA</region>
          <code>94109</code>
          <country>USA</country>
        </postal>
        <email>drecordon@verisign.com</email>
      </address>
    </author>

    <author initials="J.H" surname="Hoyt" fullname="Josh Hoyt">
      <organization abbrev="JanRain">JanRain, Inc.</organization>
      <address>
        <postal>
          <street>5331 SW Macadam Avenue</street>
          <street>Suite #375</street>
          <city>Portland</city> <region>OR</region>
          <code>97239</code>
          <country>USA</country>
        </postal>
        <email>josh@janrain.com</email>
      </address>
    </author>

    <author initials="D.H" surname="Hardt" fullname="Dick Hardt">
      <organization abbrev="Sxip">Sxip Identity Corporation</organization>
      <address>
        <postal>
          <street>798 Beatty Street</street>
          <city>Vancouver</city> <region>BC</region>
          <code>V6B 2M1</code>
          <country>Canada</country>
        </postal>
        <email>dick@sxip.com</email>
      </address>
    </author>

    <author initials="B.F" surname="Fitzpatrick"
            fullname="Brad Fitzpatrick">
      <organization abbrev="Six Apart">Six Apart, Ltd.</organization>
      <address>
        <postal>
          <street>548 4th Street</street>
          <city>San Francisco</city> <region>CA</region>
          <code>94107</code>
          <country>USA</country>
        </postal>
        <email>brad@danga.com</email>
      </address>
    </author>

    <date month="December" year="2006"/>

    <abstract>
      <t>
        OpenID Authentication provides a way to prove that an End User
        owns an Identifier. It does this without the Relying Party needing 
        access to password, email address, or other sensitive information.
      </t>

      <t>
        OpenID is decentralized. No central authority must approve or
        register Relying Parties or Identity Providers. An End User
        can freely choose which Identity Provider to use and they can
        preserve their Identifier if they switch Identity Providers.
      </t>

      <t>
        While nothing in the protocol requires JavaScript or modern
        browsers, the authentication scheme plays nicely with
        "AJAX"-style setups. This means an End User can prove their
        Identity to a Relying Party without having to leave the page
        they are on.
      </t>

      <t>
        As OpenID Authentication uses only standard HTTP(S) requests and
        responses, it does not require any special capabilities of the
        User-Agent or other software. Extensions to User-Agent's can
        simplify the End User interaction, though are not required to
        utilize the protocol.
      </t>

      <t>
        The exchange of profile information, and other features not
        covered in this specification, is addressed through additional
        Service Types built on top of OpenID. OpenID Authentication is
        designed to provide a base framework to enable portable
        user-centric digital identity in a free and decentralized
        manner.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119"/>.</t>
    </section>

    <section title="Terminology">
      <t>
    <list style="hanging">
      <t hangText="Identifier:">
        An Identifier is a "http" or "https" URI, which is commonly
        referred to as a "URL" within this document, or <eref
        target="http://www.oasis-open.org/committees/download.php/15376"
        >XRI</eref>.  An "Identifier" may be a Claimed Identifier,
        Delegate Identifier, IdP Identifier, or Verified Identifier,
        depending on context.
      </t>

      <t hangText="End User:">
        The person who wants to prove ownership of an Identifier.
      </t>

      <t hangText="User-Agent:">
        The End User's Web browser. See <xref target="RFC2616"/>.
      </t>

      <t hangText="Claimed Identifier:">
        An Identifier that the End User claims to own which has not yet
        been verified by the Relying Party.
      </t>

      <t hangText="Verified Identifier:">
        An Identifier that the End User has proven to a Relying Party
        that they own.
      </t>

      <t hangText="Delegate Identifier:">
        An alternate Identifier that can be included in the discovery
        response.
      </t>

      <t hangText="Relying Party:">
        RP. A Web application that wants proof that the End User owns an
        Identifier.
      </t>

      <t hangText="Identity Provider:">
        IdP. This is the OpenID Authentication server
        that a Relying Party contacts for cryptographic proof that the
        End User owns an Identifier.
      </t>

      <t hangText="IdP Identifier:">
        An Identifier for an Identity Provider.
      </t>

      <t hangText="Diffie-Hellman Key Exchange:">
         Diffie-Hellman Key Exchange <xref target="RFC2631" /> is a
         protocol that allows two parties to share a secret, while
         preventing eavesdroppers from learning the secret.
      </t>  
    </list>
      </t>
    </section>

    <section title="Protocol Overview">

      <t>
        <list style="numbers">
          <t>
            The End User <xref target="initiation">initiates
            authentication</xref> by supplying an Identifier to the
            Relying Party via their User Agent.
          </t>
          <t>
            The Relying Party <xref target="discovery">performs
            discovery</xref> on the Claimed Identifier and establishes
            the location of the IdP's endpoint that the End User uses
            for authentication.
          </t>
          <t>
            (optional) 

            The Relying Party and the IdP establish an <xref
            target="associations">association</xref> -- a shared
            secret established using Diffie-Hellman Key Exchange. The
            IdP uses an association to sign subsequent messages and
            the Relying Party to verify those messages.
          </t>
          <t>
            The Relying Party redirects the End User's User Agent to
            the IdP with an OpenID <xref
            target="requesting_authentication">Authentication
            request</xref>.
          </t>
          <t>
            The IdP establishes whether the End User is authorized to
            perform OpenID Authentication and wishes to do so. The
            manner in which the End User authenticates to their IdP is
            beyond the scope of this document.
          </t>
          <t>
            The IdP redirects the End User's User Agent back to the
            Relying Party with an indication either that <xref
            target="positive_assertions">authentication is
            approved</xref> or <xref
            target="negative_assertions">authentication failed</xref>.
          </t>
          <t>
            The Relying Party <xref
            target="verification">verifies</xref> the information
            received from the IdP.
           </t>
         </list>
      </t>
    </section>


    <section title="Data Formats" anchor="formats">

      <section title="Protocol Messages">

        <t>
          The OpenID Authentication protocol messages are
          mappings of plain-text keys to plain-text values. The keys and
          values are Unicode strings. When the keys and values need to
          be converted to bytes, they MUST be encoded using UTF-8.  <!--
          reference unicode, UTF-8! -->
        </t>
        
        <section title="Key-Value Form Encoding" anchor="kvform">
          <t>
            A Key-Value form message is a sequence of lines.  Each
            line begins with a key, followed by a colon, and the value
            associated with the key.  The line is terminated by a
            single newline (codepoint 10, "/n"). A key or value MUST NOT
            contain a newline and a key also MUST NOT contain a colon.
          </t>
          <t>
            Additional characters, including whitespace, MUST NOT be
            added before or after the colon or newline. The message
            MUST be encoded in UTF-8 to produce a byte string.
          </t>
          <t>
            Key-Value Form encoding is used for signature calculation
            and for <xref target="direct_response">direct
            responses</xref> to Relying Parties.
          </t>
        </section>
 
        <section title="HTTP Encoding" anchor="queries">

          <t>
            When a message is sent to an HTTP server, it MUST be encoded
            using a form encoding specified in Section 17.13.4 of
            <xref target="HTML401" />. Likewise, if the "Content-Type"
            header is included in the request headers, its value MUST
            also be such an encoding.
          </t>
          <t>
            All of the keys in the request message MUST be prefixed
            with "openid.". This prefix prevents interference with
            other parameters that are passed along with the OpenID
            Authentication message. When a message is sent as a POST,
            the application processing the HTTP request MUST only use
            the values in the POST body and MUST ignore any GET
            parameters.
          </t>
          <t>
            This model applies to messages from the User Agent to both
            the Relying Party and the IdP, as well as messages from the
            Relying Party to the IdP.
          </t>
        </section>
        <section title="Example">
          <t>
            Non-normative
          </t>
          <t>
            <figure>
              <preamble>
                The following examples encode the following information:
              </preamble>
              <artwork><![CDATA[
Key     | Value
--------+---------------------------
mode    | error
error   | This is an example message
]]>
              </artwork>
            </figure>
          </t>
          <t>
            <figure>
              <preamble>
                Key-Value Form encoded:
              </preamble>
              <artwork><![CDATA[mode:error
error:This is an example message
]]>
              </artwork>
            </figure>
            <figure>
              <preamble>
                x-www-urlencoded, as in a HTTP POST body or in a URL's
                query string (<xref target="RFC3986" /> section 3):
              </preamble>
              <artwork>openid.mode=error&amp;openid.error=This%20is%20an%20example%20message</artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Integer Representations" anchor="btwoc">
        <t>
          Arbitrary precision integers MUST be encoded as big-endian
          signed two's complement binary strings. Henceforth,
          "btwoc" is a function that takes an arbitrary precision
          integer and returns its shortest big-endian two's
          complement representation. All integers that are used with
          Diffie-Hellman are positive. This means that the left-most
          bit of the two's complement representation MUST be
          zero. If it is not, implementations MUST add a zero byte
          at the front of the string.
        </t>
        <figure>
          <preamble>Non-normative example:</preamble>
          <artwork>
Base 10 number | btwoc string representation
---------------+----------------------------
0              | "\x00"
127            | "\x7F"
128            | "\x00\x80"
255            | "\x00\xFF"
32768          | "\x00\x80\x00"
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Communication Types" anchor="communication">
      <section title="Direct Communication"
               anchor="direct_comm">
        <t>
          Direct communication is initiated by a Relying Party to an
          IdP endpoint URL.  It is used for <xref
          target="associations">establishing associations</xref> and
          <xref target="check_auth">verifying authentication
          assertions</xref>.
        </t>
        <section title="Direct Request" anchor="direct_request">
          <t>
            The message MUST be encoded as a POST body, as specified
            by <xref target="queries" />.
          </t>
        </section>
        <section title="Direct Response" anchor="direct_response">
          <t>
            The body of a response to a <xref
            target="direct_request">Direct Request</xref> consists of
            an HTTP Response body in <xref target="kvform">Key-Value
            Form</xref>. The content-type of the response SHOULD be
            "text/plain".
          </t>
           <section title="Successful Responses">
            <t>
              A server receiving a properly formed request MUST send a
              response with an HTTP status code of 200.
            </t>
          </section>

          <section title="Error Responses">
            <t>
              If a request is malformed or contains invalid arguments,
              the server MUST send a response with a status code of
              400. The response body MUST be a Key-Value Form <xref
          target="kvform"/> message with the following fields:
            </t>
            <t>
              <list style='symbols'>
                <t>
                  error
                  <list style='empty'>
                    <t>
                      Value: Unstructured text error message.
                    </t>
                  </list>
                </t>

                <t>
                  contact
                  <list style='empty'>
                    <t>
                      Value: (optional) Contact address for the
                      administrator of the sever. The contact address
                      may take any form, as it is intended to be
                      displayed to a person.
                    </t>
                  </list>
                </t>

                <t>
                  reference
                  <list style='empty'>
                    <t>
                      Value: (optional) A reference identifier, such
                      as a support ticket number or a URL to a news
                      blog, etc.
                    </t>
                  </list>
                </t>
              </list>
               The IdP MAY add additional fields to this response.
            </t>
          </section>
        </section>
      </section>
      <section title="Indirect Communication"
               anchor="indirect_comm">
        <t>
          In indirect communication, messages are passed through the
          User-Agent.  This can be initiated by either the Relying
          Party or the IdP.  Indirect communication is used for <xref
          target="requesting_authentication">authentication
          requests</xref> and <xref
          target="responding_to_authentication">authentication
          responses</xref>.
        </t>
        <t>
          There are two methods for indirect communication: HTTP
          redirects and HTML form submission.
          Both form submission and redirection require that the sender
          know a recipient URL and that the recipient URL expect
          indirect messages, as specified in <xref target="queries"
          />. The initiator of the communication chooses which method
          of indirect communication is appropriate. 
        </t>

        <section title="HTTP Redirect">
          <t>
            Data can be transferred by issuing a 302, 303, or 307 HTTP
            Redirect to the End User's User-Agent. The redirect URL is
            the URL of the receiver with the OpenID Authentication
            message appended to the query string, as specified in
            <xref target="queries" />.
          </t>
          <t>
            This method is deprecated as of OpenID Authentication
            version 2.0 though is still required for implementation to
            aid in backward compatibility.
          </t>
        </section>

        <section title="HTML FORM Redirection">
          <t>
            A mapping of keys to values can be transferred by
            returning an HTML page to the User-Agent that contains an
            HTML form element. Form submission MAY be automated
            using JavaScript.
          </t>
          <t>
            The &lt;form&gt; element's "action" attribute value MUST
            be the URL of the receiving Web site. Each Key-Value pair
            MUST be included in the form as an &lt;input&gt;
            element. The key MUST be encoded as the "name" attribute
            and the value as the "value" attribute, such that the User
            Agent will generate a message as specified in
            <xref target="queries" /> when the form is submitted. The
            form MUST include a submit button.
          </t>
        </section>
        <section title="Indirect Error Responses">
          <t>
            In the case of a malformed request or one that contains
            invalid arguments, the server MUST redirect the User Agent
            to the "openid.return_to" URL value if the value is a
            valid URL.
          </t>
          <t>
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "error"
                  </t>
                </list>
              </t>
              <t>
                openid.error
                <list style='empty'>
                  <t>
                    Value: Unstructured text error message.
                  </t>
                </list>
              </t>
              <t>
                openid.contact
                <list style='empty'>
                  <t>
                    Value: (optional) Contact address for the
                    administrator of the sever. The contact address
                    may take any form, as it is intended to be
                    displayed to a person.
                  </t>
                </list>
              </t>

              <t>
                openid.reference
                <list style='empty'>
                  <t>
                    Value: (optional) A reference identifier, such
                    as a support ticket number or a URL to a news
                    blog, etc.
                  </t>
                </list>
              </t>
            </list>

            The server MAY add additional keys to this response.
          </t>
          <t>
            If the "openid.return_to" value is missing or not a valid
            URL, the server SHOULD return a response to the End User
            indicating the error and that it is unable to return the
            End User to the initiating server.
          </t>
        </section>
      </section>
    </section>

    <section title="Generating Signatures" anchor="generating_signatures">
      <t> 
        The most common usage of an association is as a Message
        Authentication Code (MAC) key used to sign OpenID
        Authentication messages.
      </t>
      <t>
        When generating MAC keys, the recommendations in <xref
        target="RFC1750" /> SHOULD be followed.
      </t>

      <section title="Procedure">
        <t>
          To generate a message signature:
          <list style="numbers">
            <t> 
              Determine the appropriate signature list and signature
              algorithm from the <xref
                  target="associations">association type</xref>.
            </t>
            <t> 
              Generate the list to be signed using the correct <xref
                  target="signed_list">list algorithm</xref>.
            </t>
            <t> 
              Convert the list to an octet string by encoding
              with <xref target="kvform">Key-Value Form
              Encoding</xref>.
            </t>
            <t> 
              Apply the correct <xref target="sign_algos">signature
              algorithm</xref> to the octet string.
            </t>
          </list>
        </t>
      </section>

      <section title="Signed List Algorithm" anchor="signed_list">
    <t>
      The input to the Signed List Algorithm are the message
      to be signed, and the list of message keys that are to be
      signed with the "openid." prefix removed.
    </t>
    <t>
      To compute the list of key/value pairs to be signed:
      <list style="numbers">
        <t> 
          Iterate through the list of keys to be signed in
          the order they appear in the input to the algorithm.
          For each key, find the value in the message whose key is
          equal to the signed list key prefixed with "openid."
        </t>
        <t>
          Append the signed list key and the associated value to
          the message to be signed.
        </t>
      </list>
    </t>
    <t>
      The output of this algorithm is the message to be
      signed, and the list of keys that were signed.  A message
      signed using this algorithm MUST append the list of signed
      fields to the message.
    </t>
    <t>
      As the algorithm strips the "openid." prefix from message
      keys while looking for a match, it MUST only sign elements
      that have keys beginning with "openid." This is to prevent
      attacks where the Relying Party is malicious and tries to
      have the IdP sign arbitrary data.
    </t>
      </section>

      <section title="Signature Algorithms" anchor="sign_algos">
        <t>
          OpenID Authentication supports two signature algorithms:

          <list style="symbols">
            <t>HMAC-SHA1(<xref target="RFC2104" /> and <xref
                target="RFC3174" />)</t>
            <t>HMAC-SHA256 (<xref target="RFC2104" /> and <xref
                target="FIPS180-2" /></t>
          </list>

          The use of HMAC-SHA256 is RECOMENDED though at the time
          of writing this document, library support seems lacking.
        </t>
        <texttable>
          <ttcol>Algorithm</ttcol>
          <ttcol>Key Length</ttcol>

          <c>HMAC-SHA1</c>
          <c>160 bits</c>

          <c>HMAC-SHA256</c>
          <c>256 bits</c>
        </texttable>
      </section>
    </section>

    <section title="Initiation and Discovery">

      <section title="Initiation" anchor="initiation">
        <t>
          To initiate OpenID Authentication, the Relying Party SHOULD
          present the End User with a form that has a field for
          entering an Identifier. 
        </t>
        
        <t>
          It is RECOMMENDED that every Relying Party place the <eref
          target='http://openid.net/login-bg.gif'>OpenID logo</eref>
          at the beginning of the form field where the End User enters
          their Identifier. This aides in End User recognition that
          they can use their OpenID Identifier at the specific Relying
          Party.
        </t>

        <t>
          The form field's "name" attribute SHOULD have the value
          "openid_identifier" as to allow User Agents to automatically
          prefill the End User's Identifier when visiting a Relying
          Party. Rich User Agents that support OpenID Authentication
	  may not detect a Relying Party's support if the value is not
	  "openid_identifier".
        </t>
      </section>

      <section title="Normalization" anchor="normalization">
        <t>
          The End User's input MUST be normalized into an
          Identifier.  If the End User supplies input that does not
          include a scheme (http, https, or xri), then the application
          needs to determine if the input is an XRI or a URL missing
          the scheme.
        </t>

        <t>
          To do so, the Relying Party SHOULD examine the first
          character of the input. If it is an XRI Global Context
          Symbol ("=", "@", "+", "$", or "!" see <xref target="XRI
          Syntax 2.0"> Section 2.2.1.2 of</xref>), then the input
          SHOULD be treated as an XRI. If it is not, then the input
          SHOULD be treated as an http URL, and prefixed with the
          string "http://".
        </t>

        <t>
          URL identifiers MUST be further normalized by following
          redirects when retrieving their content and finally applying
          the rules in Section 6 of <xref target='RFC3986' /> to the
          final destination URL. This final URL should be noted by the
          Relying Party as the Claimed Identifier and used during
          future requests.
        </t>
      </section>

      <section title="Discovery" anchor="discovery">

        <t>
          Discovery is the process where the Relying Party uses the
          Identifier to look up ("discover") the necessary information
          for initiating requires. OpenID Authentication has three
          paths through which to do discovery:
        </t>

        <t>
          <list style="numbers">
            <t>
              If the identifier is an XRI, <eref
              target="http://www.oasis-open.org/committees/download.php/17293"
              >XRI resolution</eref> will yield an XRDS document
              that contains the necessary information.
            </t>

            <t>
              If it is a URL, the <xref target="Yadis">Yadis
              protocol</xref> is first attempted. If it succeeds, the
              result is again an XRDS document.
            </t>

            <t>
              If the Yadis protocol fails, the URL is retrieved and
              <xref target="html_disco">HTML-based discovery</xref> is
              attempted.
            </t>

          </list>

        </t>

        <section title="Discovered Information">
          <t>
            Upon successful completion of discovery, the Relying
            Party will have the following information:

            <list style="hanging">
              <t hangText="IdP Endpoint URL:">
                The URL that accepts authentication requests. This
                MUST be an absolute URL.
              </t>

              <t hangText="Claimed Identifier:">
                (optional) The normalized Identifier upon which
                discovery was performed. The Claimed Identifier is
                present unless the End User entered an IdP Identifier
                during initiation.
              </t>

              <t hangText="Delegate Identifier:">
                (optional)
                 
                The Identifier that the Relying Party SHOULD perform
                authentication using.  Upon successful authentication,
                the Relying Party SHOULD recognize the End User using
                the Claimed Identifier.  The Delegate Identifier can
                only be present when the End User enters a Claimed
                Identifier.
              </t>
            </list>
          </t>
        </section>

        <section title="XRDS-Based Discovery">
          <t>
            If XRI or Yadis discovery was used, the result will be an
            XRDS Document.  This is a XML document with entries for
            services that are related to the Identifier.  It is
            defined in <eref target="REFERENCE XRDS
            DOCUMENT">REFERENCE XRDS DOCUMENT</eref>
          </t>


          <section title="Service Elements">
          
            <section title="IdP Identifier Element">
              <t> 
                An IdP Identifier Element is a &lt;xrd:Service&gt;
                element with the following information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://openid.net/server/2.0".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    IdP Endpoint URL
                  </t>
                </list>
              </t>
            </section>

            <section title="Claimed Identifier Element">
              <t>
                A Claimed Identifier Element is an
                &lt;xrd:Service&gt; element with the following
                information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://openid.net/signon/2.0".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    IdP Endpoint URL.
                  </t>

                  <t>
                    An &lt;openid:Delegate&gt; tag (optional) whose
		            text content is the Delegate Identifier.
                  </t>
                </list>
              </t>
            </section>
          </section>

          <section title="Extracting Authentication Data">
            <t>
              Once the Relying Party has obtained an XRDS document, it
              MUST first search the document (following the rules
              described in <eref target="REFERENCE XRDS DOCUMENT">the XRDS
              specification</eref>) for an IdP Identifier. If none is
              found, the RP will search for a Claimed Identifier Element.
            </t>
          </section>

          <section title="XRI and the CanonicalID Element" toc="exclude">
            <t>
              When the identifier is an XRI, the &lt;xrd:XRD&gt;
              element that contains the OpenID Authentication
              &lt;xrd:Service&gt; element will also contain a
              &lt;CanonicalID&gt; element. The content of this element
              MUST be preserved for use after a successful
              authentication request, see <xref target="identifying" />.
            </t>

            <t>
              The Relying Party MUST confirm that the provider of
              the XRD that contains the &lt;CanonicalID&gt; element
              is authoritative for that canonical ID. The provider
              is identified by the contents of the
              &lt;ProviderID&gt; element that is a child of the
              &lt;XRD&gt; element. If the provider is not
              authoritative for the canonical ID, the Relying Party
              MUST resolve the canonical ID to confirm the OpenID
              Service Endpoint information that was discovered. The
              information discovered when resolving the canonical ID
              MUST match the information discovered when resolving
              the user-supplied identifier.
           </t>

            <t>
              When using XRI resolution, the canonical ID MUST be
              used as the Claimed Identifier. For an XRI to be a
              valid identifier, both the &lt;ProviderID&gt; and
              &lt;CanonicalID&gt; MUST be present in the discovered
              XRDS document.
            </t>

            <t>
              When using URL-based identifiers, the CanonicalID
              element SHOULD be ignored if present.
            </t>
          </section>

          <section title="Additional Information">
            <t>
              The "openid" namespace is
              "http://openid.net/signon/2.0". The "xrd" namespace is
              "xri://$xrd*($v*2.0)".
            </t>

            <t>
              For compatibility with deployed code, it is RECOMMENDED
              that a Relying Party also accept
              "http://openid.net/signon/1.0" or
              "http://openid.net/signon/1.1" for the value of
              &lt;xrd:Type&gt;. When one of these values is used, the
              Relying Party MUST use <xref target="compat_mode">OpenID
              Authentication 1.1 Compatibility</xref>.
            </t>

            <t>
              If an OpenID IdP supports extensions (<xref
              target="extensions" />), the extensions SHOULD be listed
              as additional &lt;xrd:Type&gt; child elements of the
              &lt;xrd:Service&gt; element.
            </t>

          </section>

        </section>

        <section anchor="html_disco" title="HTML-Based Discovery">
          <t>
            OpenID Authentication 1.1 HTML-based discovery MUST be
            supported by Relying Parties.  If a Relying Party locates
            an IdP using HTML-based discovery, it MUST use <xref
                target="compat_mode">OpenID Authentication 1.1
            Compatibility</xref> when communicating with that IdP.
          </t>

          <t>
            To use HTML-based discovery, an HTML document MUST be
            available at the URL of the Claimed Identifier. In the
            HEAD section of the document:

            <list>
              <t>
                A &lt;LINK&gt; tag MUST be included with attributes
                "rel" set to "openid.server", and "href" set to an IdP
                Endpoint URL
              </t>
              <t>
                A &lt;LINK&gt; tag MAY be included with attributes
                "rel" set to "openid.delegate" and "href" set to the
                End User's Delegate Identifier
              </t>
            </list>
          </t>

          <t> The host of the HTML document MAY be different from the
            End User's IdP's host.
          </t>

          <t>
            The "openid.server" and "openid.delegate" URLs MUST NOT
            include entities other than "&amp;amp;", "&amp;lt;",
            "&amp;gt;", and "&amp;quot;". Other characters that would
            not be valid in the HTML document or that cannot be
            represented in the document's character encoding MUST be
            escaped using the %xx mechanism as described in <xref
                target='RFC3986' />.
          </t>
        </section>
      </section>
    </section>


    <section title="Establishing Associations" anchor="associations">
      <t>
        An "association" is a shared secret between the IdP and
        Relying Party.  Once established, it is used to verify
        subsequent protocol messages.
      </t>
      <t>
        It is RECOMMENDED that a Relying Party form associations if it
        is possible for it to do so.  If a Relying Party is incapable
        of creating or storing associations, <xref
        target="verifying_signatures"/> provides an alternate
        verification mechanism referred to as Stateless Mode.
      </t>

      <section title="Association Session Request">
        <t>
          An association session is initiated by a <xref
          target="direct_comm">direct request</xref> from a Relying
          Party to an IdP Endpoint URL with the "openid.mode" key
          having the value of "associate".
        </t>
         
        <section title="Common Request Parameters" toc="exclude">
          <t> 
            These parameters are common to all association requests:
          </t>
          <t>
            <list style="symbols">
              <t>openid.mode 
                <list style="empty">
                  <t> Value: "associate"</t>
                </list>
              </t>

              <t>openid.assoc_type 
                <list style="empty">
                  <t> The preferred association type.  The association
                    type defines the algorithm to be used to sign
                    subsequent messages.</t>
                  <t> Value: A valid association type from <xref
                  target="assoc_types"/></t>
                  <t> Default: "HMAC-SHA1".</t>
                </list>
              </t>

              <t>openid.session_type 
                <list style='empty'>
                  <t>
                    The preferred association session type.  This
                    defines the method used to encrypt the association's
                    MAC key in transit.
                  </t>
                  <t>
                    Value: A valid association session type from
                    <xref target="assoc_sess_types"/>.
                  </t>
                  <t>
                    Note: Unless using transport layer encryption, it
                    is NOT RECOMMENDED to use "no-encryption" on a
                    public network, see <xref
                        target="preventing_eavesdropping" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Diffie-Hellman Request Parameters" toc="exclude">
          <t>
            The following parameters are common to requests whose
            requested association type is "DH-SHA1" or "DH-SHA256":
          </t>
          <t>
            <list style="symbols">
              <t>
                openid.dh_modulus
                <list style='empty'>
                  <t>Value: base64(btwoc(p))</t>
                  <t>Default: See <xref target='pvalue' /></t>
                </list>
              </t>
              <t>
                openid.dh_gen
                <list style='empty'>
                  <t>Value: base64(btwoc(g))</t>
                  <t>Default: g = 2</t>
                </list>
              </t>
              <t>
                openid.dh_consumer_public
                <list style='empty'>
                  <t>Value: base64(btwoc(g ^ xa mod p))</t>
                </list>
              </t>
            </list>
          </t>
          <t>
            See <xref target="dh_sessions"/> for more information on
            these parameters.
          </t>
          <t>
            NOTE: the 'btwoc' function is defined in <xref
            target="btwoc"/>.
          </t>
        </section> 
      </section>

      <section title="Association Session Response">
        <t>
          An association session response is a direct response from the
          IdP to the Relying Party in <xref target="kvform">Key-Value
          Form</xref>.
        </t>

        <section title="Common Response Parameters">
          <t>
            <list style="symbols">
              <t>
                session_type
                <list style="empty">
                  <t>
                    The session type for this association. If the IdP
                    is unwilling or unable to support this association
                    type, it MUST return an unsuccessful response.
                  </t>
                </list>
              </t>
              <t>
                assoc_handle
                <list style="empty">
                  <t>
                    The association handle is used as a key to refer
                    to this association in subsequent messages.
                  </t>
                  <t>
                    Value: A string 255 characters or less in length.
                    It MUST consist only of ASCII characters in the
                    range 33-126 inclusive (printable non-whitespace
                    characters).
                  </t> 
                </list>
              </t>
              <t>
                assoc_type
                <list style="empty">
                  <t>
                    The value of the "openid.assoc_type" parameter
                    from the request.  If the IdP is unwilling or
                    unable to support this association type, it MUST
                    return an unsuccessful response.
                  </t>
                </list>
              </t>
              <t>
                expires_in
                <list style="empty">
                  <t>
                    The lifetime, in seconds, of this association.
                    The Relying Party MUST NOT use the association
                    after this time has expired.
                  </t>
                  <t>
                    Value: An integer, represented in base 10 ASCII.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Unencrypted Response Parameters">
          <t>
            <list style="symbols">
              <t>
                mac_key
                <list style='empty'>
                  <t>
                    The MAC key (shared secret) for this
                    association, <xref target="RFC3548">Base 64</xref>
                    encoded.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>


        <section title='Diffie-Hellman Response Parameters' toc="exclude">
          <t>
            <list style="symbols">
              <t>
                dh_server_public
                <list style='empty'>
                  <t>
                    Value: base64(btwoc(g ^ xb mod p))
                  </t>
                  <t>
                    Description: The IdP's Diffie-Hellman public key.  
                  </t>
                </list>
              </t>
              <t>
                enc_mac_key
                <list style='empty'>
                  <t>
                    Value: base64(H(btwoc(g ^ (xa * xb) mod p)) XOR MAC key)
                  </t>
                  <t>
                    Description: The MAC key (shared secret),
                    encrypted with the secret Diffie-Hellman value. H
                    is either "SHA1" or "SHA256" depending on the
                    session type.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            NOTE: The 'btwoc' function is defined in <xref
            target="btwoc"/>
          </t>
        </section>

        <section anchor="refuse_assoc"
                 title="Unsuccessful Response Parameters">
          <t>
            If the IdP does not support an association session type or
            association type, it MUST respond with a message
            indicating that the association request failed. If there
            is another association session type or association type
            that is supported, the IdP MAY include that information in
            the response.
          </t>
          <t>
            <list style='symbols'>
              <t>
                error
                <list style='empty'>
                  <t>
                    Value: (optional) A human-readable message
                    indicating why the association request failed.
                  </t>
                </list>
              </t>
              <t>
                error_code
                <list style='empty'>
                  <t>
                    Value: "unsupported-type"
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style='empty'>
                  <t>
                    Value: A valid association session type from <xref
                        target="assoc_sess_types" />.
                  </t>
                </list>
              </t>
              <t>
                assoc_type
                <list style='empty'>
                  <t>
                    Value: (optional) An association type supported by
                    the IdP from <xref target="assoc_types" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            Upon receipt of an "unsupported-type" response, the
            Relying Party MAY make another request with the specified
            association session type and association type. If no
            association is established, the Relying Party MAY continue
            the authentication process in stateless mode.
          </t>
        </section>
      </section>   

      <section title="Association Types" anchor="assoc_types">
        <section title="HMAC-SHA1" anchor="hmacsha1">
          <t>
            An association of type "HMAC-SHA1" uses the <xref
            target="sign_algos">HMAC-SHA1</xref> signature algorithm
            in combination with the <xref target="signed_list">Signed
            List</xref> algorithm.
          </t>
        </section>

        <section title="HMAC-SHA256" anchor="hmacsha256">
          <t>
            An association of type "HMAC-256" uses the <xref
            target="sign_algos">HMAC-SHA256</xref> signature
            algorithm in combination with the <xref
            target="signed_list">Signed List</xref> algorithm.
          </t>
        </section>
      </section>

      <section title="Association Session Types" anchor="assoc_sess_types">
        <t> 
          OpenID Authentication defines three valid association
          session types: "no-encryption", "DH-SHA1", and "DH-SHA256".
        </t>

        <section title="No-Encryption Association Sessions"
                 toc="exclude">
          <t>
            In a "no-encryption" association session, the IdP sends
            the association MAC key in plain-text to the Relying Party.
            This makes it possible for an eavesdropper to intercept
            the key, and forge messages to this Relying Party.
            Therefore, no-encryption association sessions SHOULD NOT
            be used unless the messages are using transport-level
            encryption. See <xref target="preventing_eavesdropping" />
            for more information.
          </t>

          <t>
            The MAC key sent by the IdP MUST be the length specified
            for this association in <xref target="sign_algos" />.
          </t>

        </section>

        <section title="Diffie-Hellman Association Sessions"
                     anchor="dh_sessions" toc="exclude">
          <t> 
            The "DH-SHA1" and DH-SHA256" association types use
            Diffie-Hellman Key Exchange to securely transmit the
            shared secret.
          </t>
          <t>
            The MAC key MUST be the same length as the output of H,
            the hash function - 160 bits (20 bytes) for DH-SHA1 or 256
            bits (32 bytes) for DH-SHA256, as well as the output of
            the signature algorithm of this association.
          </t>

          <t>
            The Relying Party specifies a modulus, p, and a generator,
            g. The Relying Party chooses a random private key xa and
            Identity Provider chooses a random private key xb, both in
            the range [1 .. p-1]. The shared secret used to encrypt
            the MAC key is thus g ^ (xa * xb) mod p = (g ^ xa) ^ xb
            mod p = (g ^ xb) ^ xa mod p. For more information, see
            <xref target='RFC2631' />. For information on the
            selection of random values, see <xref target="RFC1750" />.
          </t>
        </section>
      </section>
    </section>

    <section title="Requesting Authentication"
             anchor="requesting_authentication">
      <t>
        Once the Relying Party has successfully performed discovery
        and (optionally) created an association with the discovered
        IdP Endpoint URL, it can send an authentication request to the
        IdP to obtain an assertion. An authentication request is an
        <xref target="indirect_comm">indirect request</xref>.
      </t>

      <section title="Request Parameters">
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  This value MUST be present for the request to be a
                  valid OpenID Authentication 2.0 request.
                </t>
                <t>
                  Note: If an IdP receives an authentication request
                  with this parameter missing or with a lower version
                  number, it SHOULD still respond to the request.  If
                  it does respond it MUST use <xref
                  target="compat_mode">OpenID Authentication 1.1
                  Compatibility</xref> when communicating with that
                  Relying Party.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>
                  Value: "checkid_immediate" or "checkid_setup"
                </t>
                <t>
                  Note: If the Relying Party wishes the End User to be
                  able to interact with the IdP, "checkid_setup"
                  should be used. An example of a situation where
                  interaction between the End User and the IdP is not
                  desired is when the authentication request is
                  happening asynchronously in JavaScript.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) Delegate Identifier when
                  available, otherwise the Claimed Identifier
                </t>
                <t>
                  Note: If this is set to the special value
                  "http://openid.net/identifier_select/2.0" then the
                  IdP MAY choose an Identifier that belongs to the End
                  User.
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: (optional) A handle for an association
                  between the Relying Party and the IdP that should be
                  used to sign the response.
                </t>
                <t>
                  Note: If no association handle is sent, the
                  transaction will take place in stateless mode.
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: URL to which the IdP SHOULD return the User
                  Agent with the response indicating the status of the
                  request.
                </t>
              </list>
            </t>

            <t>
              openid.realm
              <list style='empty'>
                <t>
                  Value: (optional) URL pattern the IdP SHOULD ask the
                  End User to trust. See <xref target="realms" />.
                </t>
                <t>
                  Default: return_to URL
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      
      <section title="Realms" anchor="realms">
        <t>
          A "realm" is a pattern that represents the part of URL-space
          for which an OpenID Authentication request is valid. A realm
          is designed to give the End User an indication of the scope
          of the authentication request. IdPs SHOULD present the realm
          when requesting the End User's approval for an
          authentication request. IdPs MAY use the realm to allow the
          End User to automate approval of authentication
	  requests. The realm SHOULD be used by IdPs to uniquely
	  identify Relying Parties.
        </t>

        <t>
          A realm pattern is a URL, with the following changes:
          <list style="symbols">
            <t>
              A realm MUST NOT contain a URI fragment
            </t>
            <t>
              A realm MAY contain a wild-card at the beginning of the
              URL authority section.  A wild-card consists of the
              characters "*." prepended to the DNS name in the
              authority section of the URL.
            </t>
          </list>
        </t>

        <t>
          A URL matches a realm if:

          <list style="symbols">
            <t>
              The URL scheme (<xref target="RFC3986">RFC 3986, section
              3.1</xref>) and port of the URL are identical to those
              in the realm.
            </t>

            <t>
              The URL's path is equal to or a sub-directory of the
              realm's path.
            </t>

            <t>
              Either:
              <list style="numbers">
                <t>
                  The realm's domain contains the wild-card characters
                  "*.", and the trailing part of the URL's domain is
                  identical to the part of the realm following the
                  "*." wildcard, or
                </t>
                <t> 
                  The URL's domain is identical to the realm's domain
                </t>
              </list>
             </t>
          </list>
            
          The "openid.return_to" URL MUST match the "openid.realm", or
          the IdP MUST return an error.
        </t>

        <t>
          It is RECOMMENDED that IdP's protect their End Users from
          requests with overly-general realms, like http://*.com/ or
          http://*.co.uk/. Determining if a realm is overly-general is
          at the discretion of the IdP.
        </t>
      </section>

      <section title="Immediate Requests">
        <t>
          When requesting authentication, the Relying Party MAY
          request that the IdP not interact with the End User.  In
          this case the IdP MUST respond immediately with either an
          assertion that authentication is successful, or a response
          indicating that the request cannot be completed without
          further user interaction.  This is accomplished by an
          authentication request with "openid.mode" set to
          "checkid_immediate".
        </t>
      </section>
    </section>

    <section title="Responding to Authentication Requests"
             anchor="responding_to_authentication">
      <t>
        When an authentication request comes from the User-Agent via
        <xref target="indirect_comm">indirect communication</xref>,
        the IdP SHOULD identify the User-Agent, and determine whether
        the End User wishes to complete the authentication.  If the
        End User can be identified and wishes to complete the
        authentication, the IdP should send a <xref
        target="positive_assertions">positive assertion</xref> to the
        Relying Party.
      </t>
      <t>
        Methods of identifying the End User and getting approval to
        finish authentication are beyond the scope of this
        specification.
      </t>
      <t>
        If no Identifier was specified in the request and there are
        Identifiers in the control of the End User, the IdP SHOULD
        allow the End User to choose which Identifier to use.  If an
        Identifier was specified, the IdP SHOULD only issue assertions
        about the specified Identifier.
      </t>
      <t>
        If the Relying Party supplied an association handle with the
        authentication request, the IdP SHOULD attempt to look up an
        association based on that handle.  If the association is
        missing or expired, the IdP SHOULD send the
        "openid.invalidate_handle" parameter as part of the response
        with the value of the request's "openid.assoc_handle"
        parameter, and SHOULD proceed as if no association handle was
        specified.
      </t>
      <t>
        If no association handle is specified, the IdP SHOULD create a
        private association for signing the response.  The IdP MUST
        store this association and MUST respond to later requests to
        check the signature of the response in <xref
        target="verifying_signatures">stateless mode</xref>.
      </t>

      <section title="Positive Assertions" anchor="positive_assertions">
        <t>
          Positive assertions are <xref target="indirect_comm">
          indirect responses</xref> with the following fields:
        </t>
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  Note: This defines the interpretation of the OpenID
                  Authentication arguments without a namespace.  To be
                  an OpenID Authentication 2.0 response, the given
                  value must be present.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>Value: "id_res"</t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The Identifier about which the IdP
                  is making a positive authentication assertion.
                </t>
                <t>
                  Note: The Identifier MAY be omitted if an extension
                  is in use that makes the response meaningful without
                  it.
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: Verbatim copy of the return_to URL parameter
                  sent in the request.
                </t>

                <t>
                  Note: Because the "openid.return_to" URL is signed
                  by the IdP, a Relying Party can make sure outside
                  parties haven't sent responses with query parameters
                  that were not included in the "openid.return_to"
                  URL.
                </t>

              </list>
            </t>

            <t>
              openid.response_nonce
              <list style='empty'>
                <t>
                  Value: A string that MUST be unique to this
                  particular successful authentication response. The
                  nonce MUST start with the current time on the
                  server, and MAY have additional characters appended
                  to the end as necessary to make each response
                  unique. The date and time MUST be formatted as
                  specified in section 5.6 of <xref target="RFC3339"
                  />, with the following restrictions:

                  <list style="symbols">
                    <t>
                      All times must be in the UTC
                      timezone, indicated with a "Z".
                    </t>
                    <t>
                      No fractional seconds are allowed
                    </t>
                  </list>

                  For example: 2005-05-15T17:11:51ZUNIQUE
                </t>
              </list>
            </t>

            <t>
              openid.invalidate_handle
              <list style='empty'>
                <t>
                  Value: (optional) If the Relying Party sent an
                  invalid association handle with the request, it
                  SHOULD be included here. If it is present, this
                  field MUST be signed.
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: The handle for the association that was used
                  to sign this assertion.
                </t>
              </list>
            </t>

            <t>
              openid.signed
              <list style='empty'>
                <t>
                  Value: Comma-separated list of signed fields.
                </t>
                <t>
                  Note: This entry consists of the fields
                  without the "openid." prefix that the signature
                  covers. This list MUST contain at least "return_to"
                  and "response_nonce". Additionally, if the IdP is
                  making an assertion about an Identifier, the
                  "identity" field MUST be present. For example,
                  "identity,return_to,response_nonce".
                </t>
              </list>
            </t>

            <t>
              openid.sig
              <list style='empty'>
                <t>
                  Value: Base 64 encoded signature calculated as
                  specified in <xref target="generating_signatures"/>.
                </t>

                <t>
                  Note: Successful authentication messages from the
                  IdP to the Relying Party MUST be signed.
                </t>
              </list>
            </t>

          </list>
 
        </t>
      </section>

      <section title="Negative Assertions" anchor="negative_assertions">
        <t>
          If the IdP is unable to identify the End User or the End
          User does not or cannot approve the authentication request,
          the IdP SHOULD send a negative assertion to the Relying
          Party as an <xref target="indirect_comm">indirect
          response</xref>.
        </t>

	<t>
	  when receiving a negative assertion, Relying Parties SHOULd
	  construct a new authentication request using the
	  "checkid_setup" mode to complete the transaction.  This is a
	  change from OpenID Authentication 1.1 and more details can
	  be found in <xref target="compat_mode" />.
	</t>

        <section title="In Response to Immediate Requests">
          <t>
            If the request was an immediate request, there is no chance
            for the End User to interact with pages on the IdP to provide
            identifying credentials or approval of a request.
            A negative assertion of an immediate request takes the
            following form:
            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>Value: "id_res"</t>
                </list>
              </t>

              <t>
                openid.user_setup_url
                <list style='empty'>
                  <t>
                    Value: A URL that the End User may visit to
                    complete the request. The Relying Party may
                    redirect the End User to this URL, or provide the
                    End User with a link that points to this URL.  The
                    request is no longer immediate.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="In Response to Non-Immediate Requests">
          <t>
            Since the IdP may display pages to the End User and
            request credentials from the End User, a negative response
            to a request that is not immediate is definitive.  It
            takes the following form:

            <list style='symbols'>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "cancel"
                  </t>
                </list>
              </t>
            </list>
          </t>

          <t>
            In a lot of cases, the Relying Party won't get a cancel
            mode response; the End User will just quit or press back
            within their User-Agent. But if it is returned, the
            Relying Party SHOULD return to what it was doing.
          </t>
        </section>
      </section>
    </section>

    <section title="Verifying Assertions" anchor="verification">
      <t>
        When the Relying Party receives a positive assertion, it MUST
        verify the following before accepting the assertion:

        <list style="symbols">
          <t>
            An assertion has not yet been accepted from this
            IdP with the same value for "openid.response_nonce"
          </t>
          <t>
            The signature on the assertion is valid
          </t>
          <t>
            Discovered information from the Identifier matches the
            information in the assertion.
          </t>
        </list>
      </t>

      
      <section title="Checking the Nonce">
        <t>
          To prevent replay attacks, the agent checking the signature
          SHOULD keep track of the nonce values included in positive
          assertions and never accept the same value more than once
          for the same IdP Endpoint URL. When using
          "check_authentication", the IdP is responsible for
          preventing replay attacks. When the Relying Party checks the
          signature on an assertion, it is responsible for preventing
          replay attacks.
        </t>
        <t>
          The time-stamp may be used to reject responses that are too
          far away from the current time, limiting the amount of time
          that nonces must be stored to prevent attacks. The
          acceptable range is implementation dependent. A larger range
          requires storing more nonces for a longer time. A shorter
          range increases the chance that clock-skew and transaction
          time will cause a spurious rejection.
        </t>
      </section>

      <section title="Verifying Signatures"
               anchor="verifying_signatures">
        <t>
          If the Relying Party has stored an association with the
          association handle specified in the assertion, it MUST check
          the signature on the assertion itself. If it does not have
          an association stored, it MUST <xref
          target="check_auth">request that the IdP verify the
          signature</xref> via Stateless mode.
        </t>

        <section title="Verifying with an Association" toc="exclude">
          <t>
            The Relying Party follows the same procedure that the
            IdP followed in <xref target= "generating_signatures">
            generating the signature</xref>, and then compares the
            signature in the response to the signature it
            generated. If the signatures do not match, the assertion
            is invalid.
          </t>

          <t>
            If an authentication request included an association
            handle for an association between the IdP and the Relying
            party, and the IdP no longer wishes to use that handle
            (because it has expired or the secret has been
            compromised, for instance), the IdP will send a response
            that must be verified directly with the IdP, as specified
            in <xref target="check_auth" />. In that instance, the IdP
            will include the field "openid.invalidate_handle" set to
            the association handle that the Relying Party included
            with the original request.
          </t>
        </section>

        <section title="Verifying Directly with the Identity Provider"
                 toc="exclude" anchor="check_auth">
          <t>
            To verify a signature directly with the IdP, the Relying
            Party sends a <xref target="direct_request">direct
            request</xref> to the IdP. This is known as Stateless
            mode.
          </t>

          <section title='Request Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  openid.mode
                  <list style='empty'>
                    <t>Value: "check_authentication"</t>
                   </list>
                </t>

                <t>
                  Exact copies of all fields from the authentication
                  response, except for "openid.mode".
                </t>
              </list>
            </t>
          </section>

          <section title='Response Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  mode
                  <list style='empty'>
                    <t>Value: "id_res"</t>
                   </list>
                </t>

                <t>
                  is_valid
                  <list style='empty'>
                    <t>Value: "true" or "false"</t>
                    <t>Description: Boolean; whether the signature is
                    valid.</t>
                  </list>
                </t>

                <t>
                  invalidate_handle
                  <list style='empty'>
                    <t>
                      Value: (optional) An association handle
                    </t>
                    <t>
                      Description: The association handle sent in
                      the request, if the server confirms that it is
                      invalid. 
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t>
              An IdP MUST NOT verify signatures for associations that
              have shared MAC keys. If an IdP did verify signatures
              for associations with shared MAC keys, it would be
              possible for parties other than the IdP to create valid
              assertions that seemed to come from the IdP.
            </t>

            <t>
              The IdP SHOULD only return "is_valid" once for each
              authentication request. An authentication request may be
              identified by its "openid.response_nonce" value.
            </t>

            <t>
              If the IdP verifies responds with "is_valid" set to
              "true", and "invalidate_handle" is present, the Relying
              Party SHOULD NOT send further authentication requests
              with that handle.  "invalidate_handle" will only be
              present when the original authentication request to the
              IdP included an association that the IdP deemed
              invalid. This implies that it will only be present in
              this response if it was also present in the <xref
              target="positive_assertions">"id_res"
              response</xref>. Including "invalidate_handle" in the
              direct verification is necessary to prevent an attacker
              from invalidating an association at will by adding it to
              an authentication response.
            </t>

          </section>
        </section>
      </section>

      <section title="Verifying Discovered Information">
        <t>
          The Relying Party MUST have performed <xref
          target="discovery">discovery</xref> on the Identifier that
          will be used and the information in the assertion MUST
          match the discovered information. 
        </t>
        <t>
          Specifically, one of the following MUST be true:
          <list style="numbers">
            <t>
              The Identifier in the assertion points to the IdP
              making the assertion.
            </t>
            <t>
              The Claimed Identifier specifies the Identifier in the
              assertion as a delegate, and the Delegate Identifier
              points to the IdP making the assertion.
            </t>
          </list>
        </t>
        <t>
          Note: The Relying Party must be able to look up the Claimed
          Identifier in order to perform the second test.  Relying
          Parties unable to store information might append the Claimed
          Identifier to the "openid.return_to" parameter in the
          request.
        </t>
        <t>
          If the Claimed Identifier was not present in the request
          ("openid.identity" was
          "http://openid.net/identifier_select/2.0"), the Relying
          Party MUST perform discovery on the Identifier in the
          response to make sure that the IdP is authorized to make
          assertions about the Identifier.
        </t>
      </section>

      <section title="Identifying the End User" anchor="identifying">
        <t>
          A successful authentication response provides the Relying
          Party with a Verified Identifier, which MAY be used as a
          user-visible Identifier.  Identifiers in OpenID MUST be
          URIs. If the Identifier is a URL, its scheme MUST be "http"
          or "https".  Except in the case that the Verified Identifier
          is an XRI, the Relying Party SHOULD use the Verified
          Identifier as a key for local storage of information about
          the End User.  If the Verified Identifier is an XRI, the
          discovered "CanonicalID" field from the XRDS document SHOULD
          be used as a key for local storage of information about the
          End User.
        </t>

        <t>
          If a request is using delegation, the Verified Identifier is
          the Identifier on which discovery was performed, and not the
          Identifier that is contained in the assertion. If an
          assertion is made for an Identifier on which discovery has
          not been performed, the Relying Party MUST perform discovery on
          that Identifier and compare the discovered information to
          that in the assertion.
        </t>

        <section title="HTTP and HTTPS URL Identifiers">
          <t>
            Relying Parties MUST differentiate between URL Identifiers
            that have different schemes. When user input is processed
            into a URL, it is processed into a HTTP URL. If the same
            End User controls the same URL, differing only by scheme,
            and it is desired that the Identifier be the HTTPS URL, it
            is RECOMMENDED that a redirect be issued from the HTTP URL
            to the HTTPS URL. Because the HTTP and HTTPS URLs are not
            equivalent and the Identifier that is used is the URL
            after following redirects, there is no reduction in
            security when using this scheme. If an attacker could gain
            control of the HTTP URL, it would have no effect on the
            HTTPS URL, since the HTTP URL is not ever used as an
            Identifier.
          </t>
        </section>
      </section>
    </section>


    <section title="OpenID Authentication 1.1 Compatibility"
             anchor="compat_mode">
      <t>
        OpenID Authentication 2.0 attempts to retain maximum
        compatibility with earlier versions of the OpenID
        Authentication specification, but this is not universally
        possible.  This section lists the behavioral changes required
        of an OpenID Authentication 2.0 IdP or Relying Party when
        communicating with an earlier-protocol peer.
      </t>

      <t>
        OpenID Authentication 2.0 implementations SHOULD support
        OpenID Authentication 1.1 compatibility, unlesss security
        considerations make it undesirable.
      </t>

      <t>
        All messages in OpenID Authentication 1.1 omit the "openid.ns"
        parameter, which is an easy way for an RP to determine if the
        message is from an OpenID Authentication 1.x endpoint. OpenID
        Authentication 1.1 only supports HMAC-SHA1 associations.
      </t>

      <section title="Relying Parties">
      <t>
        <list style="symbols">
          <t>
            Relying Parties MUST implement <xref
            target="html_disco">HTML-Based Discovery</xref>.
          </t>

          <t>
            In <xref target="requesting_authentication">authentication
            requests</xref>, the "openid.identity" parameter MUST NOT
            be the special value
            "http://openid.net/identifier_select/2.0", because OpenID
            Authentication 1.1 does not support IdP-driven identifier
            selection.
          </t>

          <t>
            The "openid.realm" parameter in authentication requests
            was known as "openid.trust_root". The syntax and meaning
            are identical.
          </t>

	  <t>
	    When responding with a negative assertion to a
	    "checkid_immediate" mode authentication request, the
	    "user_setup_url" paramater MUST be returned. This is a
	    URL that the End User may visit to complete the
	    request. The Relying Party may redirect the End User to
	    this URL, or provide the End User with a link that
	    points to this URL.
	  </t>

          <t>
            The Relying Party MUST accept an <xref
            target="positive_assertions">authentication
            response</xref> that is missing the
            "openid.response_nonce" parameter.  It SHOULD however
            implement an out-of-band method for preventing replay
            attacks.
          </t> 
        </list>
      </t>
      </section>

      <section title="Identity Providers">
        <t>
          <list style="symbols">
            <t>
              "openid.identity" MUST be sent in a <xref
                  target="positive_assertions">positive authentication
              assertion</xref>.
            </t>

            <t>
              <xref target="refuse_assoc">Unsuccessful association
              responses</xref> MUST NOT be sent, since they are not
              part of the OpenID Authentication 1.1 protocol.
            </t>

            <t>
              IdPs MAY choose to return a successful "no-encryption"
              response to any association request.
            </t>

            <t>
              Omit the "session_type" parameter when making
              "no-encryption" responses to association requests.
            </t>

            <t>
              The "openid.realm" parameter in authentication requests
              was known as "openid.trust_root". The syntax and meaning
              are identical.
            </t>

          </list>
        </t>
      </section>

    </section>

    <section title="Extensions" anchor="extensions">
      <t>
        An Extension to OpenID Authentication is a protocol that rides
        on top of the authentication request and response. Extensions
        are useful for providing extra information about an
        authentication request or response as well as providing extra
        information about the subject of the authentication response.
      </t>

      <t>
        OpenID extensions are identified by a URI. The URI MAY be used
        as the value of an &lt;xrd:Type&gt; element of an OpenID
        &lt;xrd:Service&gt; element in an XRDS document associated
        with a Claimed Identifier. It is also used to associate
        key-value pairs in messages with the extension.
      </t>
      
      <t>
        <!-- XXX: openid. only for indirect messages -->
        To associate keys and values in a message with an extension,
        the key MUST be associated with the Type URI. To associate
        keys with a Type URI, establish an alias by adding a key
        prefixed with "openid.ns." and ending with the alias text
        whose value is the Type URI. Once an alias has been
        established, all pairs in the message whose keys start with
        "openid." followed by the alias text, followed by a period or
        the end of the key are associated with that extension.
      </t>

      <t>
        A namespace alias MUST NOT contain a period, MUST NOT be the
        name of a field in a message defined in this specification,
        and MUST NOT be the same as another namespace alias in the
        same message. A namespace MUST NOT be assigned more than one
        alias in the same message. If a message is a response to
        another message, the response MAY use a different alias to
        refer to the same namespace.
      </t>

      <t>Non-normative example:</t>
      <t>An extension's type URI is
      "&lt;http://example.com/ext/1.0&gt;".
        
      <list style="empty">
        <t>openid.ns.x=http://example.com/ext/1.0</t>
        <t>openid.x=example</t>
        <t>openid.x.foo=bar</t>
        <t>openid.xx=notx</t>
      </list>
        
        In this example, the keys openid.x and openid.x.foo are
        associated with the extension; the openid.xx key is not.
      </t>

      <t>
	Extensions MUST NOT define parameters with the same name. It
	is RECOMMENDED that commas are used as value delimiters,
	though recognized that other characters are better suited in
	certain situations.  Another approach can be appending a
	numeric value to each key to differentiate between each value.
      </t>
    </section>

    <section title="Discovering OpenID Relying Parties">
      <t>
        Relying Parties are RECOMMENDED to use the Yadis protocol to
        publish their return_to URL. This allows for automated
        discovery of OpenID Relying Parties.
      </t>
      
      <t>
        The Relying Party's XRDS document's &lt;xrd:Service&gt; entry
        should have the return_to URL as the content of the
        &lt;xrd:URI&gt; tag and should have
        http://openid.net/return_to/2.0 as the content of the
        &lt;xrd:Type&gt; tag.
      </t>
      
      <figure>
        <preamble>For example:</preamble>
        <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/return_to/2.0</Type>
  <URI>http://consumer.example.com/return</URI>
</Service>
]]></artwork>
      </figure>
    </section>
    
    <section title="Security Considerations">
      <section title="Preventing Attacks">
        <section title="Eavesdropping Attacks"
                 anchor="preventing_eavesdropping">
          <t>
            There are two places in this protocol that are vulnerable
            to eavesdropping attacks. An eavesdropper could intercept
            an unencrypted association session and recover the shared
            secret, allowing an attacker to masquerade as the IdP to
            that relying party. An eavesdropper could also intercept a
            successful authentication assertion and re-use it, if the
            nonce is not checked.
          </t>

          <t>
            Both of these attacks can be prevented by using SSL for
            these connections. The association session can also use
            Diffie-Hellman Key Exchange instead of "no-encryption" to
            protect from eavesdropping. If the nonce is checked in
            message verification, the positive authentication
            assertion cannot be re-used.
          </t>
        </section>

        <section title="Man-in-the-Middle Attcks">
          <t>
            Associations prevent tampering of signed fields by a man
            in the middle, except during discovery, association
            sessions and stateless mode. Altering signed fields
            without the shared secret requires breaking the
            MAC. Currently, no tractable attack is known on the MACs
            used in this protocol. The quality of the protection
            provided by the MAC depends on the randomness of the
            shared MAC key, so it is important that an unguessable
            value be used.
          </t>

          <t>
            If DNS resolution or the transport layer is compromised,
            signatures on messages are not adequate, since the
            attacker can impersonate the IdP and issue its own
            associations, or its own decisions in stateless mode. If
            an attacker can tamper with the discovery process, he can
            specify any IdP, and so does not have to impersonate the
            IdP.
          </t>

          <t>
            Using SSL with certificates signed by a trusted authority
            prevents these kinds of attacks by verifying the results
            of the DNS look-up against the certificate. Once the
            validity of the certificate has been established,
            tampering is not possible. Impersonating an SSL server
            requires forging or stealing a certificate, which is
            significantly harder than the network attacks.
          </t>

          <t>
            In order to get protection from SSL, SSL must be used for
            all parts of the interaction, including interaction with
            the End User through the User Agent.  While the protocol
	    does not require SSL be used, its use is strongly
	    RECOMMENDED.  Current best practicies dictate that an IdP
	    SHOULD use SSL, with a certificate signed by a trusted
	    authority, to secure its service endpoint.  In addition,
	    SSL, with a certificate signed by a trusted authority,
	    SHOULD be used so that a Relying Party can fetch the
	    End User's URL in a secure manner.  Please keep in mind
	    that a Relying Party MAY decide to not complete, or even
	    begin, a transaction if SSL is not being correctly used
	    at these various endpoints.
          </t>
        </section>
      </section>

      <section title="User Agents">
        <t>
          Since this protocol is intended to be used interactively,
          User Agents will primarily be common Web browsers. Web
          browsers or their hosts may be infected with spyware or
          other malware, which limits the strength of the
          authentication assertion, since untrusted software makes it
          impossible to know whether the authentication decision has
          been made with the End User's approval. With this said, many
          web applications and protocols today rely on the security of
          the Web browser and their hosts.
        </t>

        <t>
          Cross-site-scripting attacks against IdPs may be used to the
          same effect. For the best security, IdPs should not depend
          on scripting so that User Agents without scripting enabled
          can make authentication decisions.
        </t>
      </section>

      <section title="User Interface Considerations">
        <t>
          The Relying Party SHOULD redirect the End User to the IdP
          Endpoint URL in a top-level browser window with all controls
          visible. This allows better protection for the End User
          against IdP look-alike sites (phishing).
        </t>
      </section>
    </section>

    <appendix title="Examples">
      <t>Non-normative</t>

      <appendix title="Delegation">
        <t>
          For example, an End User wants to use
          http://www.example.com/ as their Identifier, but
          http://www.example.com/ doesn't have the means, or desire,
          to run an IdP. LiveJournal is an Identity Provider, so if
          the End User has a LiveJournal OpenID Identifier, they can
          delegate their authentication to LiveJournal.
        </t>
      </appendix>

      <appendix title="XRDS">
        <t>
          <figure>
            <preamble>
              To use www.example.com as their Identifier, but have
              Relying Parties actually verify
              http://exampleuser.livejournal.com/ with the IdP
              Endpoint URL
              http://www.livejournal.com/openid/server.bml, the
              following XML snippet should be present in the final XRD
              element in the XRDS file:
            </preamble>
            <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/signon/2.0</Type>
  <URI>http://www.livejournal.com/openid/server.bml</URI>
  <Delegate xmlns="http://openid.net/signon/2.0">
    http://exampleuser.livejournal.com/
  </Delegate>
</Service>
]]></artwork>
          </figure> 
        </t>
      </appendix>

      <appendix title="HTML Identifier Markup">
        <figure>
          <preamble>
            To use www.example.com as their Identifier, but have
            Relying Parties actually verify
            http://exampleuser.livejournal.com/ with the Identity
            Provider located at
            http://www.livejournal.com/openid/server.bml, the
            following markup should be present in the &lt;head&gt;
            of the HTML document located by the identifier URL:
          </preamble>
          <artwork><![CDATA[
<link rel="openid.server"
      href="http://www.livejournal.com/openid/server.bml"/>
<link rel="openid.delegate"
      href="http://exampleuser.livejournal.com/"/>
]]></artwork>
        </figure> 
      </appendix>

      <appendix title="Login Form">
        <t>
          The End User visits a Relying Party site which supports
          OpenID Authentication.  The Relying Party presents the End
          User with a form field for them to enter their Identifier or
          their IdP's identifier.
        </t>

        <t>
          <figure>
            <preamble>For example:</preamble>
            <artwork>
              ----------------------------------
              |[logo]example.com               | [Login Button]
              ----------------------------------
            </artwork>
          </figure>
        </t>
      </appendix>

      <appendix title="XRI CanonicalID">
        <t>
          For example, if =example and =exmpl both yield an XRD
          document with the CanonicalID xri://(example)!1234 then
          those identifiers should be treated as equivalent. For
          applications with user accounts, those identifiers should
          both be attached to the same account.
        </t>
      </appendix>
    </appendix>

    <appendix title='Diffie-Hellman Key Exchange Default Value' anchor="pvalue">
      <figure>
        <preamble>
          This is a confirmed-prime number, used as the default
          modulus for Diffie-Hellman Key Exchange. In hexadecimal:
        </preamble>
        <artwork>
DCF93A0B883972EC0E19989AC5A2CE310E1D37717E8D9571BB7623731866E61E
F75A2E27898B057F9891C2E27A639C3F29B60814581CD3B2CA3986D268370557
7D45C2E7E52DC81C7A171876E5CEA74B1448BFDFAF18828EFD2519F14E45E382
6634AF1949E5B535CC829A483B8A76223E5D490A257F05BDFF16F2FB22C583AB
        </artwork>
      </figure>
    </appendix>

    <!-- XXX: An example for Generating Signatures might be nice. -->

    <appendix title="Changes from the Previous OpenID Authentication Specification">
      <t>
        This specification is based on the original specification for
        OpenID Authentication as written by Brad Fitzpatrick. That
        specification did not have a version number, but was called
        OpenID 1.0, and then OpenID 1.1 when it was revised.  The
        protocol outlined in this specification is intended to be
        backwards-compatible with the revised OpenID protocol.  The
        most significant changes to the specification are outlined in
        this section.
      </t>
      <appendix title="Updated Initiation and Discovery">
        <t>
          <list style="symbols">
            <t>
              Supports IdP-driven identifier selection. This new
              variation of the protocol flow is initiated by entering
              an Identifier for an IdP instead of an Identifier for an
              End User, and allows the IdP to assist the End User in
              selecting an Identifier.
            </t>
            <t>
              Supports the use of XRIs as Identifiers. XRIs may be
              used as Identifiers for both End Users and IdPs.
            </t>
            <t>
              When URLs are used as Identifiers, they are normalized
              according to RFC 3986, for better compatibility with
              existing Web infrastructure.
            </t>
            <t>
              Uses the Yadis protocol for discovery. This allows for
              using multiple IdPs for a single Identifier, for
              load-balancing and fallback in the case of IdP
              failure. Additionally, it allows for discovery of
              supported extensions.
            </t>
          </list>
        </t>
      </appendix>

      <appendix title="Security improvements">
        <t>
          A nonce is now part of the protocol for built-in protection
          against replay attacks.
        </t>
        <t>
          A new association type, HMAC-SHA256, and a new association
          session type, DH-SHA256, allow for stronger signatures on
          authentication assertions.
        </t>
      </appendix>

      <appendix title="Extensions">
        <t>
          Extensions are a new mechanism to support data exchange and
          other Relying Party-IdP communication along with the
          authentication exchange. Extensions allow for the exchange
          of arbitrary attributes, as well as for protocol extensions,
          such as the inclusion of additional information about the
          Relying Party in the authentication request.
        </t>
        <t>
          Because extensions can transfer arbitrary data, the
          Identifier is now optional in the response.
        </t>
      </appendix>
    </appendix>
  </middle>

  <back>
    <references title='Normative References'>
      <reference anchor='RFC2119'>
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials='B.S' surname='Bradner' fullname='Scott Bradner'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>
      <reference anchor='RFC3986'>
        <front>
          <title>Uniform Resource Identifiers (URI): Generic Syntax</title>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC1750'>
        <front>
          <title>Randomness Recommendations for Security</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Digital Equipment Corporation</organization>
          </author>
          <author initials='S.C' surname='Crocker'
                  fullname='Stephen D. Crocker'>
            <organization>CyberCash, Inc.</organization>
          </author>
          <author initials='J.S' surname='Schiller'
                  fullname='Jeffery I. Schiller'>
            <organization>Massachusetts Institute of Technology</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC2631'>
        <front>
          <title>Diffie-Hellman Key Agreement Method</title>
          <author initials='E.R' surname='Rescorla'
                  fullname='Eric Rescorla'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2631" />
      </reference>
      <reference anchor='RFC3548'>
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials='S.J' surname='Josefsson'
                  fullname='Simon Josefsson'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3548" />
      </reference>
      <reference anchor='RFC2104'>
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>
          <author initials='H.K' surname='Krawczyk' fullname='Hugo Krawczyk'>
            <organization>IBM</organization>
          </author>
          <author initials='M.B' surname='Bellare' fullname='Mihir Bellare'>
            <organization>UCSD</organization>
          </author>
          <author initials='R.C' surname='Canetti' fullname='Ran Canetti'>
            <organization>IBM</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2104" />
      </reference>
      <reference anchor='FIPS180-2'>
        <front>
          <title>Secure Hash Signature Standard</title>
          <author>
            <organization>U.S. Department of Commerce</organization>
          </author>
          <author>
            <organization>National Institute of Standards 
              and Technology</organization>
          </author>
        </front>
        <seriesInfo name="FIPS" value="180-2" />
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf" />
        <annotation>Defines Secure Hash Algorithm 256 (SHA256)</annotation>
      </reference>
      <reference anchor='HTML401'>
        <front>
          <title>HTML 4.01 Specification</title>
          <author>
            <organization>W3C</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.w3.org/TR/html401" />
      </reference>
      <reference anchor='RFC2616'>
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
          <author initials='R.F' surname='Fielding' fullname='R. Fielding'>
            <organization>UC Irvine</organization>
          </author>
          <author initials='J.G' surname='Gettys' fullname='J. Gettys'>
            <organization>Compaq/W3C</organization>
          </author>
          <author initials='J.M' surname='Mogul' fullname='J. Mogul'>
            <organization>Compaq</organization>
          </author>
          <author initials='H.F' surname='Frystyk' fullname='H. Frystyk'>
            <organization>W3C/MIT</organization>
          </author>
          <author initials='L.M' surname='Masinter' fullname='L. Masinter'>
            <organization>Xerox</organization>
          </author>
          <author initials='P.L' surname='Leach' fullname='P. Leach'>
            <organization>Microsoft</organization>
          </author>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization>W3C/MIT</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2616" />
      </reference>
      <reference anchor='RFC3174'>
        <front>
          <title>US Secure Hash Algorithm 1 (SHA1)</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Motorola</organization>
          </author>
          <author initials='P.J' surname='Jones' fullname='Paul E. Jones'>
            <organization>Cisco Systems, Inc.</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor='RFC3339'>
        <front>
          <title>Date and Time on the Internet: Timestamps</title>
          <author initials='C.N' surname='Newman'
                  fullname='Chris Newman'>
            <organization>Sun Microsystems</organization>
          </author>
          <author initials='G.K' surname='Klyne' fullname='Graham Klyne'>
            <organization>Clearswift Corporation</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor="XRI Syntax 2.0"
                 target="http://www.oasis-open.org/committees/download.php/15376#_Toc117301848" >

        <front>
          <title>Extensible Resource Identifier (XRI) Syntax V2.0</title>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='D.M' surname='McAlpin' fullname="Dave McAlpin">
            <organization>Epok</organization>
          </author>
        </front>
        <format type="HTML" target=
                "http://www.oasis-open.org/committees/download.php/15376" />
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/15377" />
      </reference>
      <reference anchor="Yadis"
                 target="http://yadis.org/papers/yadis-v1.0.pdf" >
        <front>
          <title>Yadis Specification 1.0</title>
          <author initials='J.M' surname='Miller' fullname="Joaquin Miller">
            <organization>NetMesh</organization>
          </author>
        </front>
      </reference>
    </references>
  </back>
</rfc>
