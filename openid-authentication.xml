<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<rfc category="info" ipr="full3978" docName="openid-authentication-2_0-11.xml">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="2" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="yes" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Implementor's Draft" ?>

  <front>
    <title>OpenID Authentication 2.0 - Draft 11</title>

    <author initials="" surname="specs@openid.net" fullname="specs@openid.net">
      <organization />
    </author>

    <date month="January" year="2007"/>

    <abstract>
      <t>
        OpenID Authentication provides a way to prove that an end user
        controls an Identifier. It does this without the Relying Party
        needing access to end user credentials such as a password or
        to other sensitive information such as an email address.
      </t>

      <t>
        OpenID is decentralized. No central authority must approve or
        register Relying Parties or OpenID Providers. An end user
        can freely choose which OpenID Provider to use, and can
        preserve their Identifier if they switch OpenID Providers.
      </t>

      <t>
        While nothing in the protocol requires JavaScript or modern
        browsers, the authentication scheme plays nicely with
        "AJAX"-style setups. This means an end user can prove their
        Identity to a Relying Party without having to leave their
        current Web page.
      </t>

      <t>
        OpenID Authentication uses only standard HTTP(S) requests and
        responses, so it does not require any special capabilities of
        the User-Agent or other client software. OpenID is not tied to
        the use of cookies or any other specific mechanism of Relying
        Party or OpenID Provider session management.  Extensions to
        User-Agents can simplify the end user interaction, though are
        not required to utilize the protocol.
      </t>

      <t>
        The exchange of profile information, or the exchange of other
        information not covered in this specification, can be addressed
        through additional service types built on top of this
        protocol to create a framework. OpenID Authentication is
        designed to provide a base service to enable portable,
        user-centric digital identity in a free and decentralized manner.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Notation and Conventions">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
        and "OPTIONAL" in this document are to be interpreted as
        described in <xref target="RFC2119"/>.
      </t>

      <t>
        Throughout this document, values are quoted to indicate that
        they are to be taken literally. When using these values in
        protocol messages, the quotes MUST NOT be used as part of the
        value.
      </t>
    </section>

    <section title="Terminology" anchor="terminology">
      <t>
        <list style="hanging">
          <t hangText="Identifier:">
            An Identifier is either a "http" or "https" URI, (commonly
            referred to as a "URL" within this document), or an <xref
            target="XRI_Syntax_2.0" >XRI</xref>.  This document defines
            various kinds of Identifiers, designed for use in different
            contexts.
          </t>

          <t hangText="User-Agent:">
            The end user's Web browser which implements HTTP/1.1 <xref
            target="RFC2616"/>.
          </t>

          <t hangText="Relying Party:">
            RP. A Web application that wants proof that the end user
            controls an Identifier.
          </t>

          <t hangText="OpenID Provider:">
            OP. An OpenID Authentication server on which a Relying
            Party relies for an assertion that the end user controls
            an Identifier.
          </t>

          <t hangText="OP Endpoint URL:">
            The URL which accepts OpenID Authentication requests,
            obtained by performing discovery on the the User-Supplied
            Identifier. This value MUST be an absolute URL.
          </t>

          <t hangText="OP Identifier:">
            An Identifier for an OpenID Provider.
          </t>

          <t hangText="User-Supplied Identifier:">
            An Identifier that was presented by the end user to the
            Relying Party, or selected by the user at the OpenID
            Provider.  During the initiation phase of the protocol,
            an end user may enter either their own Identifier or an OP
            Identifier. If an OP Identifier is used, the OP may then
            assist the end user in selecting an Identifier to share with
            the Relying Party.
          </t>

          <t hangText="Claimed Identifier:">
            An Identifier that the end user claims to own; the overall
            aim of the protocol is verifying this claim. The Claimed
            Identifier is either:
            <list style="symbols">
              <t>
                The Identifier obtained by <xref target="normalization">
                normalizing</xref> the User-Supplied Identifier, if it
                was an URL.
              </t>
              <t>
                The <xref target="canonicalid">CanonicalID</xref>, if it
                was an XRI.
              </t>
            </list>
          </t>

          <t hangText="OP-Local Identifier:">
            An alternate Identifier for an end user that is local to a
            particular OP and thus not necessarily under the end user's
            control.
          </t>
        </list>
      </t>
    </section>

    <section title="Protocol Overview">

      <t>
        <list style="numbers">
          <t>
            The end user <xref target="initiation">initiates
            authentication</xref> by presenting a User-Supplied Identifier
            to the Relying Party via their User-Agent.
          </t>
          <t>
            After <xref target="normalization">normalizing</xref> the
            User-Supplied Identifier, the Relying Party <xref
            target="discovery">performs discovery</xref> on it and
            establishes the OP Endpoint URL that the end user uses for
            authentication.  It should be noted that the User-Supplied
            Identifier may be an OP Identifier, as discussed in <xref
            target="discovered_info" />, which allows selection of a
            Claimed Identifier at the OP or for the protocol to
            proceed without a Claimed Identifier if something else
            useful is being done via an <xref
            target="extensions">extension</xref>.
          </t>
          <t>
            (optional)

            The Relying Party and the OP establish an <xref
            target="associations">association</xref> -- a shared
            secret established using <xref
            target="RFC2631">Diffie-Hellman Key Exchange</xref>. The
            OP uses an association to sign subsequent messages and the
            Relying Party to verify those messages; this removes the
            need for subsequent direct requests to verify the
            signature after each authentication request/response.
          </t>
          <t>
            The Relying Party redirects the end user's User-Agent to
            the OP with an OpenID <xref
            target="requesting_authentication">Authentication
            request</xref>.
          </t>
          <t>
            The OP establishes whether the end user is authorized to
            perform OpenID Authentication and wishes to do so. The
            manner in which the end user authenticates to their OP and
            any policies surrounding such authentication is out of
            scope for this document.
          </t>
          <t>
            The OP redirects the end user's User-Agent back to the
            Relying Party with either an assertion that <xref
            target="positive_assertions">authentication is
            approved</xref> or a message that <xref
            target="negative_assertions">authentication failed</xref>.
          </t>
          <t>
            The Relying Party <xref target="verification">verifies
            </xref> the information received from the OP including
            checking the Return URL, verifying the discovered
            information, checking the nonce, and verifying the
            signature by using either the shared key established
            during the association or by sending a direct request
            to the OP.
           </t>
         </list>
      </t>
    </section>


    <section title="Data Formats">

      <section title="Protocol Messages">

        <t>
          The OpenID Authentication protocol messages are
          mappings of plain-text keys to plain-text values. The keys and
          values permit the full Unicode character set (UCS). When the
          keys and values need to be converted to/from bytes, they
          MUST be encoded using <xref target="RFC3629">UTF-8</xref>.
        </t>

        <t>
          Messages MUST NOT contain multiple parameters with the same name.
        </t>

        <t>
          Throughout this document, all OpenID message parameters are
          REQUIRED, unless specifically marked as OPTIONAL.
        </t>

        <section title="Key-Value Form Encoding" anchor="kvform">
          <t>
            A message in Key-Value form is a sequence of lines.  Each
            line begins with a key, followed by a colon, and the value
            associated with the key.  The line is terminated by a
            single newline (UCS codepoint 10, "\n"). A key or value
            MUST NOT contain a newline and a key also MUST NOT contain
            a colon.
          </t>
          <t>
            Additional characters, including whitespace, MUST NOT be
            added before or after the colon or newline. The message
            MUST be encoded in UTF-8 to produce a byte string.
          </t>
          <t>
            Key-Value Form encoding is used for signature calculation
            and for <xref target="direct_response">direct
            responses</xref> to Relying Parties.
          </t>
        </section>

        <section title="HTTP Encoding" anchor="http_encoding">
          <t>
            When a message is sent to an HTTP server, it MUST be encoded
            using a form encoding specified in Section 17.13.4 of
            <xref target="HTML401" />. Likewise, if the "Content-Type"
            header is included in the request headers, its value MUST
            also be such an encoding.
          </t>
          <t>
            All of the keys in the request message MUST be prefixed
            with "openid.". This prefix prevents interference with
            other parameters that are passed along with the OpenID
            Authentication message. When a message is sent as a POST,
            OpenID parameters MUST only be sent in, and extracted
            from, the POST body.
          </t>
          <t>
            All messages that are sent as HTTP requests (GET or POST)
            MUST contain the following fields:

            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://specs.openid.net/auth/2.0"
                  </t>
                  <t>
                    This particular value MUST be present for the
                    request to be a valid OpenID Authentication 2.0
                    request. Future versions of the specification may
                    define different values in order to allow message
                    recipients to properly interpret the request.
                  </t>
                  <t>
                    If this value is absent or set to one of
                    "http://openid.net/signon/1.1" or
                    "http://openid.net/signon/1.0", then this message
                    SHOULD be interpreted using <xref
                    target="compat_mode">OpenID Authentication 1.1
                    Compatibility mode</xref>.
                  </t>
                </list>
              </t>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: Specified individually for each message
                    type.
                  </t>
                  <t>
                    The "openid.mode" parameter allows the recipient
                    of the message to know what kind of message it is
                    processing. If "openid.mode" is absent, the party
                    processing the message SHOULD assume that the
                    request is not an OpenID message.
                  </t>
                </list>
              </t>
            </list>
          </t>

          <t>
            This model applies to messages from the User-Agent to both
            the Relying Party and the OP, as well as messages from the
            Relying Party to the OP.
          </t>
        </section>
        <section title="Example">
          <t>
            Non-normative
          </t>
          <figure>
            <preamble>
              The following examples encode the following information:
            </preamble>
            <artwork><![CDATA[
Key     | Value
--------+---------------------------
mode    | error
error   | This is an example message
]]>
            </artwork>
          </figure>

          <figure>
            <preamble>
              Key-Value Form encoded:
            </preamble>
            <artwork><![CDATA[mode:error
error:This is an example message
]]>
            </artwork>
          </figure>

          <figure>
            <preamble>
              x-www-urlencoded, as in a HTTP POST body or in a URL's
              query string (<xref target="RFC3986" /> section 3):
            </preamble>
            <artwork>openid.mode=error&amp;openid.error=This%20is%20an%20example%20message</artwork>
          </figure>
        </section>
      </section>

      <section title="Integer Representations" anchor="btwoc">
        <t>
          Arbitrary precision integers MUST be encoded as big-endian
          signed two's complement binary strings. Henceforth, "btwoc"
          is a function that takes an arbitrary precision integer and
          returns its shortest big-endian two's complement
          representation. All integers that are used with
          Diffie-Hellman Key Exchange are positive. This means that
          the left-most bit of the two's complement representation
          MUST be zero. If it is not, implementations MUST add a zero
          byte at the front of the string.
        </t>
        <figure>
          <preamble>Non-normative example:</preamble>
          <artwork>
Base 10 number | btwoc string representation
---------------+----------------------------
0              | "\x00"
127            | "\x7F"
128            | "\x00\x80"
255            | "\x00\xFF"
32768          | "\x00\x80\x00"
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Communication Types">
      <section title="Direct Communication"
               anchor="direct_comm">
        <t>
          Direct communication is initiated by a Relying Party to an
          OP endpoint URL.  It is used for <xref
          target="associations">establishing associations</xref> and
          <xref target="check_auth">verifying authentication
          assertions</xref>.
        </t>
        <section title="Direct Request" anchor="direct_request">
          <t>
            The message MUST be encoded as a POST body, as specified
            by <xref target="http_encoding" />.
          </t>
          <t>
            All direct requests are HTTP POSTs, and so
            contain the required fields listed in <xref
                target="http_encoding" />.
          </t>
        </section>
        <section title="Direct Response" anchor="direct_response">
          <t>
            The body of a response to a <xref
            target="direct_request">Direct Request</xref> consists of
            an HTTP Response body in <xref target="kvform">Key-Value
            Form</xref>. The content-type of the response SHOULD be
            "text/plain".
          </t>
          <t>
            All Key-Value form message MUST contain the following field:

            <list style='symbols'>
              <t>
                ns
                <list style='empty'>
                  <t>
                    Value: "http://specs.openid.net/auth/2.0"
                  </t>
                  <t>
                    This particular value MUST be present for the
                    response to be a valid OpenID 2.0 response. Future
                    versions of the specification may define different
                    values in order to allow message recipients to
                    properly interpret the request.
                  </t>
                  <t>
                    If this value is absent or set to one of
                    "http://openid.net/signon/1.1" or
                    "http://openid.net/signon/1.0", then this message
                    SHOULD be interpreted using <xref
                    target="compat_mode">OpenID Authentication 1.1
                    Compatibility mode</xref>.
                  </t>
                </list>
              </t>
            </list>
          </t>

          <section title="Successful Responses">
            <t>
              A server receiving a valid request MUST send a
              response with an HTTP status code of 200.
            </t>
          </section>

          <section title="Error Responses">
            <t>
              If a request is malformed or contains invalid arguments,
              the server MUST send a response with a status code of
              400. The response body MUST be a <xref
              target="kvform">Key-Value Form</xref> message with the
              following fields:
            </t>
            <t>
              <list style='symbols'>
                <t>
                  ns
                  <list style='empty'>
                    <t>
                      As specified in <xref target="direct_response" />.
                    </t>
                  </list>
                </t>

                <t>
                  error
                  <list style='empty'>
                    <t>
                      Value: A human-readable message indicating the cause
                      of the error.
                    </t>
                  </list>
                </t>

                <t>
                  contact
                  <list style='empty'>
                    <t>
                      Value: (optional) Contact address for the
                      administrator of the sever. The contact address
                      may take any form, as it is intended to be
                      displayed to a person.
                    </t>
                  </list>
                </t>

                <t>
                  reference
                  <list style='empty'>
                    <t>
                      Value: (optional) A reference token, such
                      as a support ticket number or a URL to a news
                      blog, etc.
                    </t>
                  </list>
                </t>
              </list>
               The OP MAY add additional fields to this response.
            </t>
          </section>
        </section>
      </section>
      <section title="Indirect Communication"
               anchor="indirect_comm">
        <t>
          In indirect communication, messages are passed through the
          User-Agent.  This can be initiated by either the Relying
          Party or the OP.  Indirect communication is used for <xref
          target="requesting_authentication">authentication
          requests</xref> and <xref
          target="responding_to_authentication">authentication
          responses</xref>.
        </t>
        <t>
          There are two methods for indirect communication: HTTP
          redirects and HTML form submission.
          Both form submission and redirection require that the sender
          know a recipient URL and that the recipient URL expect
          indirect messages, as specified in <xref target="http_encoding"
          />. The initiator of the communication chooses which method
          of indirect communication is appropriate depending on
          capabilities, message size, or other external factors.
        </t>
        <t>
          All indirect messages arrive as HTTP requests, and so
          contain the required fields listed in <xref
          target="http_encoding" />.
        </t>

        <section title="HTTP Redirect">
          <t>
            Data can be transferred by issuing a 302, 303, or 307 HTTP
            Redirect to the end user's User-Agent. The redirect URL is
            the URL of the receiver with the OpenID Authentication
            message appended to the query string, as specified in
            <xref target="http_encoding" />.
          </t>
        </section>

        <section title="HTML FORM Redirection">
          <t>
            A mapping of keys to values can be transferred by
            returning an HTML page to the User-Agent that contains an
            HTML form element. Form submission MAY be automated,
            for example by using JavaScript.
          </t>
          <t>
            The &lt;form&gt; element's "action" attribute value MUST
            be the URL of the receivier. Each Key-Value pair MUST be
            included in the form as an &lt;input&gt; element. The key
            MUST be encoded as the "name" attribute and the value as
            the "value" attribute, such that the User-Agent will
            generate a message as specified in <xref
            target="http_encoding"/> when the form is submitted. The
            form MUST include a submit button.
          </t>
        </section>
        <section title="Indirect Error Responses" anchor="indirect_error">
          <t>
            In the case of a malformed request, or one that contains
            invalid arguments, the OpenID Provider MUST redirect the
            User-Agent to the "openid.return_to" URL value if the
            value is present and it is a valid URL.
          </t>
          <t>
            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    As specified in <xref target="http_encoding" />.
                  </t>
                </list>
              </t>

              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "error"
                  </t>
                </list>
              </t>
              <t>
                openid.error
                <list style='empty'>
                  <t>
                    Value: A human-readable message indicating the cause
                    of the error.
                  </t>
                </list>
              </t>
              <t>
                openid.contact
                <list style='empty'>
                  <t>
                    Value: (optional) Contact address for the
                    administrator of the sever. The contact address
                    may take any form, as it is intended to be
                    displayed to a person.
                  </t>
                </list>
              </t>

              <t>
                openid.reference
                <list style='empty'>
                  <t>
                    Value: (optional) A reference token, such as a
                    support ticket number or a URL to a news blog,
                    etc.
                  </t>
                </list>
              </t>
            </list>

            The server MAY add additional keys to this response.
          </t>
          <t>
            If the malformed or invalid message is received by the Relying
            Party, or "openid.return_to" is not present or its value is not
            a valid URL, the server SHOULD return a response to the
            end user indicating the error and that it is unable to continue.
          </t>
        </section>
      </section>
    </section>

    <section title="Generating Signatures" anchor="generating_signatures">
      <t>
        The most common usage of an association is as a Message
        Authentication Code (MAC) key used to sign OpenID
        Authentication messages.
      </t>
      <t>
        When generating MAC keys, the recommendations in <xref
        target="RFC1750" /> SHOULD be followed.
      </t>

      <section title="Procedure">
        <t>
          To generate a message signature:

          <list style="numbers">
            <t>
              Determine the list of keys to be signed, according to
              the message to be signed (See <xref
              target="positive_assertions" />). The list of keys to be
              signed MUST be part of the message. The list is stored
              with the key "openid.signed". The value is a
              comma-separated list of keys, with the "openid." prefix
              stripped. This algorithm is only capable of signing keys
              that start with "openid."
            </t>

            <t>
              Iterate through the list of keys to be signed in the
              order they appear in "openid.signed" list.  For each
              key, find the value in the message whose key is equal to
              the signed list key prefixed with "openid."
            </t>

            <t>
              Convert the list of key/value pairs to be signed to an
              octet string by encoding with <xref
              target="kvform">Key-Value Form Encoding</xref>.
            </t>

            <t>
              Determine the signature algorithm from the <xref
              target="associations">association type</xref>.  Apply
              the <xref target="sign_algos">signature algorithm</xref>
              to the octet string.
            </t>
          </list>
        </t>
      </section>

      <section title="Signature Algorithms" anchor="sign_algos">
        <t>
          OpenID Authentication supports two signature algorithms:

          <list style="symbols">
            <t>HMAC-SHA1 - 160 bit key length (<xref target="RFC2104" /> and <xref
                target="RFC3174" />)</t>
            <t>HMAC-SHA256 - 256 bit key length (<xref target="RFC2104" /> and <xref
                target="FIPS180-2" /></t>
          </list>

          If supported, the use of HMAC-SHA256 is RECOMMENDED.
        </t>
      </section>
    </section>

    <section title="Initiation and Discovery">

      <section title="Initiation" anchor="initiation">
        <t>
          To initiate OpenID Authentication, the Relying Party SHOULD
          present the end user with a form that has a field for
          entering a User-Supplied Identifier.
        </t>

        <t>
          The form field's "name" attribute SHOULD have the value
          "openid_identifier", so that User-Agents can automatically
          determine that this is an OpenID form. Browser extensions or
          other software that support OpenID Authentication may not
          detect a Relying Party's support if this attribute is not
          set appropriately.
        </t>
      </section>

      <section title="Normalization" anchor="normalization">
        <t>
          The end user's input MUST be normalized into an
          Identifier, as follows:
        </t>

        <t>
          <list style="numbers">
            <t>
              If the user's input starts with one of the "xri://",
              "xri://$ip*", or "xri://$dns*" prefixes, they MUST be
              stripped off, so that XRIs are used in the canonical
              form, and URI-authority XRIs are further considered URL
              identifiers.
            </t>

            <t>
              If the first character of the resulting string is an
              XRI Global Context Symbol ("=", "@", "+", "$", "!") as
              defined in Section 2.2.1 of<xref target="XRI_Syntax_2.0" />,
              then the input SHOULD be treated as an XRI.
            </t>

            <t>
              Otherwise, the input SHOULD be treated as an http URL; if it
              does not include a "http" or "https" scheme, the Identifier
              MUST be prefixed with the string "http://". See
              <xref target='http_s_identifiers' /> for more information.
            </t>

            <t>
              URL identifiers MUST then be further normalized by both
              following redirects when retrieving their content and
              finally applying the rules in Section 6 of <xref
              target='RFC3986' /> to the final destination URL. This
              final URL MUST be noted by the Relying Party as the
              Claimed Identifier and be used when <xref
              target="requesting_authentication">requesting
              authentication</xref>.
            </t>
          </list>

          See <xref target="normalization_example">normalization
          example</xref>.

        </t>
      </section>

      <section title="Discovery" anchor="discovery">

        <t>
          Discovery is the process where the Relying Party uses the
          Identifier to look up ("discover") the necessary information
          for initiating requests. OpenID Authentication has three
          paths through which to do discovery:
        </t>

        <t>
          <list style="numbers">
            <t>
              If the identifier is an XRI, <xref
              target="XRI_Resolution_2.0" />
              will yield an XRDS document that
              contains the necessary information.  It should also be
              noted that Relying Parties can take advantage of
              XRI Proxy Resolvers, such as the one provided by
              XDI.org at http://www.xri.net. This will remove the need for the RPs to
              perform XRI Resolution locally.
            </t>

            <t>
              If it is a URL, the <xref target="Yadis">Yadis
              protocol</xref> SHALL be first attempted. If it
              succeeds, the result is again an XRDS document.
            </t>

            <t>
              If the Yadis protocol fails and no valid XRDS document
              is retrieved, or no <xref
              target="service_elements">Service Elements</xref> are
              found in the XRDS document, the URL is retrieved and
              <xref target="html_disco">HTML-Based discovery</xref>
              SHALL be attempted.
            </t>
          </list>
        </t>

        <section title="Discovered Information" anchor="discovered_info">
          <t>
            Upon successful completion of discovery, the Relying Party
            will have one or more sets of the following information
            (see the <xref target="terminology">Terminology
            section</xref> for definitions).  If more than one set of
            the following information has been discovered, the
            precedence rules defined in <xref target="XRI_Resolution_2.0" />
            are to be applied.

            <list style="symbols">
              <t>OP Endpoint URL</t>
              <t>Protocol Version</t>
            </list>

            If the end user did not enter an OP Identifier, the
            following information will also be present:

            <list style="symbols">
              <t>Claimed Identifier</t>
              <t>OP-Local Identifier</t>
            </list>

            If the end user entered an OP Identifier, there is no
            Claimed Identifier. For the purposes of making OpenID
            Authentication requests, the value
            "http://specs.openid.net/auth/2.0/identifier_select"
            MUST be used as both the Claimed Identifier and the
            OP-Local Identifier when an OP Identifier is entered.
          </t>
        </section>

        <section title="XRDS-Based Discovery">
          <t>
            If XRI or Yadis discovery was used, the result will be an
            XRDS Document.  This is an XML document with entries for
            services that are related to the Identifier.  It is
            defined in <xref target="XRI_Resolution_2.0">Section 3
            of</xref>.  See <xref target="XRDS_Sample" /> for an
            example XRDS document.
          </t>


          <section title="OpenID Service Elements" anchor="service_elements">

            <section title="OP Identifier Element">
              <t>
                An OP Identifier Element is an &lt;xrd:Service&gt;
                element with the following information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://specs.openid.net/auth/2.0/server".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    OP Endpoint URL
                  </t>
                </list>
              </t>
            </section>

            <section title="Claimed Identifier Element">
              <t>
                A Claimed Identifier Element is an
                &lt;xrd:Service&gt; element with the following
                information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://specs.openid.net/auth/2.0/signon".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    OP Endpoint URL.
                  </t>

                  <t>
                    An &lt;xrd:LocalID&gt; tag (optional) whose text
                    content is the OP-Local Identifier.
                  </t>
                </list>
              </t>
            </section>
          </section>

          <section title="Extracting Authentication Data"
                   anchor="extracting_auth">
            <t>
              Once the Relying Party has obtained an XRDS document, it
              MUST first search the document (following the rules
              described in <xref target="XRI_Resolution_2.0" />) for
              an OP Identifier Element. If none is found, the RP will search
              for a Claimed Identifier Element.
            </t>
          </section>

          <section title="XRI and the CanonicalID Element" anchor="canonicalid"
                   toc="exclude">
            <t>
              When the Identifier is an XRI, the &lt;xrd:XRD&gt;
              element that contains the OpenID Authentication
              &lt;xrd:Service&gt; element MUST also contain a
              &lt;CanonicalID&gt; element. The content of this element
              MUST be used as the Claimed Identifier (see <xref
              target="identifying" />).  This is a vital security
              consideration because a primary purpose of the
              &lt;CanonicalID&gt; element is to assert a persistent
              identifier that will never be reassigned, thus
              preventing the possibility of an XRI being ("taken
              over") by a new registrant.
            </t>

            <t>
              The Relying Party MUST confirm that the provider of the
              XRD that contains the &lt;CanonicalID&gt; element is
              authoritative for that Canonical ID and that this XRDS
              document is authoritative for the OpenID Service
              Element. Relying Parties should either do this manually
              or ensure that their resolver does this.
           </t>

            <t>
              When using XRI resolution, the Canonical ID MUST be
              used as the Claimed Identifier. For an XRI to be a
              valid Identifier, both the &lt;ProviderID&gt; and
              &lt;CanonicalID&gt; MUST be present in the discovered
              XRDS document.
            </t>

            <t>
              When using URL Identifiers, the CanonicalID
              element MUST be ignored if present.
            </t>
          </section>

          <section title="Additional Information">
            <t>
              The "openid" namespace is no longer used as of OpenID
              Authentication 2.0.  The "xrd" namespace is
              "xri://$xrd*($v*2.0)".
            </t>

            <t>
              For compatibility with deployed code, it is RECOMMENDED
              that Relying Parties also accept
              "http://openid.net/signon/1.0" or
              "http://openid.net/signon/1.1" for the value of
              &lt;xrd:Type&gt;, as described in the <xref
              target="compat_mode">OpenID Authentication 1.1
              Compatibility mode</xref> section. It is RECOMMENDED
              that Relying Parties supporting OpenID Authentication
              2.0 choose to use, if available, endpoints with the type
              "http://specs.openid.net/auth/2.0/server" and
              "http://specs.openid.net/auth/2.0/signon", in
              this order, as specified in <xref
              target="extracting_auth" />
            </t>

            <t>
              If an OP supports extensions (<xref target="extensions"
              />), the extensions SHOULD be listed as additional
              &lt;xrd:Type&gt; child elements of the
              &lt;xrd:Service&gt; element.
            </t>

          </section>

        </section>

        <section anchor="html_disco" title="HTML-Based Discovery">
          <t>
            HTML-Based discovery MUST be supported by Relying
            Parties. HTML-Based discovery is only usable for discovery
            of Claimed Identifiers. OP Identifiers must be XRIs or
            URLs that support XRDS discovery.
          </t>

          <t>
            To use HTML-Based discovery, an HTML document MUST be
            available at the URL of the Claimed Identifier. Within the
            HEAD element of the document:

            <list>
              <t>
                A LINK element MUST be included with attributes
                "rel" set to "openid2.provider" and "href" set to an OP
                Endpoint URL
              </t>
              <t>
                A LINK element MAY be included with attributes
                "rel" set to "openid2.local_id" and "href" set to the
                end user's OP-Local Identifier
              </t>
            </list>
          </t>

          <t>
            The protocol version when HTML discovery is performed is
            "http://specs.openid.net/auth/2.0/signon".
          </t>

          <t>
            The host of the HTML document MAY be different from the
            end user's OP's host.
          </t>

          <t>
            The "openid2.provider" and "openid2.local_id" URLs MUST NOT
            include entities other than "&amp;amp;", "&amp;lt;",
            "&amp;gt;", and "&amp;quot;". Other characters that would
            not be valid in the HTML document or that cannot be
            represented in the document's character encoding MUST be
            escaped using the percent-encoding (%xx) mechanism
            described in <xref target='RFC3986' />.
          </t>
        </section>
      </section>
    </section>


    <section title="Establishing Associations" anchor="associations">
      <t>
        An association between the Relying Parry and the OpenID Provider
        establishes a shared secret between them, which is used to verify
        subsequent protocol messages and reduce round trips.
      </t>

      <t>
        It is RECOMMENDED that a Relying Party form associations if it
        is possible for it to do so.  If a Relying Party is incapable
        of creating or storing associations, <xref target="check_auth" />
        provides an alternate verification mechanism referred to as
        Stateless Mode.
      </t>

      <section title="Association Session Request">
        <t>
          An association session is initiated by a <xref
          target="direct_comm">direct request</xref> from a Relying
          Party to an OP Endpoint URL with the "openid.mode" key
          having the value of "associate".
        </t>

        <section title="Common Request Parameters" toc="exclude">
          <t>
            These parameters are common to all association requests:
          </t>
          <t>
            <list style="symbols">
              <t>openid.ns
                <list style='empty'>
                  <t>
                    As specified in <xref target="http_encoding" />.
                  </t>
                </list>
              </t>
              <t>openid.mode
                <list style="empty">
                  <t> Value: "associate"</t>
                </list>
              </t>

              <t>openid.assoc_type
                <list style="empty">
                  <t> The preferred association type.  The association
                    type defines the algorithm to be used to sign
                    subsequent messages.</t>
                  <t> Value: A valid association type from <xref
                  target="assoc_types"/></t>
                </list>
              </t>

              <t>openid.session_type
                <list style='empty'>
                  <t>
                    The preferred association session type.  This
                    defines the method used to encrypt the association's
                    MAC key in transit.
                  </t>
                  <t>
                    Value: A valid association session type from
                    <xref target="assoc_sess_types"/>.
                  </t>
                  <t>
                    Note: Unless using transport layer encryption, it
                    is NOT RECOMMENDED to use "no-encryption" on a
                    public network, see <xref
                        target="preventing_eavesdropping" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Diffie-Hellman Request Parameters" toc="exclude">
          <t>
            The following parameters are common to requests whose
            requested association session type is "DH-SHA1" or
            "DH-SHA256":
          </t>
          <t>
            <list style="symbols">
              <t>
                openid.dh_modulus
                <list style='empty'>
                  <t>Value: base64(btwoc(p))</t>
                  <t>Default: See <xref target='pvalue' /></t>
                </list>
              </t>
              <t>
                openid.dh_gen
                <list style='empty'>
                  <t>Value: base64(btwoc(g))</t>
                  <t>Default: g = 2</t>
                </list>
              </t>
              <t>
                openid.dh_consumer_public
                <list style='empty'>
                  <t>Value: base64(btwoc(g ^ xa mod p))</t>
                </list>
              </t>
            </list>
          </t>
          <t>
            See <xref target="dh_sessions"/> for more information on
            these parameters.
          </t>
          <t>
            NOTE: The 'btwoc' function is defined in <xref
            target="btwoc"/>.
          </t>
        </section>
      </section>

      <section title="Association Session Response">
        <t>
          An association session response is a direct response from the
          OP to the Relying Party in <xref target="kvform">Key-Value
          Form</xref>.
        </t>

        <section title="Common Response Parameters">
          <t>
            <list style="symbols">
              <t>
                ns
                <list style="empty">
                  <t>
                    As specified in <xref target="direct_response" />.
                  </t>
                </list>
              </t>
              <t>
                assoc_handle
                <list style="empty">
                  <t>
                    The association handle is used as a key to refer
                    to this association in subsequent messages.
                  </t>
                  <t>
                    Value: A string 255 characters or less in length.
                    It MUST consist only of ASCII characters in the
                    range 33-126 inclusive (printable non-whitespace
                    characters).
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style="empty">
                  <t>
                    The value of the "openid.session_type" parameter
                    from the request.  If the OP is unwilling or
                    unable to support this association type, it MUST
                    return an <xref target="refuse_assoc">unsuccessful
                    response</xref>.
                  </t>
                </list>
              </t>
              <t>
                assoc_type
                <list style="empty">
                  <t>
                    The value of the "openid.assoc_type" parameter
                    from the request.  If the OP is unwilling or
                    unable to support this association type, it MUST
                    return an <xref target="refuse_assoc">unsuccessful
                    response</xref>.
                  </t>
                </list>
              </t>
              <t>
                expires_in
                <list style="empty">
                  <t>
                    The lifetime, in seconds, of this association.
                    The Relying Party MUST NOT use the association
                    after this time has passed.
                  </t>
                  <t>
                    Value: An integer, represented in base 10 ASCII.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Unencrypted Response Parameters">
          <t>
            <list style="symbols">
              <t>
                mac_key
                <list style='empty'>
                  <t>
                    The MAC key (shared secret) for this
                    association, <xref target="RFC3548">Base 64</xref>
                    encoded.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>


        <section title='Diffie-Hellman Response Parameters' toc="exclude">
          <t>
            <list style="symbols">
              <t>
                dh_server_public
                <list style='empty'>
                  <t>
                    Value: base64(btwoc(g ^ xb mod p))
                  </t>
                  <t>
                    Description: The OP's Diffie-Hellman public key.
                  </t>
                </list>
              </t>
              <t>
                enc_mac_key
                <list style='empty'>
                  <t>
                    Value: base64(H(btwoc(g ^ (xa * xb) mod p)) XOR MAC key)
                  </t>
                  <t>
                    Description: The MAC key (shared secret),
                    encrypted with the secret Diffie-Hellman value. H
                    is either "SHA1" or "SHA256" depending on the
                    session type.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            NOTE: The 'btwoc' function is defined in <xref
            target="btwoc"/>
          </t>
        </section>

        <section anchor="refuse_assoc"
                 title="Unsuccessful Response Parameters">
          <t>
            If the OP does not support a session type or association
            type, it MUST respond with a direct error message
            indicating that the association request failed. If there
            is another association session type or association type
            that is supported, the OP SHOULD include that information
            in the response.
          </t>
          <t>
            <list style='symbols'>
              <t>
                ns
                <list style="empty">
                  <t>
                    As specified in <xref target="direct_response" />.
                  </t>
                </list>
              </t>
              <t>
                error
                <list style='empty'>
                  <t>
                    Value: A human-readable message indicating why the
                    association request failed.
                  </t>
                </list>
              </t>
              <t>
                error_code
                <list style='empty'>
                  <t>
                    Value: "unsupported-type"
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style='empty'>
                  <t>
                    Value: (optional) A valid association session type
                    from <xref target="assoc_sess_types" /> that the
                    OP supports.
                  </t>
                </list>
              </t>
              <t>
                assoc_type
                <list style='empty'>
                  <t>
                    Value: (optional) An association type supported by
                    the OP from <xref target="assoc_types" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            Upon receipt of an "unsupported-type" response, the
            Relying Party MAY make another request with the specified
            association session type and association type. If no
            association is established, the Relying Party MAY continue
            the authentication process in <xref target="check_auth">
            Direct Verification</xref>.
          </t>
        </section>
      </section>

      <section title="Association Types" anchor="assoc_types">
        <section title="HMAC-SHA1">
          <t>
            An association of type "HMAC-SHA1" uses the <xref
            target="sign_algos">HMAC-SHA1</xref> signature algorithm.
          </t>
        </section>

        <section title="HMAC-SHA256">
          <t>
            An association of type "HMAC-256" uses the <xref
            target="sign_algos">HMAC-SHA256</xref> signature
            algorithm.
          </t>
        </section>
      </section>

      <section title="Association Session Types" anchor="assoc_sess_types">
        <t>
          OpenID Authentication defines three valid association
          session types: "no-encryption", "DH-SHA1", and "DH-SHA256".
        </t>

        <section title="No-Encryption Association Sessions"
                 toc="exclude">
          <t>
            In a "no-encryption" association session, the OP sends
            the association MAC key in plain-text to the Relying Party.
            This makes it possible for an eavesdropper to intercept
            the key, and forge messages to this Relying Party.
            Therefore, "no-encryption" association sessions SHOULD NOT
            be used unless the messages are using transport layer
            encryption. See <xref target="preventing_eavesdropping" />
            for more information.
          </t>

          <t>
            The MAC key sent by the OP MUST be the length specified
            for the requested association type, as specified in <xref
            target="sign_algos" />.
          </t>

        </section>

        <section title="Diffie-Hellman Association Sessions"
                     anchor="dh_sessions" toc="exclude">
          <t>
            The "DH-SHA1" and DH-SHA256" association types use
            Diffie-Hellman Key Exchange to securely transmit the
            shared secret.
          </t>
          <t>
            The MAC key MUST be the same length as the output of H,
            the hash function - 160 bits (20 bytes) for DH-SHA1 or 256
            bits (32 bytes) for DH-SHA256, as well as the output of
            the signature algorithm of this association.
          </t>

          <t>
            The Relying Party specifies a modulus, p, and a generator,
            g. The Relying Party chooses a random private key xa and
            OpenID Provider chooses a random private key xb, both in
            the range [1 .. p-1]. The shared secret used to encrypt
            the MAC key is thus g ^ (xa * xb) mod p = (g ^ xa) ^ xb
            mod p = (g ^ xb) ^ xa mod p. For more information, see
            <xref target='RFC2631' />. For information on the
            selection of random values, see <xref target="RFC1750" />.
          </t>
        </section>
      </section>
    </section>

    <section title="Requesting Authentication"
             anchor="requesting_authentication">
      <t>
        Once the Relying Party has successfully performed discovery
        and (optionally) created an association with the discovered
        OP Endpoint URL, it can send an authentication request to the
        OP to obtain an assertion. An authentication request is an
        <xref target="indirect_comm">indirect request</xref>.
      </t>

      <section title="Request Parameters">
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  As specified in <xref target="http_encoding" />.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>
                  Value: "checkid_immediate" or "checkid_setup"
                </t>
                <t>
                  Note: If the Relying Party wishes the end user to be
                  able to interact with the OP, "checkid_setup"
                  should be used. An example of a situation where
                  interaction between the end user and the OP is not
                  desired is when the authentication request is
                  happening asynchronously in JavaScript.
                </t>
              </list>
            </t>

            <t>
              openid.claimed_id
              <list style='empty'>
                <t>
                  Value: (optional) The Claimed Identifier.
                  "openid.claimed_id" and "openid.identity" SHALL
                  be either both present or both absent.
                </t>
                <t>
                  Note: The Claimed Identifier is the same as the
                  OP-Local Identifier if a different OP-Local
                  Identifier is not supplied. If neither value is
                  present, the assertion is not about an identifier,
                  and will contain other information in its payload,
                  using <xref target="extensions">extensions</xref>.
                </t>
                <t>
                  It is RECOMMENDED that OPs accept XRI identifiers
                  with or without the "xri://" prefix, as specified
                  in the <xref target="normalization">Normalization
                  </xref> section.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The OP-Local Identifier.
                </t>
                <t>
                  Note: If this is set to the special value
                  "http://specs.openid.net/auth/2.0/identifier_select"
                  then the OP SHOULD choose an Identifier that belongs
                  to the end user. This parameter MAY be omitted if
                  the request is not about an identifier (for instance
                  if an extension is in use that makes the request
                  meaningful without it; see openid.claimed_id above).
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: (optional) A handle for an association
                  between the Relying Party and the OP that SHOULD be
                  used to sign the response.
                </t>
                <t>
                  Note: If no association handle is sent, the
                  transaction will take place in <xref target="check_auth">
                  Stateless Mode</xref>.
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: (optional) URL to which the OP SHOULD return
                  the User-Agent with the response indicating the
                  status of the request.
                </t>
                <t>
                  Note: If this value is not sent in the request it
                  signifies that the Relying Party does not wish
                  for the end user to be returned.
                </t>
                <t>
                  Note: The return_to URL MAY be used as a mechanism
                  for the Relying Party to attach context about the
                  authentication request to the authentication
                  response. This document does not define a mechanism
                  by which the RP can ensure that query parameters are
                  not modified by outside parties; such a mechanism
                  can be defined by the RP itself.
                </t>
              </list>
            </t>

            <t>
              openid.realm
              <list style='empty'>
                <t>
                  Value: (optional) URL pattern the OP SHOULD ask the
                  end user to trust. See <xref target="realms" />.
                  This value MUST be sent if openid.return_to is
                  omitted.
                </t>
                <t>
                  Default: return_to URL
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>

      <section title="Realms" anchor="realms">
        <t>
          A "realm" is a pattern that represents the part of URL-space
          for which an OpenID Authentication request is valid. A realm
          is designed to give the end user an indication of the scope
          of the authentication request. OPs SHOULD present the realm
          when requesting the end user's approval for an authentication
          request. The realm SHOULD be used by OPs to uniquely identify
          Relying Parties. For example, OPs MAY use the realm to allow
          the end user to automate approval of authentication requests.
        </t>

        <t>
          A realm pattern is a URL, with the following changes:
          <list style="symbols">
            <t>
              A realm MUST NOT contain a URI fragment
            </t>
            <t>
              A realm MAY contain a wild-card at the beginning of the
              URL authority section.  A wild-card consists of the
              characters "*." prepended to the DNS name in the
              authority section of the URL.
            </t>
          </list>
        </t>

        <t>
          A URL matches a realm if:

          <list style="symbols">
            <t>
              The URL scheme and port of the URL are identical to those
              in the realm.  See <xref target="RFC3986">RFC
              3986</xref>, section 3.1 for rules about URI matching.
            </t>

            <t>
              The URL's path is equal to or a sub-directory of the
              realm's path.
            </t>

            <t>
              Either:
              <list style="numbers">
                <t>
                  The realm's domain contains the wild-card characters
                  "*.", and the trailing part of the URL's domain is
                  identical to the part of the realm following the
                  "*." wildcard, or
                </t>
                <t>
                  The URL's domain is identical to the realm's domain
                </t>
              </list>
             </t>
          </list>

          When present, the "openid.return_to" URL MUST match the
          "openid.realm", or the OP MUST return an <xref
          target="indirect_error">indirect error response</xref>.
        </t>

        <t>
          It is RECOMMENDED that OPs protect their users from making
          assertions with overly-general realms, like http://*.com/ or
          http://*.co.uk/. Overly general realms can be dangerous when
          the realm is used for identifying a particular Relying
          Party. Whether a realm is overly-general is at the
          discretion of the OP.
        </t>
      </section>

      <section title="Immediate Requests">
        <t>
          When requesting authentication, the Relying Party MAY
          request that the OP not interact with the end user.  In
          this case the OP MUST respond immediately with either an
          assertion that authentication is successful, or a response
          indicating that the request cannot be completed without
          further user interaction.  This is accomplished by an
          authentication request with "openid.mode" set to
          "checkid_immediate".
        </t>
      </section>
    </section>

    <section title="Responding to Authentication Requests"
             anchor="responding_to_authentication">
      <t>
        When an authentication request comes from the User-Agent via
        <xref target="indirect_comm">indirect communication</xref>,
        the OP SHOULD determine that an authorized end user wishes to
        complete the authentication.  If an authorized end user wishes
        to complete the authentication, the OP SHOULD send a <xref
        target="positive_assertions">positive assertion</xref> to the
        Relying Party.
      </t>
      <t>
        Methods of identifying authorized end users and obtaining
        approval to return an OpenID Authentication assertion are
        beyond the scope of this specification.  See <xref
        target="rp_mitm_proxy" /> for OpenID Provider security
        considerations.
      </t>
      <t>
        If the relying party requested OP-driven identifier selection
        by setting "openid.identity" to
        "http://specs.openid.net/auth/2.0/identifier_select"
        and there are Identifiers for which the end user is authorized
        to issue authentication responses, the OP SHOULD allow the end
        user to choose which Identifier to use.
      </t>
      <t>
        If the Relying Party supplied an association handle with the
        authentication request, the OP SHOULD attempt to look up an
        association based on that handle.  If the association is
        missing or expired, the OP SHOULD send the
        "openid.invalidate_handle" parameter as part of the response
        with the value of the request's "openid.assoc_handle"
        parameter, and SHOULD proceed as if no association handle was
        specified.
      </t>
      <t>
        If no association handle is specified, the OP SHOULD use a
        private association for signing the response.  The OP MUST
        store this association and MUST respond to later requests to
        check the signature of the response via <xref
        target="check_auth">Direct Verification</xref>.
      </t>
      <t>
        If the "openid.return_to" value is omitted in the request, the
        Relying Party does not wish to receive an authentication
        assertion from the OP. This can be useful when using
        extensions to transfer data from the Relying Party to the OP.
      </t>

      <section title="Positive Assertions" anchor="positive_assertions">
        <t>
          Positive assertions are <xref target="indirect_comm">
          indirect responses</xref> with the following fields:
        </t>
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  As specified in <xref target="http_encoding" />.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>Value: "id_res"</t>
              </list>
            </t>

            <t>
              openid.op_endpoint
              <list style='empty'>
                <t>
                  The OP Endpoint URL.
                </t>
              </list>
            </t>

            <t>
              openid.claimed_id
              <list style='empty'>
                <t>
                  Value: (optional) The Claimed Identifier.
                  "openid.claimed_id" and "openid.identity" SHALL
                  be either both present or both absent.
                </t>
                <t>
                  Note: The end user MAY choose to use an OP-Local
                  Identifier as a Claimed Identifier.
                </t>
                <t>
                  Note: If neither Identifier is present in the assertion,
                  it is not about an identifier, and will contain
                  other information in its payload, using <xref
                  target="extensions">extensions</xref>.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The OP-Local Identifier
                </t>
                <t>
                  Note: Relying Parties SHOULD accept and verify
                  assertions about Identifiers for which they have not
                  requested authentication. OpenID Providers MAY
                  assist the end user in selecting the Claimed and
                  OP-Local Identifiers about which the assertion is
                  made.  The openid.identity field MAY be omitted if
                  an extension is in use that makes the response
                  meaningful without it (see openid.claimed_id above).
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: Verbatim copy of the return_to URL parameter
                  sent in the request.
                </t>
              </list>
            </t>

            <t>
              openid.response_nonce
              <list style='empty'>
                <t>
                  Value: A string 255 characters or less in length,
                  that MUST be unique to this particular successful
                  authentication response. The nonce MUST start with the
                  current time on the server, and MAY contain additional
                  ASCII characters in the range 33-126 inclusive
                  (printable non-whitespace characters), as necessary to
                  make each response unique. The date and time MUST be
                  formatted as specified in section 5.6 of
                  <xref target="RFC3339" />, with the following restrictions:

                  <list style="symbols">
                    <t>
                      All times must be in the UTC
                      timezone, indicated with a "Z".
                    </t>
                    <t>
                      No fractional seconds are allowed
                    </t>
                  </list>

                  For example: 2005-05-15T17:11:51ZUNIQUE
                </t>
              </list>
            </t>

            <t>
              openid.invalidate_handle
              <list style='empty'>
                <t>
                  Value: (optional) If the Relying Party sent an
                  invalid association handle with the request, it
                  SHOULD be included here.
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: The handle for the association that was used
                  to sign this assertion.
                </t>
              </list>
            </t>

            <t>
              openid.signed
              <list style='empty'>
                <t>
                  Value: Comma-separated list of signed fields.
                </t>
                <t>
                  Note: This entry consists of the fields without the
                  "openid." prefix that the signature covers. This
                  list MUST contain at least "op_endpoint",
                  "return_to" "response_nonce" and "assoc_handle", and
                  if present in the response, "claimed_id" and
                  "identity". Additional keys MAY be signed as part of
                  the message. See <xref
                  target="generating_signatures">Generating
                  Signatures</xref>.
                </t>
                <t>
                  For example,
                  "op_endpoint,identity,claimed_id,return_to,assoc_handle,response_nonce".
                </t>
              </list>
            </t>

            <t>
              openid.sig
              <list style='empty'>
                <t>
                  Value: Base 64 encoded signature calculated as
                  specified in <xref target="generating_signatures"/>.
                </t>
              </list>
            </t>

          </list>

        </t>
      </section>

      <section title="Negative Assertions" anchor="negative_assertions">
        <t>
          If the OP is unable to identify the end user or the end
          user does not or cannot approve the authentication request,
          the OP SHOULD send a negative assertion to the Relying
          Party as an <xref target="indirect_comm">indirect
          response</xref>.
        </t>

        <t>
          When receiving a negative assertion in response to a
          "checkid_immediate" mode request, Relying Parties SHOULD
          construct a new authentication request using "checkid_setup"
          mode. Details about how this differs from OpenID
          Authentication 1.1 can be found in <xref
          target="compat_mode" />.
        </t>

        <section title="In Response to Immediate Requests">
          <t>
            If the request was an immediate request, there is no chance
            for the end user to interact with pages on the OP to provide
            identifying credentials or approval of a request.
            A negative assertion of an immediate request takes the
            following form:
            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    As specified in <xref target="http_encoding" />.
                  </t>
                </list>
              </t>
              <t>
                openid.mode
                <list style='empty'>
                  <t>Value: "setup_needed"</t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="In Response to Non-Immediate Requests">
          <t>
            Since the OP may display pages to the end user and
            request credentials from the end user, a negative response
            to a request that is not immediate is definitive.  It
            takes the following form:

            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    As specified in <xref target="http_encoding" />.
                  </t>
                </list>
              </t>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "cancel"
                  </t>
                </list>
              </t>
            </list>
          </t>

          <t>
            Often, if the user does not wish to or cannot complete the
            authentication request, the OpenID authentication process
            will be aborted and the Relying Party will not get a
            cancel mode response (the end user may quit or press the
            back button in their User-Agent instead of continuing).
            If a RP receives the "cancel" response, authentication was
            unsuccessful and the RP MUST treat the end user as
            non-authenticated.
          </t>
        </section>
      </section>
    </section>

    <section title="Verifying Assertions" anchor="verification">
      <t>
        When the Relying Party receives a positive assertion, it MUST
        verify the following before accepting the assertion:

        <list style="symbols">
          <t>
            The value of "openid.return_to" matches the URL of the
            current request (<xref target="verify_return_to" />)
          </t>
          <t>
            Discovered information matches the information in the
            assertion (<xref target="verify_disco" />)
          </t>
          <t>
            An assertion has not yet been accepted from this OP with
            the same value for "openid.response_nonce" (<xref
            target="verify_nonce" />)
          </t>
          <t>
            The signature on the assertion is valid and all fields
            that are required to be signed are signed (<xref
            target="verifying_signatures" />)
          </t>
        </list>

        If all four of these conditions are met, assertion is now
        verified. If the assertion contained a Claimed Identifier, the
        user is now authenticated with that identifier.
      </t>

      <section title="Verifying the Return URL" anchor="verify_return_to">
        <t>
          To verify that the "openid.return_to" URL matches the URL
          that is processing this assertion:

          <list style="symbols">
            <t>
              The URL scheme, authority, and path MUST be the same
              between the two URLs.
            </t>
            <t>
              Any query parameters that are present in the
              "openid.return_to" URL MUST also be present with the
              same values in the URL of the HTTP request the RP
              received.
            </t>
          </list>
        </t>
      </section>

      <section title="Verifying Discovered Information" anchor="verify_disco">
        <t>
          If the Claimed Identifier is included in the assertion, it
          MUST have been <xref target="discovery">discovered</xref> by
          the Relying Party and the information in the assertion MUST
          be present in the discovered information. The Claimed
          Identifier MUST NOT be an OP Identifier.
        </t>

        <t>
          If the Claimed Identifier was not present in the request
          ("openid.identity" was
          "http://specs.openid.net/auth/2.0/identifier_select"), the
          Relying Party MUST perform discovery on the Claimed
          Identifier in the response to make sure that the OP is
          authorized to make assertions about the Claimed Identifier.
        </t>

        <t>
          If no Claimed Identifier is present in the response, the
          assertion is not about an identifier and the RP MUST NOT use
          the User-supplied Identifier associated with the current
          OpenID authentication transaction to identify the user.
          Extension information in the assertion MAY still be used.
        </t>

        <texttable title="Discovered Information to Authentication Response Mapping">
          <ttcol align='left'>Discovered Value</ttcol>
          <ttcol align='left'>Response Field</ttcol>

          <c>Claimed Identifier</c>
          <c>openid.claimed_id</c>

          <c>OP-Local Identifier</c>
          <c>openid.identity</c>

          <c>OP Endpoint URL</c>
          <c>openid.op_endpoint</c>

          <c>Protocol Version</c>
          <c>openid.ns</c>
          <postamble>
            This table shows the mapping of <xref
            target="discovered_info">discovered information</xref>
            into fields in the <xref
            target="positive_assertions">OpenID Authentication 2.0
            "id_res" response</xref>
          </postamble>
        </texttable>

        <t>
          If using a discovery mechanism that yields an XRDS document,
          the protocol version, OP Endpoint URL and the OP-Local
          Identifier (if different than the Claimed Identifier) MUST
          be present in one &lt;xrd:Service&gt; element. There MAY be
          unused fields in that &lt;xrd:Service&gt; element.
        </t>

        <figure>
          <preamble>Non-normative example:</preamble>
          <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://specs.openid.net/auth/2.0/signon</Type>
  <URI>http://provider.example.com/openid</URI>
  <URI>https://provider.example.com/openid</URI>
</Service>
]]></artwork>
          <postamble>
            In this example XRDS snippet, the &lt;xrd:Service&gt;
            element has two &lt;xrd:URI&gt; elements, which map to OP
            Endpoint URLs as per <xref target="discovered_info" />. If
            an assertion has either value for "openid.op_endpoint",
            then that field matches this &lt;xrd:Service&gt;
            element. The other &lt;xrd:URI&gt; element is unused.
          </postamble>
        </figure>

      </section>

      <section title="Checking the Nonce" anchor="verify_nonce">
        <t>
          To prevent replay attacks, the agent checking the signature
          keeps track of the nonce values included in positive
          assertions and never accepts the same value more than once
          for the same OP Endpoint URL.
        </t>
        <t>
          <list style="symbols">
            <t>
              When using "check_authentication", the OP MUST NOT issue
              more than one successful response to a request with the
              same value for "openid.response_nonce".
            </t>
            <t>
              When the Relying Party checks the signature on an
              assertion, the Relying Party SHOULD ensure that an
              assertion has not yet been accepted with the same value
              for "openid.response_nonce" from the same OP Endpoint
              URL.
            </t>
          </list>
        </t>
        <t>
          The time-stamp MAY be used to reject responses that are too
          far away from the current time, limiting the amount of time
          that nonces must be stored to prevent attacks. The
          acceptable range is out of the scope of this
          specification. A larger range requires storing more nonces
          for a longer time. A shorter range increases the chance that
          clock-skew and transaction time will cause a spurious
          rejection.
        </t>
      </section>

      <section title="Verifying Signatures"
               anchor="verifying_signatures">
        <t>
          If the Relying Party has stored an association with the
          association handle specified in the assertion, it MUST check
          the signature on the assertion itself. If it does not have
          an association stored, it MUST request that the OP verify
          the signature via <xref target="check_auth">Direct
          Verification</xref>.
        </t>

        <section title="Verifying with an Association" toc="exclude">
          <t>
            The Relying Party follows the same procedure that the
            OP followed in <xref target= "generating_signatures">
            generating the signature</xref>, and then compares the
            signature in the response to the signature it
            generated. If the signatures do not match, the assertion
            is invalid.
          </t>

          <t>
            If an authentication request included an association
            handle for an association between the OP and the Relying
            party, and the OP no longer wishes to use that handle
            (because it has expired or the secret has been
            compromised, for instance), the OP will send a response
            that must be verified directly with the OP, as specified
            in <xref target="check_auth" />. In that instance, the OP
            will include the field "openid.invalidate_handle" set to
            the association handle that the Relying Party included
            with the original request.
          </t>
        </section>

        <section title="Verifying Directly with the OpenID Provider"
                 toc="exclude" anchor="check_auth">
          <t>
            To have the signature verification performed by the OP,
            the Relying Party sends a <xref target="direct_request">
            direct request</xref> to the OP. To verify the signature,
            the OP uses a private association that was generated when
            it issued the <xref target="positive_assertions">
            positive assertion</xref>.
          </t>

          <section title='Request Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  openid.mode
                  <list style='empty'>
                    <t>Value: "check_authentication"</t>
                   </list>
                </t>

                <t>
                  Exact copies of all fields from the authentication
                  response, except for "openid.mode".
                </t>
              </list>
            </t>

            <t>
              For verifying signatures an OP MUST only use private
              associations and MUST NOT use associations that have
              shared keys. If the verification request contains a
              handle for a shared association, it means the Relying
              Party no longer knows the shared secret, or an entity
              other than the RP (e.g. an attacker) has established
              this association with the OP.
            </t>

            <t>
              To prevent replay attacks, the OP MUST NOT issue more
              than one verification response for each authentication
              response it had previously issued. An authentication
              response and its matching verification request may
              be identified by their "openid.response_nonce" values.
            </t>

          </section>

          <section title='Response Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  ns
                  <list style='empty'>
                    <t>
                      As specified in <xref target="direct_response" />.
                    </t>
                  </list>
                </t>

                <t>
                  is_valid
                  <list style='empty'>
                    <t>
                      Value: "true" or "false"; asserts whether the
                      signature of the verification request is valid.
                    </t>
                  </list>
                </t>

                <t>
                  invalidate_handle
                  <list style='empty'>
                    <t>
                      Value: (optional) The "invalidate_handle" value
                      sent in the verification request, if the OP confirms
                      it is invalid.
                    </t>
                    <t>
                      Description: If present in a verification response
                      with "is_valid" set to "true", the Relying Party
                      SHOULD remove the corresponding association from its
                      store and SHOULD NOT send further authentication
                      requests with this handle.
                    </t>
                    <t>
                      Note: This two-step process for invalidating
                      associations is necessary to prevent an attacker
                      from invalidating an association at will by adding
                      "invalidate_handle" parameters to an authentication
                      response.
                    </t>
                  </list>
                </t>
              </list>
            </t>
          </section>
        </section>
      </section>

      <section title="Identifying the end user" anchor="identifying">
        <t>
          The Claimed Identifier in a successful authentication
          response MAY be used as a user-visible Identifier. The
          Relying Party SHOULD use it as a key for local storage of
          information about the end user.
        </t>

        <section title="HTTP and HTTPS URL Identifiers" anchor="http_s_identifiers">
          <t>
            Relying Parties MUST differentiate between URL Identifiers
            that have different schemes. When end user input is
            processed into a URL, it is processed into a HTTP URL. If
            the same end user controls the same URL, differing only by
            scheme, and it is desired that the Identifier be the HTTPS
            URL, it is RECOMMENDED that a redirect be issued from the
            HTTP URL to the HTTPS URL. Because the HTTP and HTTPS URLs
            are not equivalent and the Identifier that is used is the
            URL after following redirects, there is no forseen
            reduction in security when using this scheme. If an
            attacker could gain control of the HTTP URL, it would have
            no effect on the HTTPS URL, since the HTTP URL is not ever
            used as an Identifier except to initiate the discovery
            process.
          </t>
        </section>
      </section>
    </section>

    <section title="Extensions" anchor="extensions">
      <t>
        An Extension to OpenID Authentication is a protocol that
        "piggybacks" on the authentication request and response. Extensions
        are useful for providing extra information about an
        authentication request or response as well as providing extra
        information about the subject of the authentication response.
      </t>

      <t>
        OpenID extensions are identified by a Type URI. The Type URI
        MAY be used as the value of an &lt;xrd:Type&gt; element of an
        OpenID &lt;xrd:Service&gt; element in an XRDS document
        associated with a Claimed Identifier.  The Type URI is also
        used to associate key-value pairs in messages with the extension.
      </t>

      <t>
        <!-- XXX: openid. only for indirect messages -->
        To associate keys and values in a message with an extension,
        the key MUST be associated with the Type URI. To associate
        keys with a Type URI, establish an alias by adding a key
        prefixed with "openid.ns." and ending with the alias text
        whose value is the Type URI. Once an alias has been
        established, all pairs in the message whose keys start with
        "openid." followed by the alias text, followed by a period or
        the end of the key are associated with that extension.
      </t>

      <t>
        A namespace alias MUST NOT contain a period and MUST NOT be
        the same as another namespace alias in the same message. A
        namespace alias also MUST NOT be in the following list of
        disallowed aliases:

        <list style="symbols">
          <t>assoc_handle</t>
          <t>assoc_type</t>
          <t>claimed_id</t>
          <t>contact</t>
          <t>delegate</t>
          <t>dh_consumer_public</t>
          <t>dh_gen</t>
          <t>dh_modulus</t>
          <t>error</t>
          <t>identity</t>
          <t>invalidate_handle</t>
          <t>mode</t>
          <t>ns</t>
          <t>op_endpoint</t>
          <t>openid</t>
          <t>realm</t>
          <t>reference</t>
          <t>response_nonce</t>
          <t>return_to</t>
          <t>server</t>
          <t>session_type</t>
          <t>sig</t>
          <t>signed</t>
          <t>trust_root</t>
        </list>

        A namespace MUST NOT be assigned more than one alias in the
        same message. If a message is a response to another message,
        the response MAY use a different alias to refer to the same
        namespace.
      </t>

      <t>Non-normative example:</t>
      <t>An extension's type URI is
      "&lt;http://example.com/ext/1.0&gt;".

      <list style="empty">
        <t>openid.ns.x=http://example.com/ext/1.0</t>
        <t>openid.x=example</t>
        <t>openid.x.foo=bar</t>
        <t>openid.xx=notx</t>
      </list>

        In this example, the keys "openid.x" and "openid.x.foo" are
        associated with the extension; the "openid.xx" key is not.
      </t>

      <t>
        Extensions MUST NOT define multiple parameters with the same name.
        Extensions that need to send multiple values for the same parameter
        name must define their own conventions for doing so.
      </t>
    </section>

    <section title="Discovering OpenID Relying Parties">
      <t>
        Relying Parties are RECOMMENDED to use the Yadis protocol to
        publish their return_to URL. This allows for automated
        discovery of OpenID Relying Parties.
      </t>

      <t>
        A Relying Party discovery XRDS document MUST contain an
        &lt;xrd:Service&gt; element:

        <list style="symbols">
          <t>
            Containing at least one &lt;xrd:URI&gt; element.
          </t>
          <t>
            Where all &lt;xrd:URI&gt; tags contain a URL that accepts
            OpenID 2.0 Authentication responses.
          </t>
          <t>
            Containing a &lt;xrd:Type&gt; tag whose content is
            "http://specs.openid.net/auth/2.0/return_to".
          </t>
        </list>
      </t>

      <figure>
        <preamble>Non-normative example:</preamble>
        <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://specs.openid.net/auth/2.0/return_to</Type>
  <URI>http://consumer.example.com/return</URI>
</Service>
]]></artwork>
      </figure>
    </section>

    <section title="OpenID Authentication 1.1 Compatibility"
             anchor="compat_mode">

      <t>
        This section describes how to interact with OpenID
        Authentication 1.1 Relying Parties and OPs. OpenID
        Authentication 2.0 implementations SHOULD support OpenID
        Authentication 1.1 compatibility, unless security
        considerations make it undesirable.
      </t>

      <section title="Changes from OpenID Authentication 1.1" >
        <t>
          (non-normative)
        </t>
        <t>
          This specification is based on the original specification for
          OpenID Authentication as written by Brad Fitzpatrick. That
          specification did not have a version number, but was called
          OpenID 1.0, and then OpenID 1.1 when it was revised.  The
          protocol outlined in this specification is intended to be
          backwards-compatible with the revised OpenID protocol.  The
          changes to the specification are outlined in this section.
        </t>

        <section title="Updated Initiation and Discovery">
          <t>
            <list style="symbols">
              <t>
                Supports OP Identifiers. This new variation of the
                protocol flow is initiated by an end user entering an OP
                Identifier instead of their own Identifier.  This allows
                the OP to assist the end user in selecting an
                Identifier.
              </t>
              <t>
                Supports the use of XRIs as Identifiers. XRIs may be
                used as Identifiers for both end users and OPs, and
                provide automatic mapping from one or more reassignable
                i-names to a synonymous persistent Canonical ID that
                will never be reassigned.
              </t>
              <t>
                When URLs are used as Identifiers, they are normalized
                according to the guidelines in <xref target='RFC3986' />,
                for better compatibility with the existing Web infrastructure.
              </t>
              <t>
                Uses the Yadis protocol for discovery. This allows for
                using multiple OPs for a single Identifier, for
                load-balancing and fallback in the case of OP
                failure. Additionally, it allows for discovery of
                supported extensions and other associated services.
              </t>
            </list>
          </t>
        </section>

        <section title="Security improvements">
          <t>
            A nonce is now part of the protocol for built-in protection
            against replay attacks, which was previously implemented
            out-of-band by each library or application.
          </t>
          <t>
            A new association type, HMAC-SHA256, and a new association
            session type, DH-SHA256, allow for stronger signatures on
            authentication assertions.
          </t>
          <t>
            An actual <xref target="security_considerations">Security
            Considerations section</xref> which looks at protecting
            the protocol from end-to-end.
          </t>
        </section>

        <section title="Extensions">
          <t>
            Extensions are now an officially supported mechanism to
            support data exchange and other Relying Party-OP
            communication along with the authentication
            exchange. Extensions allow for the exchange of arbitrary
            attributes, as well as for protocol extensions,
            such as the inclusion of additional information about the
            Relying Party in the authentication request.
          </t>
          <t>
            Because extensions can transfer arbitrary data, the
            Identifier is now optional in authentication messages.
          </t>
        </section>
      </section>

      <section title="Implementing OpenID Authentication 1.1 Compatibility">
        <t>
          All messages in OpenID Authentication 1.1 omit the
          "openid.ns" parameter, which is an easy way for an RP to
          determine if the message is from an OpenID Authentication
          1.1 endpoint. OpenID Authentication 1.1 supports only
          HMAC-SHA1 associations.
        </t>

        <t>
          Error responses in OpenID Authentication 1.1 did not define
          "contact" or "reference". OpenID Authentication 1.1 did
          allow for the addition of extra fields in error
          responses. It is RECOMMENDED for contact and reference to be
          sent even when using OpenID Authentication 1.1, since they
          may be useful for debugging and do not affect compatibility.
        </t>

        <section title="Relying Parties">
          <t>
            <list style="symbols">
              <t>
                When HTML discovery is performed, the OP endpoint URL
                is marked by the link relationship "openid.server"
                rather than "openid2.provider". The end user's
                OP-Local Identifier is marked by the link relationship
                "openid.delegate" rather than "openid2.local_id".  The
                protocol version is in this case
                "http://openid.net/signon/1.1". HTML allows multiple
                link relationships to be specified for a single link,
                so if an OP provides both OpenID Authentication 1.1
                and OpenID Authentication 2.0, "openid2.provider" and
                "openid.server" may appear in the same "rel"
                attribute.
              </t>

              <t>
                When XRDS-based discovery is performed, the end user's
                OP-Local Identifier appears in the
                &lt;openid:Delegate&gt; tag of the OpenID
                &lt;xrd:Service&gt; element rather than in the
                &lt;xrd:LocalID&gt; tag. In order to support
                currently-deployed discovery code, both tags MAY
                appear in the &lt;xrd:Service&gt; element.
              </t>

              <t>
                Relying Parties SHOULD extract and use OpenID
                Authentication 1.x service elements from XRDS
                documents, if Yadis succeeds on an URL
                identifier. Such service elements are identified by
                &lt;xrd:Type&gt; tags whose text contents are
                "http://openid.net/server/1.0" or
                "http://openid.net/server/1.1".  Although this is not
                specified in the previous version of the protocol, it
                is a generally accepted practice of advertising OpenID
                Authentication 1.x services through Yadis.
              </t>

              <t>
                "openid.claimed_id" is not defined by OpenID
                Authentication 1.1. Relying Parties MAY send the value
                when making requests, but MUST NOT depend on the value
                being present in authentication responses. When the
                OP-Local Identifier ("openid.identity") is
                different from the Claimed Identifier, the Relying
                Party MUST keep track of what Claimed Identifier was
                used to discover the OP-Local Identifier, for
                example by keeping it in session state. Although the
                Claimed Identifier will not be present in the
                response, it MUST be used as the identifier for the
                user.
              </t>

              <t>
                "openid.identity" MUST be sent in a <xref
                    target="responding_to_authentication">authentication
                request</xref>.
              </t>

              <t>
                Relying Parties MUST send a blank session_type parameter
                in "no-encryption" association requests.
              </t>

              <t>
                In OpenID Authentication 1.1, the "no-encryption"
                association session type is represented by a blank or
                missing "openid.session_type" parameter. Relying
                Parties MUST NOT send requests with
                "openid.session_type" set to "no-encryption".
              </t>

              <t>
                In <xref
                target="requesting_authentication">authentication
                requests</xref>, the "openid.identity" parameter
                SHOULD NOT be the special value
                "http://specs.openid.net/auth/2.0/identifier_select",
                because OpenID Authentication 1.1 does not support the
                use of OP Identifiers.
              </t>

              <t>
                The "openid.realm" parameter in authentication requests
                was known as "openid.trust_root". The syntax and meaning
                are identical.
              </t>

              <t>
                When responding with a negative assertion to a
                "checkid_immediate" mode authentication request, the
                "user_setup_url" parameter MUST be returned. This is a
                URL that the end user may visit to complete the
                request. The OP MAY redirect the end user to
                this URL, or provide the end user with a link that
                points to this URL.
              </t>

              <t>
                The Relying Party MUST accept an <xref
                target="positive_assertions">authentication
                response</xref> that is missing the
                "openid.response_nonce" parameter.  It SHOULD
                implement a method for preventing replay attacks.
              </t>

              <t>
                Relying Parties MUST accept
                <xref target="positive_assertions">authentication responses
                </xref> that are missing the "openid.op_endpoint" parameter.
              </t>
            </list>
          </t>
        </section>

        <section title="OpenID Providers">
          <t>
            <list style="symbols">
              <t>
                "openid.identity" MUST be sent in a <xref
                    target="positive_assertions">positive authentication
                assertion</xref>.
              </t>

              <t>
                In OpenID Authentication 1.1, the "no-encryption"
                association session type is represented by a blank or
                missing "openid.session_type" parameter.  OPs MUST NOT
                send responses with "openid.session_type" set to
                "no-encryption".
              </t>

              <t>
                OPs MAY choose to return a successful "no-encryption"
                response to any association request. As above, the
                "openid.session_type" parameter MUST be blank or
                omitted from the response.
              </t>

              <t>
                OPs MUST accept association requests with no assoc_type
                parameter, and assume them to be of type HMAC-SHA1.
              </t>

              <t>
                Unsuccessful association attempts MAY be responded with
                direct error messages or with "no-encryption" positive
                association responses.
              </t>

              <t>
                The "openid.realm" parameter in authentication requests
                was known as "openid.trust_root". The syntax and meaning
                are identical.
              </t>

              <t>
                When responding with a negative assertion to a
                "checkid_immediate" mode authentication request, the
                "user_setup_url" parameter MUST be returned. This is a URL
                that the end user may visit to complete the request. The
                Relying Party may redirect the end user to this URL, or
                provide the end user with a link that points to this
                URL.
              </t>

              <t>
                OPs MUST NOT send the "openid.op_endpoint" parameter in
                <xref target="positive_assertions">authentication responses
                </xref>, since it is not part of the OpenID Authentication
                1.1 protocol.
              </t>
            </list>
          </t>
        </section>
      </section>
    </section>

    <section title="Security Considerations" anchor="security_considerations">
      <section title="Preventing Attacks">
        <section title="Eavesdropping Attacks"
                 anchor="preventing_eavesdropping">
          <t>
            There are two places in this protocol that are vulnerable
            to eavesdropping attacks.
            <list style="symbols">
              <t>
                An eavesdropper could intercept an unencrypted association
                session and recover the shared secret, allowing an attacker
                to masquerade as the OP to that relying party.
              </t>
              <t>
                If the nonce were not checked, an eavesdropper could also
                intercept a successful authentication assertion and re-use it.
              </t>
            </list>
          </t>

          <t>
            Both of these attacks can be prevented by using SSL for
            these connections. The association session can also use
            Diffie-Hellman Key Exchange instead of "no-encryption" to
            protect from eavesdropping. If the nonce is checked in
            message verification, the positive authentication
            assertion cannot be re-used.
          </t>
        </section>

        <section title="Man-in-the-Middle Attacks">
          <t>
            Associations prevent tampering of signed fields by a man
            in the middle except during discovery, association
            sessions and <xref target="check_auth">Direct
            Verification</xref>. Altering signed fields without the
            shared secret requires breaking the MAC. Currently no
            tractable attack is known on the MACs used in this
            protocol. The quality of the protection provided by the
            MAC depends on the randomness of the shared MAC key, so it
            is important that an unguessable value be used.
          </t>

          <t>
            If DNS resolution or the transport layer is compromised
            signatures on messages are not adequate, since the
            attacker can impersonate the OP and issue its own
            associations, or its own decisions in Stateless Mode. If
            an attacker can tamper with the discovery process they can
            specify any OP, and so does not have to impersonate the
            OP.  Additionally, if an attacker can compromise the
            integrity of the information returned during the discovery
            process, by altering the XRDS document, the need for a man
            in the middle is removed.  One method to prevent this sort
            of attack is by digitally signing the XRDS file as per
            <xref target="RFC3275">XMLDSIG</xref>. The keying material
            is not specified, since the RP ultimately needs to make
            its own decision whether to trust keys used for such
            signature.
          </t>

          <t>
            Using SSL with certificates signed by a trusted authority
            prevents these kinds of attacks by verifying the results
            of the DNS look-up against the certificate. Once the
            validity of the certificate has been established,
            tampering is not possible. Impersonating an SSL server
            requires forging or stealing a certificate, which is
            significantly harder than the network based attacks.
          </t>

          <t>
            In order to get protection from SSL, SSL must be used for
            all parts of the interaction, including interaction with
            the end user through the User-Agent.  While the protocol
            does not require SSL be used, its use is strongly
            RECOMMENDED.  Current best practices dictate that an OP
            SHOULD use SSL, with a certificate signed by a trusted
            authority, to secure its Endpoint URL as well as the
            interactions with the end user's User-Agent.  In addition,
            SSL, with a certificate signed by a trusted authority,
            SHOULD be used so that a Relying Party can fetch the end
            user's URL in a secure manner.  Following its own security
            policies, a Relying Party MAY choose to not complete, or
            even begin, a transaction if SSL is not being correctly
            used at these various endpoints.
          </t>

          <section title="Rogue Relying Party Proxying" anchor="rp_mitm_proxy">
            <t>
              A special type of man-in-the-middle attack is one where
              the Relying Party is a rogue party acting as a MITM.  The
              RP would perform discovery on the End User's Claimed
              Identifier and instead of redirecting the User Agent to
              the OP, would instead proxy the OP through itself.  This
              would thus allow the RP to capture credentials the End
              User provides to the OP.  While there are multiple ways to
              prevent this sort of attack, the specifics are outside the
              scope of this document.  Each method of prevention
              requires that the OP establish a secure channel with the
              End User.
            </t>
          </section>
        </section>
      </section>

      <section title="User-Agents">
        <t>
          Since this protocol is intended to be used interactively,
          User-Agents will primarily be common Web browsers. Web
          browsers or their hosts may be infected with spyware or
          other malware, which limits the strength of the
          authentication assertion, since untrusted software makes it
          impossible to know whether the authentication decision has
          been made with the end user's approval. With that said, many
          web applications and protocols today rely on the security of
          the Web browser and their hosts.
        </t>

        <t>
          Cross-site-scripting attacks against OPs may be used to the
          same effect. For the best security, OPs should not depend
          on scripting.  This enables User-Agents that do not support
          scripting, or have scripting disabled, to still employ the
          protocol.
        </t>
      </section>

      <section title="User Interface Considerations">
        <t>
          The Relying Party SHOULD redirect the end user to the OP
          Endpoint URL in a top-level browser window with all controls
          visible. This allows better protection for the end user
          against OP look-alike sites (phishing).
        </t>

        <t>
          OpenID Providers SHOULD educate their end users about the
          potential for OpenID phishing attacks and SHOULD equip their
          end users with the tools to defeat such attacks, for example
          browser plug-ins that verify the authenticity of the OP's
          Authentication Service Endpoint URL.
        </t>
      </section>

      <section title="HTTP and HTTPS URL Identifiers">
        <t>
          While these types of Identifiers have been <xref
          target='http_s_identifiers'>previously discussed</xref>,
          they are worth mentioning again.  As previously stated, the
          RECOMMENDED method of an End User expressing control over a
          URL differing only be scheme is to setup a redirect from the
          HTTP URL to the HTTPS URL.  Relying Parties will never store
          the HTTP URL as during the discovery and initiation phase
          will follow the redirect and use the HTTPS URL as the
          Claimed Identifier.
        </t>

        <t>
          End users with concerns over this recommendation should
          directly enter their HTTPS URL at each Relying Party.  This
          thus removes the step where the Relying Party follows the
          redirect to the HTTPS URL.  The single security
          consideration currently seen is if an attacker were to
          compromise the integrity of the HTTP URL by removing the
          redirect and pointing the Identifier at a rogue OP.  This
          however will alter the user experience, is detectable by
          anti-phishing technologies, and the security of the
          Identifier itself is a fundamental principle within OpenID.
        </t>
      </section>

      <section title="Denial of Service Attacks">
        <t>
          Within the protocol there are places where a rogue RP could
          launch a denial of service attack against an OP since there
          is nothing in OpenID protocol messages that allows the OP to
          quickly check that it is a genuine request.  This can be
          done by the RP repeatedly requesting associations,
          authentication, or verification of a signature.
        </t>

        <t>
          The potentially most severe attack is during the association
          phase as each message requires the OP to execute a discrete
          exponentiation.  Since the RP has the ability to specify
          modulus and generator per message, an attacker can even
          force the OP to perform this exponentiation in real time
          prior to responding for each message.
        </t>

        <t>
          While this could be particularly harmful, OpenID Providers
          can easily use generic IP based rate-limiting and banning
          techniques to help combat these sorts of attacks.  OPs can
          also look at banning requests based on the "openid.realm"
          and "openid.return_to" values.
        </t>
      </section>

      <section title="Protocol Variants">
        <t>
          The following are known variations in the protocol which may
          or may not directly affect the security of the use of the
          protocol.  It is imagined that these values could be used in
          the creation of security profiles for this protocol.  The
          following list of variants are from the perspective of an
          OpenID Provider.
        </t>

        <texttable>
          <ttcol align='left'>Number</ttcol>
          <ttcol align='left'>Variant</ttcol>
          <ttcol align='left'>Values</ttcol>

          <c>1.</c>
          <c>
            Are wildcards allowed in realms?
          </c>
          <c>
            One of Yes/No
          </c>

          <c>2.</c>
          <c>
            Require prior association?  Does the OP require the RP
            first create an association before requesting
            authentication?
          </c>
          <c>
            One of Yes/No
          </c>

          <c>3.</c>
          <c>
            Types of claimed identifiers accepted.
          </c>
          <c>
            Set of HTTP/HTTPS/XRI
          </c>

          <c>4.</c>
          <c>
            Are self-issued certificates allowed for authentication?
            This applies to all SSL traffic. If 'no' here, then OP
            *probably* requires all HTTPS identifiers to chain up to
            known trust roots, but that's intentionally not implied.
          </c>
          <c>
            One of Yes/No
          </c>

          <c>5.</c>
          <c>
            Must the XRDS file be signed? Signature on the XRDS as per
            XMLDSIG. Keying material not specified, since the RP
            ultimately needs to make own decision whether to trust
            keys used for such signature.
          </c>
          <c>
            One of Yes/No
          </c>

          <c>6.</c>
          <c>
            Must the XRDS file be retrieved over secure channel? This does not
            imply SSL?
          </c>
          <c>
            One of Yes/No
          </c>

          <c>7.</c>
          <c>
            What types of session types can be used when creating
            associations?
          </c>
          <c>
            Set of no-encryption/DH-SHA1/DH-SHA256
          </c>

          <c>8.</c>
          <c>
            Must the RP have an XRDS document?
          </c>
          <c>
            One of Yes/No
          </c>

          <c>9.</c>
          <c>
            What association types the OP agrees to use for
            signatures?
          </c>
          <c>
            Set of HMAC-SHA1/HMAC-SHA256
          </c>

          <c>10.</c>
          <c>
            Must the association request take place over secure channel?
          </c>
          <c>
            One of Yes/No
          </c>

          <postamble>
            Identified security variants.
          </postamble>
          </texttable>
      </section>
    </section>

    <appendix title="Examples">
      <t>Non-normative</t>

      <appendix title="Normalization" anchor="normalization_example">
          <texttable title="User's Input to Identifier Normalization">
            <ttcol align="left">User's Input</ttcol>
            <ttcol align="left">Identifier</ttcol>
            <ttcol align="left">Type</ttcol>

            <c>=example1</c>
            <c>=example1</c>
            <c>XRI</c>

            <c>xri://=example2</c>
            <c>=example2</c>
            <c>XRI</c>

            <c>xri://$dns*example3.com</c>
            <c>http://example3.com</c>
            <c>URL</c>

            <c>xri://$ip*1.2.3.4</c>
            <c>http://1.2.3.4</c>
            <c>URL</c>

            <c>http://example4.com/</c>
            <c>http://example4.com/</c>
            <c>URL</c>

            <c>https://example5.com/</c>
            <c>https://example5.com/</c>
            <c>URL</c>

            <c>example6.com</c>
            <c>http://example6.com</c>
            <c>URL</c>
          </texttable>
      </appendix>

      <appendix title="OP-Local Identifiers">
        <t>
          An end user wants to use "http://www.example.com/" as their
          Claimed Identifier. The end user has an account with
          Example Provider, which functions as an OpenID Provider.  The
          end user's OP-Local Identifier is
          "https://exampleuser.exampleprovider.com/".
        </t>

        <t>
          In this scenario, with the proper configuration of Yadis or
          HTML-Based Discovery (see <xref target="discovery" /> and
          <xref target="XRDS_Sample" /> below), a Relying Party will
          discover the following information about the end user:

          <list style="hanging">
            <t hangText="Claimed Identifier">
              http://www.example.com/
            </t>
            <t hangText="OP-Local Identifier">
              https://exampleuser.exampleprovider.com/
            </t>
          </list>
        </t>
      </appendix>

      <appendix title="XRDS" anchor="XRDS_Sample">
        <figure>
          <preamble>
            For an end user to use "http://www.example.com/" as
            their Identifier, but have Relying Parties actually
            verify "https://exampleuser.exampleprovider.com/" with the OP
            Endpoint URL
            "https://www.exampleprovider.com/endpoint/", the
            following XML snippet should be present in the final XRD
            element in the XRDS file when discovery is preformed on
            "http://www.example.com/":
          </preamble>
          <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://specs.openid.net/auth/2.0/signon</Type>
  <URI>https://www.exampleprovider.com/endpoint/</URI>
  <LocalID>https://exampleuser.exampleprovider.com/</LocalID>
</Service>
]]></artwork>
        </figure>
      </appendix>

      <appendix title="HTML Identifier Markup">
        <figure>
          <preamble>
            To use "http://www.example.com/" as their Identifier, but have
            Relying Parties actually verify
            "http://exampleuser.livejournal.com/" with the OpenID
            Provider located at
            "http://www.livejournal.com/openid/server.bml", the
            following markup should be present in the &lt;head&gt;
            of the HTML document located by the identifier URL:
          </preamble>
          <artwork><![CDATA[
<link rel="openid2.provider openid.server"
      href="http://www.livejournal.com/openid/server.bml"/>
<link rel="openid2.local_id openid.delegate"
      href="http://exampleuser.livejournal.com/"/>
]]></artwork>
        </figure>
      </appendix>

      <appendix title="XRI CanonicalID">
        <t>
          For example, if the XRI i-names =example and =exmpl both
          yield an XRDS document with the CanonicalID
          xri://(example)!1234 then those Identifiers should be
          treated as equivalent. For applications with user accounts,
          the persistent Canonical ID xri://(example)!1234 should be
          used the the primary key for the account.  Although the
          i-names =example and =exmpl may also be stored for reference
          as display names, they are reassignable identifiers and
          should not be used as persistent keys.
        </t>
      </appendix>
    </appendix>

    <appendix title='Diffie-Hellman Key Exchange Default Value' anchor="pvalue">
      <figure>
        <preamble>
          This is a confirmed-prime number, used as the default
          modulus for Diffie-Hellman Key Exchange. In hexadecimal:
        </preamble>
        <artwork>
DCF93A0B883972EC0E19989AC5A2CE310E1D37717E8D9571BB7623731866E61E
F75A2E27898B057F9891C2E27A639C3F29B60814581CD3B2CA3986D268370557
7D45C2E7E52DC81C7A171876E5CEA74B1448BFDFAF18828EFD2519F14E45E382
6634AF1949E5B535CC829A483B8A76223E5D490A257F05BDFF16F2FB22C583AB
        </artwork>
      </figure>
    </appendix>

    <!-- XXX: An example for Generating Signatures might be nice. -->

    <appendix title="Acknowledgements">
      <t>
        The OpenID Community would like to thank the following people
        for the work they've done in the drafting and editing of this
        specification.  If you want to know the nitty gritty of who
        actually wrote what, feel free to look at our SVN repository
        or even use "svn blame". :)
        http://openid.net/svn/specifications/authentication/2.0/
      </t>

      <t>
      <list style='empty'>
        <t>Barry Ferg (barry@sxip.com)</t>
        <t>Brad Fitzpatrick (bradfitz@sixapart.com)</t>
        <t>Carl Howells (chowells@janrain.com)</t>
        <t>David Recordon (drecordon@verisign.com) &lt;editor&gt;</t>
        <t>Dick Hardt (dick@sxip.com)</t>
        <t>Drummond Reed (drummond.reed@cordance.net)</t>
        <t>Hans Granqvist (hgranqvist@verisign.com)</t>
        <t>Johannes Ernst (jernst@netmesh.us)</t>
        <t>Johnny Bufu (johnny@sxip.com) &lt;editor&gt;</t>
        <t>Josh Hoyt (josh@janrain.com) &lt;editor&gt;</t>
        <t>Kevin Turner (kevin@janrain.com)</t>
        <t>Marius Scurtescu (marius@sxip.com)</t>
        <t>Martin Atkins (mart@degeneration.co.uk)</t>
        <t>Mike Glover (mpg4@janrain.com)</t>
      </list>
      </t>
    </appendix>
  </middle>

  <back>
    <references title='Normative References'>
      <reference anchor='RFC3629'>
        <front>
          <title>
            UTF-8, a transformation format of Unicode and ISO 10646
          </title>
          <author initials='F.Y' surname='Yergeau' fullname='Francois Yergeau'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3629" />
      </reference>
      <reference anchor='RFC2119'>
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials='B.S' surname='Bradner' fullname='Scott Bradner'>
            <organization>Alis Technologies</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>
      <reference anchor='RFC3986'>
        <front>
          <title>Uniform Resource Identifiers (URI): Generic Syntax</title>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC1750'>
        <front>
          <title>Randomness Recommendations for Security</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Digital Equipment Corporation</organization>
          </author>
          <author initials='S.C' surname='Crocker'
                  fullname='Stephen D. Crocker'>
            <organization>CyberCash, Inc.</organization>
          </author>
          <author initials='J.S' surname='Schiller'
                  fullname='Jeffery I. Schiller'>
            <organization>Massachusetts Institute of Technology</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="1750" />
      </reference>
      <reference anchor='RFC2631'>
        <front>
          <title>Diffie-Hellman Key Agreement Method</title>
          <author initials='E.R' surname='Rescorla'
                  fullname='Eric Rescorla'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2631" />
      </reference>
      <reference anchor='RFC3548'>
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials='S.J' surname='Josefsson'
                  fullname='Simon Josefsson'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3548" />
      </reference>
      <reference anchor='RFC2104'>
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>
          <author initials='H.K' surname='Krawczyk' fullname='Hugo Krawczyk'>
            <organization>IBM</organization>
          </author>
          <author initials='M.B' surname='Bellare' fullname='Mihir Bellare'>
            <organization>UCSD</organization>
          </author>
          <author initials='R.C' surname='Canetti' fullname='Ran Canetti'>
            <organization>IBM</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2104" />
      </reference>
      <reference anchor='FIPS180-2'>
        <front>
          <title>Secure Hash Signature Standard</title>
          <author>
            <organization>U.S. Department of Commerce</organization>
          </author>
          <author>
            <organization>National Institute of Standards
              and Technology</organization>
          </author>
        </front>
        <seriesInfo name="FIPS" value="180-2" />
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf" />
        <annotation>Defines Secure Hash Algorithm 256 (SHA256)</annotation>
      </reference>
      <reference anchor='HTML401'>
        <front>
          <title>HTML 4.01 Specification</title>
          <author>
            <organization>W3C</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.w3.org/TR/html401" />
      </reference>
      <reference anchor='RFC2616'>
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
          <author initials='R.F' surname='Fielding' fullname='R. Fielding'>
            <organization>UC Irvine</organization>
          </author>
          <author initials='J.G' surname='Gettys' fullname='J. Gettys'>
            <organization>Compaq/W3C</organization>
          </author>
          <author initials='J.M' surname='Mogul' fullname='J. Mogul'>
            <organization>Compaq</organization>
          </author>
          <author initials='H.F' surname='Frystyk' fullname='H. Frystyk'>
            <organization>W3C/MIT</organization>
          </author>
          <author initials='L.M' surname='Masinter' fullname='L. Masinter'>
            <organization>Xerox</organization>
          </author>
          <author initials='P.L' surname='Leach' fullname='P. Leach'>
            <organization>Microsoft</organization>
          </author>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization>W3C/MIT</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2616" />
      </reference>
      <reference anchor='RFC3174'>
        <front>
          <title>US Secure Hash Algorithm 1 (SHA1)</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Motorola</organization>
          </author>
          <author initials='P.J' surname='Jones' fullname='Paul E. Jones'>
            <organization>Cisco Systems, Inc.</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor='RFC3339'>
        <front>
          <title>Date and Time on the Internet: Timestamps</title>
          <author initials='C.N' surname='Newman'
                  fullname='Chris Newman'>
            <organization>Sun Microsystems</organization>
          </author>
          <author initials='G.K' surname='Klyne' fullname='Graham Klyne'>
            <organization>Clearswift Corporation</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>

      <reference anchor="RFC3275">
        <front>
          <title>(Extensible Markup Language) XML-Signature Syntax and
          Processing</title>
          <author initials='D.E.' surname='Eastlake 3rd'
                  fullname='Donald E. Eastlake 3rd'>
            <organization>Motorola</organization>
          </author>
          <author initials='J.R.' surname='Reagle Jr.' fullname='Joseph M. Reagle Jr.'>
            <organization>Massachusetts Institute of
            Technology</organization>
          </author>
          <author initials='D.S.' surname='Solo' fullname='David
                                                                 Solo'>
            <organization>Citigroup</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3275" />
      </reference>

      <reference anchor="XRI_Syntax_2.0"
                 target="http://www.oasis-open.org/committees/download.php/15376" >

        <front>
          <title>Extensible Resource Identifier (XRI) Syntax V2.0</title>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='D.M' surname='McAlpin' fullname="Dave McAlpin">
            <organization>Epok</organization>
          </author>
        </front>
        <format type="HTML" target=
                "http://www.oasis-open.org/committees/download.php/15376" />
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/15377" />
      </reference>

      <reference anchor="XRI_Resolution_2.0"
                 target="http://www.oasis-open.org/committees/download.php/17293" >
        <front>
          <title>Extensible Resource Identifier (XRI) Resolution V2.0
          - Working Draft 10</title>
          <author initials='G.W' surname='Wachob' fullname="Gabe Wachob">
            <organization>Visa International</organization>
          </author>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='L.C' surname='Chasen' fullname="Les Chasen">
            <organization>NeuStar</organization>
          </author>
          <author initials='W.T' surname='Tan' fullname="William Tan">
            <organization>NeuStar</organization>
          </author>
          <author initials='S.C' surname='Churchill' fullname="Steve Churchill">
            <organization>XDI.ORG</organization>
          </author>
        </front>
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/17293" />
      </reference>

      <reference anchor="Yadis">
        <front>
          <title>Yadis Specification 1.0</title>
          <author initials='J.M' surname='Miller' fullname="Joaquin Miller">
            <organization>NetMesh</organization>
          </author>
        </front>
        <format type='PDF' target="http://yadis.org/papers/yadis-v1.0.pdf" />
        <format type='ODT' target="http://yadis.org/papers/yadis-v1.0.odt" />
      </reference>
    </references>
  </back>
</rfc>
