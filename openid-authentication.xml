<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC ''
'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category="info" ipr="none" docName="openid-authentication-2_0-11.xml">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="2" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc iprnotified="no" ?>
  <?rfc strict="yes" ?>
  <?rfc private="Pre-Draft" ?>

  <front>
    <title>OpenID Authentication 2.0 - Pre-Draft 11</title>

    <author initials="D.R" surname="Recordon" fullname="David Recordon">
      <organization abbrev="VeriSign">VeriSign, Inc.</organization>
      <address>
        <postal>
          <street>487 E Middlefield Road</street>
          <city>Mountain View</city> <region>CA</region>
          <code>94109</code>
          <country>USA</country>
        </postal>
        <email>drecordon@verisign.com</email>
      </address>
    </author>

    <author initials="J.H" surname="Hoyt" fullname="Josh Hoyt">
      <organization abbrev="JanRain">JanRain, Inc.</organization>
      <address>
        <postal>
          <street>5331 SW Macadam Avenue</street>
          <street>Suite #375</street>
          <city>Portland</city> <region>OR</region>
          <code>97239</code>
          <country>USA</country>
        </postal>
        <email>josh@janrain.com</email>
      </address>
    </author>

    <author initials="D.H" surname="Hardt" fullname="Dick Hardt">
      <organization abbrev="Sxip">Sxip Identity Corporation</organization>
      <address>
        <postal>
          <street>798 Beatty Street</street>
          <city>Vancouver</city> <region>BC</region>
          <code>V6B 2M1</code>
          <country>Canada</country>
        </postal>
        <email>dick@sxip.com</email>
      </address>
    </author>

    <author initials="B.F" surname="Fitzpatrick"
            fullname="Brad Fitzpatrick">
      <organization abbrev="Six Apart">Six Apart, Ltd.</organization>
      <address>
        <postal>
          <street>548 4th Street</street>
          <city>San Francisco</city> <region>CA</region>
          <code>94107</code>
          <country>USA</country>
        </postal>
        <email>brad@danga.com</email>
      </address>
    </author>

    <date month="November" year="2006"/>

    <abstract>
      <t>
        OpenID Authentication provides a way to prove that an end user
        controls an Identifier. It does this without the Relying Party
        needing access to end user credentials such as a password or
        to other sensitive information such as an email address.
      </t>

      <t>
        OpenID is decentralized. No central authority must approve or
        register Relying Parties or OpenID Providers. An end user
        can freely choose which OpenID Provider to use, and can
        preserve their Identifier if they switch OpenID Providers.
      </t>

      <t>
        While nothing in the protocol requires JavaScript or modern
        browsers, the authentication scheme plays nicely with
        "AJAX"-style setups. This means an end user can prove their
        Identity to a Relying Party without having to leave their
        current Web page.
      </t>

      <t>
        OpenID Authentication uses only standard HTTP(S) requests and
        responses, so it does not require any special capabilities of the
        User-Agent or other software. OpenID is not tied to the use of
        cookies or any other specific mechanism of Relying Party
        session management.  Extensions to User-Agents can simplify
        the end user interaction, though are not required to utilize
        the protocol.
      </t>

      <t>
        The exchange of profile information, or the exchange of other
        information not covered in this specification, can be addressed
        through additional Service Types built on top of this
        protocol to create a framework. OpenID Authentication is
        designed to provide a base service to enable portable,
        user-centric digital identity in a free and decentralized manner.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Requirements Notation">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
      "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
      and "OPTIONAL" in this document are to be interpreted as
      described in <xref target="RFC2119"/>.</t>
    </section>

    <section title="Terminology">
      <t>
    <list style="hanging">
      <t hangText="Identifier:">
        An Identifier is either a "http" or "https" URI, (commonly
        referred to as a "URL" within this document), or an <xref
        target="XRI Syntax 2.0" >XRI</xref>.  This document defines
        various kinds of Identifiers, designed for use in different
        contexts.
      </t>

      <t hangText="User-Agent:">
        The end user's Web browser which implements HTTP/1.1 <xref
        target="RFC2616"/>.
      </t>

      <t hangText="Relying Party:">
        RP. A Web application that wants proof that the end user
        controls an Identifier.
      </t>

      <t hangText="OpenID Provider:">
        OP. The party operating an OpenID Authentication server on
        which a Relying Party relies for an assertion that the end
        user controls an Identifier.
      </t>

      <t hangText="OP Endpoint URL:">
        The URL which accepts OpenID Authentication requests,
        discovered by dereferencing the end user's Identifier.  This
        value MUST be an absolute URL.
      </t>

      <t hangText="User-supplied Identifier">
        An Identifier that was presented by the end user to the Relying Party.
        During the initiation phase of the protocol, an end user may enter
        either a Public Identifier or an OP Identifier. If an OP Identifier
        is used, the OP may then assist the end user in selecting either a
        Public Identifier or a Private Identifier to share with the Relying
        Party.
      </t>

      <t hangText="Claimed Identifier:">
        An Identifier that the end user claims to own. The overall aim
        of the protocol is verifying this Identifier. The Claimed
        Identifier is either:
        <list style="symbols">
          <t>
            The Identifier obtained by <xref target="normalization">
            normalizing</xref> the User-supplied Identifier, if it
            was an URL.
          </t>
          <t>
            The <xref target="canonicalid">CanonicalID</xref>, if it
            was an XRI.
          </t>
        </list>
      </t>

      <t hangText="OP-Specific Identifier:">
        An alternate Identifier for an end user that is specific to a
        particular OP and thus not necessarily under the end user's
        control.
      </t>


      <t hangText="OP Identifier:">
        An Identifier for an OpenID Provider.
      </t>

      <t hangText="Public Identifier:">
        An Identifier that is intended to be public information and
        not specific to the end user's relationship with one or more
        Relying Parties, for example a blog URL or an i-name.
      </t>

      <t hangText="Private Identifier:">
        An Identifier that is intended to be private information used
        only in the context of the end user's relationship with one or
        more specific Relying Parties.
      </t>

      <t hangText="Diffie-Hellman Key Exchange:">
         Diffie-Hellman Key Exchange <xref target="RFC2631" /> is a
         protocol that allows two parties to create a shared a secret,
         while preventing eavesdroppers from learning the secret.
      </t>

    </list>
      </t>
    </section>

    <section title="Protocol Overview">

      <t>
        <list style="numbers">
          <t>
            The end user <xref target="initiation">initiates
            authentication</xref> by presenting a User-supplied Identifier
            to the Relying Party via their User-Agent.
          </t>
          <t>
            After normalizing the User-supplied Identifier, The Relying
            Party <xref target="discovery">performs discovery</xref> on
            it and establishes the URL of the OP's OpenID Authentication
            service endpoint that the end user uses for authentication.
          </t>
          <t>
            (optional) 

            The Relying Party and the OP establish an <xref
            target="associations">association</xref> -- a shared
            secret established using Diffie-Hellman Key Exchange. The
            OP uses an association to sign subsequent messages and
            the Relying Party to verify those messages; this removes
            the need for subsequent direct requests to verify the
            signature after each authentication request.
          </t>
          <t>
            The Relying Party redirects the end user's User-Agent to
            the OP with an OpenID <xref
            target="requesting_authentication">Authentication
            request</xref>.
          </t>
          <t>
            The OP establishes whether the end user is authorized to
            perform OpenID Authentication and wishes to do so. The
            manner in which the end user authenticates to their OP and
            any policies surrounding such authentication is out of
            scope for this document.
          </t>
          <t>
            The OP redirects the end user's User-Agent back to the
            Relying Party with cyrptographic proof asserting either
            that <xref target="positive_assertions">authentication is
            approved</xref> or <xref
            target="negative_assertions">authentication failed</xref>.
          </t>
          <t>
            The Relying Party <xref
            target="verification">verifies</xref> the information
            received from the OP including checking the nonce,
            verifying the signature by using either the shared key
            established during the association or by sending a direct
            request to the OP, and verifying the discovered
            information.
           </t>
         </list>
      </t>
    </section>


    <section title="Data Formats" anchor="formats">

      <section title="Protocol Messages">

        <t>
          The OpenID Authentication protocol messages are
          mappings of plain-text keys to plain-text values. The keys and
          values permit the full Unicode character set (UCS). When the
          keys and values need to be converted to/from bytes, they
          MUST be encoded using <xref target="RFC3629">UTF-8</xref>.

          Messages MUST NOT contain multiple parameters with the same name.  
        </t>
        
        <section title="Key-Value Form Encoding" anchor="kvform">
          <t>
            A message in Key-Value form is a sequence of lines.  Each
            line begins with a key, followed by a colon, and the value
            associated with the key.  The line is terminated by a
            single newline (UCS codepoint 10, "\n"). A key or value
            MUST NOT contain a newline and a key also MUST NOT contain
            a colon.
          </t>
          <t>
            Additional characters, including whitespace, MUST NOT be
            added before or after the colon or newline. The message
            MUST be encoded in UTF-8 to produce a byte string.
          </t>
          <t>
            Key-Value Form encoding is used for signature calculation
            and for <xref target="direct_response">direct
            responses</xref> to Relying Parties.
          </t>
        </section>
 
        <section title="HTTP Encoding" anchor="queries">

          <t>
            When a message is sent to an HTTP server, it MUST be encoded
            using a form encoding specified in Section 17.13.4 of
            <xref target="HTML401" />. Likewise, if the "Content-Type"
            header is included in the request headers, its value MUST
            also be such an encoding.
          </t>
          <t>
            All of the keys in the request message MUST be prefixed
            with "openid.". This prefix prevents interference with
            other parameters that are passed along with the OpenID
            Authentication message. When a message is sent as a POST,
            the application processing the HTTP request MUST only use
            the values in the POST body and MUST ignore any GET
            parameters.
          </t>
          <t>
            This model applies to messages from the User-Agent to both
            the Relying Party and the OP, as well as messages from the
            Relying Party to the OP.
          </t>
        </section>
        <section title="Example">
          <t>
            Non-normative
          </t>
          <t>
            <figure>
              <preamble>
                The following examples encode the following information:
              </preamble>
              <artwork><![CDATA[
Key     | Value
--------+---------------------------
mode    | error
error   | This is an example message
]]>
              </artwork>
            </figure>
          </t>
          <t>
            <figure>
              <preamble>
                Key-Value Form encoded:
              </preamble>
              <artwork><![CDATA[mode:error
error:This is an example message
]]>
              </artwork>
            </figure>
            <figure>
              <preamble>
                x-www-urlencoded, as in a HTTP POST body or in a URL's
                query string (<xref target="RFC3986" /> section 3):
              </preamble>
              <artwork>openid.mode=error&amp;openid.error=This%20is%20an%20example%20message</artwork>
            </figure>
          </t>
        </section>
      </section>

      <section title="Integer Representations" anchor="btwoc">
        <t>
          Arbitrary precision integers MUST be encoded as big-endian
          signed two's complement binary strings. Henceforth,
          "btwoc" is a function that takes an arbitrary precision
          integer and returns its shortest big-endian two's
          complement representation. All integers that are used with
          Diffie-Hellman are positive. This means that the left-most
          bit of the two's complement representation MUST be
          zero. If it is not, implementations MUST add a zero byte
          at the front of the string.
        </t>
        <figure>
          <preamble>Non-normative example:</preamble>
          <artwork>
Base 10 number | btwoc string representation
---------------+----------------------------
0              | "\x00"
127            | "\x7F"
128            | "\x00\x80"
255            | "\x00\xFF"
32768          | "\x00\x80\x00"
          </artwork>
        </figure>
      </section>
    </section>

    <section title="Communication Types" anchor="communication">
      <section title="Direct Communication"
               anchor="direct_comm">
        <t>
          Direct communication is initiated by a Relying Party to an
          OP endpoint URL.  It is used for <xref
          target="associations">establishing associations</xref> and
          <xref target="check_auth">verifying authentication
          assertions</xref>.
        </t>
        <section title="Direct Request" anchor="direct_request">
          <t>
            The message MUST be encoded as a POST body, as specified
            by <xref target="queries" />.
          </t>
          <t>
            All direct requests must contain the following field:
          </t>
          <t>
            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the request to
                    be a valid OpenID 2.0 direct request.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>
        <section title="Direct Response" anchor="direct_response">
          <t>
            The body of a response to a <xref
            target="direct_request">Direct Request</xref> consists of
            an HTTP Response body in <xref target="kvform">Key-Value
            Form</xref>. The content-type of the response SHOULD be
            "text/plain".
          </t>
          <t>
            All direct responses must contain the following field:
          </t>
          <t>
            <list style='symbols'>
              <t>
                ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 direct response.
                  </t>
                </list>
              </t>
            </list>
          </t>

           <section title="Successful Responses">
            <t>
              A server receiving a valid request MUST send a
              response with an HTTP status code of 200.
            </t>
          </section>

          <section title="Error Responses">
            <t>
              If a request is malformed or contains invalid arguments,
              the server MUST send a response with a status code of
              400. The response body MUST be a Key-Value Form <xref
          target="kvform"/> message with the following fields:
            </t>
            <t>
              <list style='symbols'>
                <t>
                  ns
                  <list style='empty'>
                    <t>
                        Value: "http://openid.net/signon/2.0"
                    </t>
                    <t>
                        This value MUST be present for the response to
                        be a valid OpenID 2.0 direct error response.
                    </t>
                  </list>
                </t>

                <t>
                  error
                  <list style='empty'>
                    <t>
                      Value: Unstructured text error message.
                    </t>
                  </list>
                </t>

                <t>
                  contact
                  <list style='empty'>
                    <t>
                      Value: (optional) Contact address for the
                      administrator of the sever. The contact address
                      may take any form, as it is intended to be
                      displayed to a person.
                    </t>
                  </list>
                </t>

                <t>
                  reference
                  <list style='empty'>
                    <t>
                      Value: (optional) A reference identifier, such
                      as a support ticket number or a URL to a news
                      blog, etc.
                    </t>
                  </list>
                </t>
              </list>
               The OP MAY add additional fields to this response.
            </t>
          </section>
        </section>
      </section>
      <section title="Indirect Communication"
               anchor="indirect_comm">
        <t>
          In indirect communication, messages are passed through the
          User-Agent.  This can be initiated by either the Relying
          Party or the OP.  Indirect communication is used for <xref
          target="requesting_authentication">authentication
          requests</xref> and <xref
          target="responding_to_authentication">authentication
          responses</xref>.
        </t>
        <t>
          There are two methods for indirect communication: HTTP
          redirects and HTML form submission.
          Both form submission and redirection require that the sender
          know a recipient URL and that the recipient URL expect
          indirect messages, as specified in <xref target="queries"
          />. The initiator of the communication chooses which method
          of indirect communication is appropriate depending on
          capabilities, message size, or other external factors.
        </t>
        <t>
          All indirect messages must contain the following field:
        </t>
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  This value MUST be present for the message to
                  be a valid OpenID 2.0 indirect message.
                </t>
              </list>
            </t>
          </list>
        </t>

        <section title="HTTP Redirect">
          <t>
            Data can be transferred by issuing a 302, 303, or 307 HTTP
            Redirect to the end user's User-Agent. The redirect URL is
            the URL of the receiver with the OpenID Authentication
            message appended to the query string, as specified in
            <xref target="queries" />.
          </t>
        </section>

        <section title="HTML FORM Redirection">
          <t>
            A mapping of keys to values can be transferred by
            returning an HTML page to the User-Agent that contains an
            HTML form element. Form submission MAY be automated
            using JavaScript.
          </t>
          <t>
            The &lt;form&gt; element's "action" attribute value MUST
            be the URL of the receiving Web site. Each Key-Value pair
            MUST be included in the form as an &lt;input&gt;
            element. The key MUST be encoded as the "name" attribute
            and the value as the "value" attribute, such that the
            User-Agent will generate a message as specified in <xref
            target="queries" /> when the form is submitted. The form
            MUST include a submit button.
          </t>
        </section>
        <section title="Indirect Error Responses">
          <t>
            In the case of a malformed request or one that contains
            invalid arguments, the server MUST redirect the User-Agent
            to the "openid.return_to" URL value if the value is a
            valid URL.
          </t>
          <t>
            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 indirect error response.
                  </t>
                </list>
              </t>

              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "error"
                  </t>
                </list>
              </t>
              <t>
                openid.error
                <list style='empty'>
                  <t>
                    Value: Unstructured text error message.
                  </t>
                </list>
              </t>
              <t>
                openid.contact
                <list style='empty'>
                  <t>
                    Value: (optional) Contact address for the
                    administrator of the sever. The contact address
                    may take any form, as it is intended to be
                    displayed to a person.
                  </t>
                </list>
              </t>

              <t>
                openid.reference
                <list style='empty'>
                  <t>
                    Value: (optional) A reference identifier, such
                    as a support ticket number or a URL to a news
                    blog, etc.
                  </t>
                </list>
              </t>
            </list>

            The server MAY add additional keys to this response.
          </t>
          <t>
            If the "openid.return_to" value is not a valid URL, the
            server SHOULD return a response to the end user indicating
            the error and that it is unable to return the end user to
            the initiating server. If the parameter is ommitted in the
            request, it signifies that the initiating server does not
            wish to for the end user to be returned to it as something
            else useful will have been performed via an extension.
          </t>
        </section>
      </section>
    </section>

    <section title="Generating Signatures" anchor="generating_signatures">
      <t> 
        The most common usage of an association is as a Message
        Authentication Code (MAC) key used to sign OpenID
        Authentication messages.
      </t>
      <t>
        When generating MAC keys, the recommendations in <xref
        target="RFC1750" /> SHOULD be followed.
      </t>

      <section title="Procedure">
        <t>
          To generate a message signature:
          <list style="numbers">
            <t> 
              Determine the appropriate list of keys to be signed
              and signature algorithm from the <xref
                  target="associations">association type</xref>.
            </t>
            <t> 
              Generate the list of key/value pairs to be signed using
              the correct <xref
                  target="signed_list">list algorithm</xref>.
            </t>
            <t> 
              Convert the list of key/value pairs to be signed to an octet
              string by encoding with <xref target="kvform">Key-Value Form
              Encoding</xref>.
            </t>
            <t> 
              Apply the correct <xref target="sign_algos">signature
              algorithm</xref> to the octet string.
            </t>
          </list>
        </t>
      </section>

      <section title="Signed List Algorithm" anchor="signed_list">
    <t>
      The input to the Signed List Algorithm are the message
      to be signed, and the list of message keys that are to be
      signed with the "openid." prefix removed.
    </t>
    <t>
      To compute the list of key/value pairs to be signed:
      <list style="numbers">
        <t> 
          Iterate through the list of keys to be signed in
          the order they appear in the input to the algorithm.
          For each key, find the value in the message whose key is
          equal to the signed list key prefixed with "openid."
        </t>
        <t>
          Append the signed list key and the associated value to
          the list of key/value pairs to be signed.
        </t>
      </list>
    </t>
    <t>
      The output of this algorithm is the list of key/value pairs
      to be signed, and the list of keys to be signed. A message
      signed using this algorithm MUST append the list of signed
      fields to the message.
    </t>
    <t>
      As the algorithm strips the "openid." prefix from message
      keys while looking for a match, it MUST only sign elements
      that have keys beginning with "openid." This is to prevent
      attacks where the Relying Party is malicious and tries to
      have the OP sign arbitrary data.
    </t>
      </section>

      <section title="Signature Algorithms" anchor="sign_algos">
        <t>
          OpenID Authentication supports two signature algorithms:

          <list style="symbols">
            <t>HMAC-SHA1(<xref target="RFC2104" /> and <xref
                target="RFC3174" />)</t>
            <t>HMAC-SHA256 (<xref target="RFC2104" /> and <xref
                target="FIPS180-2" /></t>
          </list>

          HMAC-SHA1 is the default for authentication requests though
          the use of HMAC-SHA256 is RECOMENDED. At the time of writing
          this document, library support for SHA256 seems lacking.
        </t>
        <texttable>
          <ttcol>Algorithm</ttcol>
          <ttcol>Key Length</ttcol>

          <c>HMAC-SHA1</c>
          <c>160 bits</c>

          <c>HMAC-SHA256</c>
          <c>256 bits</c>
        </texttable>
      </section>
    </section>

    <section title="Initiation and Discovery">

      <section title="Initiation" anchor="initiation">
        <t>
          To initiate OpenID Authentication, the Relying Party SHOULD
          present the end user with a form that has a field for
          entering an Identifier. 
        </t>
        
        <t>
          It is RECOMMENDED that a Relying Party place the <eref
          target='http://openid.net/login-bg.gif'>OpenID logo</eref>
          at the beginning of the form field where the end user enters
          their Identifier. This aides in end user recognition that
          they can use an OpenID enabled Identifier at the Relying Party.
        </t>

        <t>
          The form field's "name" attribute SHOULD have the value
          "openid_identifier" as to allow User-Agents to automatically
          prefill the end user's preferred Identifier when visiting a
          Relying Party. Browser extensions or other software that
          support OpenID Authentication may not detect a Relying
          Party's support if the value is not this value.
        </t>
      </section>

      <section title="Normalization" anchor="normalization">
        <t>
          The end user's input MUST be normalized into an
          Identifier.  If the end user supplies input that does not
          include a scheme (http, https, or xri), then the application
          needs to determine if the input is an XRI or a URL missing
          the scheme.
        </t>

        <t>
          To do so, the Relying Party SHOULD examine the first
          character of the input. If it is an XRI Global Context
          Symbol ("=", "@", "+", "$", or "!" see
          <xref target="XRI Syntax 2.0">Section 2.2.1.2 of</xref>),
          then the input SHOULD be treated as an XRI. If it is not,
          then the input SHOULD be treated as an http URL, and
          prefixed with the string "http://". See <xref
          target='http_s_identifiers' /> for more information.
        </t>

        <t>
          URL identifiers MUST then be further normalized by both
          following redirects when retrieving their content and
          finally applying the rules in Section 6 of <xref
          target='RFC3986' /> to the final destination URL. This final
          URL MUST be noted by the Relying Party as the Claimed
          Identifier and be used during future requests.
        </t>
      </section>

      <section title="Discovery" anchor="discovery">

        <t>
          Discovery is the process where the Relying Party uses the
          Identifier to look up ("discover") the necessary information
          for initiating requests. OpenID Authentication has three
          paths through which to do discovery:
        </t>

        <t>
          <list style="numbers">
            <t>
              If the identifier is an XRI,
              <xref target="XRI Resolution 2.0" /> will yield an XRDS
              document that contains the necessary information.
            </t>

            <t>
              If it is a URL, the <xref target="Yadis">Yadis
              protocol</xref> SHALL be first attempted. If it
              succeeds, the result is again an XRDS document.
            </t>

            <t>
              If the Yadis protocol fails, the URL is retrieved and
              <xref target="html_disco">HTML-based discovery</xref>
              SHALL be attempted.
            </t>
          </list>
        </t>

        <section title="Discovered Information">
          <t>
            Upon successful completion of discovery, the Relying
            Party will have the following information (see the
            Terminology section for definitions):

            <list style="hanging">
              <t hangText="OP Endpoint URL:">
                The absolute URL on the OP that accepts authentication requests.
              </t>

              <t hangText="Claimed Identifier:">
                (optional) The identifier that is the subject of this
                authentication request. This is:
              </t>
                  <t>
                    The Identifier obtained by <xref target="normalization">
                    normalizing </xref> the User-supplied Identifier,
                    if it was an URL.
                  </t>
                  <t>
                    The <xref target="canonicalid"> CanonicalID </xref>,
                    if the User-supplied Identifier was an XRI.
                  </t>

              <t hangText="OP-Specific Identifier:">
                (optional) An identifier that allows an OP to
                identify the end user of a Claimed Identifier. If no
                OP-specific identifier is present in the discovered
                information, the Claimed Identifier is also the
                OP-Specific Identifier.
              </t>

              <t hangText="Protocol Version:">
                The OpenID protocol version of the discovered
                OpenID Provider(s). This is determined by the
                &lt;xrd:Type&gt; tag of the OP Identifier Element.
              </t>
            </list>
          </t>
        </section>

        <section title="XRDS-Based Discovery">
          <t>
            If XRI or Yadis discovery was used, the result will be an
            XRDS Document.  This is a XML document with entries for
            services that are related to the Identifier.  It is
            defined in <xref target="XRI Resolution 2.0">Section 3
            of</xref>.  See <xref target="XRDS Sample" /> for an
            example XRDS document.
          </t>


          <section title="Service Elements">
          
            <section title="OP Identifier Element">
              <t> 
                An OP Identifier Element is a &lt;xrd:Service&gt;
                element with the following information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://openid.net/server/2.0".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    OP Endpoint URL
                  </t>
                </list>
              </t>
            </section>

            <section title="Claimed Identifier Element">
              <t>
                A Claimed Identifier Element is an
                &lt;xrd:Service&gt; element with the following
                information:

                <list style="hanging">
                  <t>
                    An &lt;xrd:Type&gt; tag whose text content is
                    "http://openid.net/signon/2.0".
                  </t>

                  <t>
                    An &lt;xrd:URI&gt; tag whose text content is the
                    OP Endpoint URL.
                  </t>

                  <t>
                    An &lt;openid:Delegate&gt; tag (optional) whose text
                    content is the OP-Specific Identifier.
                  </t>
                </list>
              </t>
            </section>
          </section>

          <section title="Extracting Authentication Data">
            <t>
              Once the Relying Party has obtained an XRDS document, it
              MUST first search the document (following the rules
              described in <xref target="XRI Resolution 2.0" />) for
              an OP Identifier Element. If none is found, the RP will search
              for a Claimed Identifier Element.
            </t>
          </section>

          <section title="XRI and the CanonicalID Element" anchor="canonicalid"
                   toc="exclude">
            <t>
              When the identifier is an XRI, the &lt;xrd:XRD&gt;
              element that contains the OpenID Authentication
              &lt;xrd:Service&gt; element MUST also contain a
              &lt;CanonicalID&gt; element. The content of this element
              MUST be used as the Claimed Identifier (see <xref
              target="identifying" />).  This is a vital security
              consideration because a primary purpose of the
              &lt;CanonicalID&gt; element is to assert a persistent
              identifier that will never be reassigned, thus
              preventing the possibility of an XRI being "taken over"
              by a new registrant.
            </t>

            <t>
              The Relying Party MUST confirm that the provider of the
              XRD that contains the &lt;CanonicalID&gt; element is
              authoritative for that Canonical ID. The provider is
              identified by the contents of the &lt;xrd:ProviderID&gt;
              element that is a child of the &lt;xrd:XRD&gt;
              element. If the provider is not authoritative for the
              Canonical ID, the Relying Party MUST resolve the
              Canonical ID to confirm the OP Endpoint URL information
              that was discovered. The information discovered when
              resolving the canonical ID MUST match the information
              discovered when resolving the User-supplied Identifier.
           </t>

            <t>
              When using XRI resolution, the canonical ID MUST be
              used as the Claimed Identifier. For an XRI to be a
              valid identifier, both the &lt;ProviderID&gt; and
              &lt;CanonicalID&gt; MUST be present in the discovered
              XRDS document.
            </t>

            <t>
              When using URL-based identifiers, the CanonicalID
              element SHOULD be ignored if present.
            </t>
          </section>

          <section title="Additional Information">
            <t>
              The "openid" namespace is
              "http://openid.net/signon/2.0". The "xrd" namespace is
              "xri://$xrd*($v*2.0)".
            </t>

            <t>
              For compatibility with deployed code, it is RECOMMENDED
              that a Relying Party also accept
              "http://openid.net/signon/1.0" or
              "http://openid.net/signon/1.1" for the value of
              &lt;xrd:Type&gt;. When one of these values is used, the
              Relying Party MUST use <xref target="compat_mode">OpenID
              Authentication 1.1 Compatibility</xref>.
            </t>

            <t>
              If an OpenID OP supports extensions (<xref
              target="extensions" />), the extensions SHOULD be listed
              as additional &lt;xrd:Type&gt; child elements of the
              &lt;xrd:Service&gt; element.
            </t>

          </section>

        </section>

        <section anchor="html_disco" title="HTML-Based Discovery">
          <t>
            OpenID Authentication 1.1 HTML-based discovery MUST be
            supported by Relying Parties.  If a Relying Party locates
            an OP using HTML-based discovery, it MUST use <xref
                target="compat_mode">OpenID Authentication 1.1
            Compatibility</xref> when communicating with that OP.
          </t>

          <t>
            To use HTML-based discovery, an HTML document MUST be
            available at the URL of the Claimed Identifier. In the
            HEAD section of the document:

            <list>
              <t>
                A &lt;LINK&gt; tag MUST be included with attributes
                "rel" set to "openid.server", and "href" set to an OP
                Endpoint URL
              </t>
              <t>
                A &lt;LINK&gt; tag MAY be included with attributes
                "rel" set to "openid.delegate" and "href" set to the
                end user's OP-Specific Identifier
              </t>
            </list>
          </t>

          <t> The host of the HTML document MAY be different from the
            end user's OP's host.
          </t>

          <t>
            The "openid.server" and "openid.delegate" URLs MUST NOT
            include entities other than "&amp;amp;", "&amp;lt;",
            "&amp;gt;", and "&amp;quot;". Other characters that would
            not be valid in the HTML document or that cannot be
            represented in the document's character encoding MUST be
            escaped using the percent-encoding (%xx) mechanism
            described in <xref target='RFC3986' />.
          </t>
        </section>
      </section>
    </section>


    <section title="Establishing Associations" anchor="associations">
      <t>
        An "association" is a shared secret between the OP and
        Relying Party.  Once established, it is used to verify
        subsequent protocol messages and reduces round trips.
      </t>
      <t>
        It is RECOMMENDED that a Relying Party form associations if it
        is possible for it to do so.  If a Relying Party is incapable
        of creating or storing associations, <xref
        target="verifying_signatures"/> provides an alternate
        verification mechanism referred to as Stateless Mode (note
        that this was referred to as "dumb mode" in previous versions
        of this specification).
      </t>

      <section title="Association Session Request">
        <t>
          An association session is initiated by a <xref
          target="direct_comm">direct request</xref> from a Relying
          Party to an OP Endpoint URL with the "openid.mode" key
          having the value of "associate".
        </t>
         
        <section title="Common Request Parameters" toc="exclude">
          <t> 
            These parameters are common to all association requests:
          </t>
          <t>
            <list style="symbols">
              <t>openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the request to
                    be a valid OpenID 2.0 association request.
                  </t>
                </list>
              </t>
              <t>openid.mode 
                <list style="empty">
                  <t> Value: "associate"</t>
                </list>
              </t>

              <t>openid.assoc_type 
                <list style="empty">
                  <t> The preferred association type.  The association
                    type defines the algorithm to be used to sign
                    subsequent messages.</t>
                  <t> Value: A valid association type from <xref
                  target="assoc_types"/></t>
                  <t> Default: "HMAC-SHA1".</t>
                </list>
              </t>

              <t>openid.session_type 
                <list style='empty'>
                  <t>
                    The preferred association session type.  This
                    defines the method used to encrypt the association's
                    MAC key in transit.
                  </t>
                  <t>
                    Value: A valid association session type from
                    <xref target="assoc_sess_types"/>.
                  </t>
                  <t>
                    Note: Unless using transport layer encryption, it
                    is NOT RECOMMENDED to use "no-encryption" on a
                    public network, see <xref
                        target="preventing_eavesdropping" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Diffie-Hellman Request Parameters" toc="exclude">
          <t>
            The following parameters are common to requests whose
            requested association session type is "DH-SHA1" or
            "DH-SHA256":
          </t>
          <t>
            <list style="symbols">
              <t>
                openid.dh_modulus
                <list style='empty'>
                  <t>Value: base64(btwoc(p))</t>
                  <t>Default: See <xref target='pvalue' /></t>
                </list>
              </t>
              <t>
                openid.dh_gen
                <list style='empty'>
                  <t>Value: base64(btwoc(g))</t>
                  <t>Default: g = 2</t>
                </list>
              </t>
              <t>
                openid.dh_consumer_public
                <list style='empty'>
                  <t>Value: base64(btwoc(g ^ xa mod p))</t>
                </list>
              </t>
            </list>
          </t>
          <t>
            See <xref target="dh_sessions"/> for more information on
            these parameters.
          </t>
          <t>
            NOTE: the 'btwoc' function is defined in <xref
            target="btwoc"/>.
          </t>
        </section> 
      </section>

      <section title="Association Session Response">
        <t>
          An association session response is a direct response from the
          OP to the Relying Party in <xref target="kvform">Key-Value
          Form</xref>.
        </t>

        <section title="Common Response Parameters">
          <t>
            <list style="symbols">
              <t>
                ns
                <list style="empty">
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 association response.
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style="empty">
                  <t>
                    The session type for this association. If the OP
                    is unwilling or unable to support this session
                    type, it MUST return an unsuccessful response.
                  </t>
                </list>
              </t>
              <t>
                assoc_handle
                <list style="empty">
                  <t>
                    The association handle is used as a key to refer
                    to this association in subsequent messages.
                  </t>
                  <t>
                    Value: A string 255 characters or less in length.
                    It MUST consist only of ASCII characters in the
                    range 33-126 inclusive (printable non-whitespace
                    characters).
                  </t> 
                </list>
              </t>
              <t>
                assoc_type
                <list style="empty">
                  <t>
                    The value of the "openid.assoc_type" parameter
                    from the request.  If the OP is unwilling or
                    unable to support this association type, it MUST
                    return an unsuccessful response.
                  </t>
                </list>
              </t>
              <t>
                expires_in
                <list style="empty">
                  <t>
                    The lifetime, in seconds, of this association.
                    The Relying Party MUST NOT use the association
                    after this time has expired.
                  </t>
                  <t>
                    Value: An integer, represented in base 10 ASCII.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="Unencrypted Response Parameters">
          <t>
            <list style="symbols">
              <t>
                mac_key
                <list style='empty'>
                  <t>
                    The MAC key (shared secret) for this
                    association, <xref target="RFC3548">Base 64</xref>
                    encoded.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>


        <section title='Diffie-Hellman Response Parameters' toc="exclude">
          <t>
            <list style="symbols">
              <t>
                dh_server_public
                <list style='empty'>
                  <t>
                    Value: base64(btwoc(g ^ xb mod p))
                  </t>
                  <t>
                    Description: The OP's Diffie-Hellman public key.
                  </t>
                </list>
              </t>
              <t>
                enc_mac_key
                <list style='empty'>
                  <t>
                    Value: base64(H(btwoc(g ^ (xa * xb) mod p)) XOR MAC key)
                  </t>
                  <t>
                    Description: The MAC key (shared secret),
                    encrypted with the secret Diffie-Hellman value. H
                    is either "SHA1" or "SHA256" depending on the
                    session type.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            NOTE: The 'btwoc' function is defined in <xref
            target="btwoc"/>
          </t>
        </section>

        <section anchor="refuse_assoc"
                 title="Unsuccessful Response Parameters">
          <t>
            If the OP does not support an association session type or
            association type, it MUST respond with a message
            indicating that the association request failed. If there
            is another association session type or association type
            that is supported, the OP MAY include that information in
            the response.
          </t>
          <t>
            <list style='symbols'>
              <t>
                ns
                <list style="empty">
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 association failure response.
                  </t>
                </list>
              </t>
              <t>
                error
                <list style='empty'>
                  <t>
                    Value: (optional) A human-readable message
                    indicating why the association request failed.
                  </t>
                </list>
              </t>
              <t>
                error_code
                <list style='empty'>
                  <t>
                    Value: "unsupported-type"
                  </t>
                </list>
              </t>
              <t>
                session_type
                <list style='empty'>
                  <t>
                    Value: A valid association session type from <xref
                        target="assoc_sess_types" />.
                  </t>
                </list>
              </t>
              <t>
                assoc_type
                <list style='empty'>
                  <t>
                    Value: (optional) An association type supported by
                    the OP from <xref target="assoc_types" />.
                  </t>
                </list>
              </t>
            </list>
          </t>
          <t>
            Upon receipt of an "unsupported-type" response, the
            Relying Party MAY make another request with the specified
            association session type and association type. If no
            association is established, the Relying Party MAY continue
            the authentication process in stateless mode.
          </t>
        </section>
      </section>   

      <section title="Association Types" anchor="assoc_types">
        <section title="HMAC-SHA1" anchor="hmacsha1">
          <t>
            An association of type "HMAC-SHA1" uses the <xref
            target="sign_algos">HMAC-SHA1</xref> signature algorithm
            in combination with the <xref target="signed_list">Signed
            List</xref> algorithm.
          </t>
        </section>

        <section title="HMAC-SHA256" anchor="hmacsha256">
          <t>
            An association of type "HMAC-256" uses the <xref
            target="sign_algos">HMAC-SHA256</xref> signature
            algorithm in combination with the <xref
            target="signed_list">Signed List</xref> algorithm.
          </t>
        </section>
      </section>

      <section title="Association Session Types" anchor="assoc_sess_types">
        <t> 
          OpenID Authentication defines three valid association
          session types: "no-encryption", "DH-SHA1", and "DH-SHA256".
        </t>

        <section title="No-Encryption Association Sessions"
                 toc="exclude">
          <t>
            In a "no-encryption" association session, the OP sends
            the association MAC key in plain-text to the Relying Party.
            This makes it possible for an eavesdropper to intercept
            the key, and forge messages to this Relying Party.
            Therefore, no-encryption association sessions SHOULD NOT
            be used unless the messages are using transport-level
            encryption. See <xref target="preventing_eavesdropping" />
            for more information.
          </t>

          <t>
            The MAC key sent by the OP MUST be the length specified
            for this association in <xref target="sign_algos" />.
          </t>

        </section>

        <section title="Diffie-Hellman Association Sessions"
                     anchor="dh_sessions" toc="exclude">
          <t> 
            The "DH-SHA1" and DH-SHA256" association types use
            Diffie-Hellman Key Exchange to securely transmit the
            shared secret.
          </t>
          <t>
            The MAC key MUST be the same length as the output of H,
            the hash function - 160 bits (20 bytes) for DH-SHA1 or 256
            bits (32 bytes) for DH-SHA256, as well as the output of
            the signature algorithm of this association.
          </t>

          <t>
            The Relying Party specifies a modulus, p, and a generator,
            g. The Relying Party chooses a random private key xa and
            OpenID Provider chooses a random private key xb, both in
            the range [1 .. p-1]. The shared secret used to encrypt
            the MAC key is thus g ^ (xa * xb) mod p = (g ^ xa) ^ xb
            mod p = (g ^ xb) ^ xa mod p. For more information, see
            <xref target='RFC2631' />. For information on the
            selection of random values, see <xref target="RFC1750" />.
          </t>
        </section>
      </section>
    </section>

    <section title="Requesting Authentication"
             anchor="requesting_authentication">
      <t>
        Once the Relying Party has successfully performed discovery
        and (optionally) created an association with the discovered
        OP Endpoint URL, it can send an authentication request to the
        OP to obtain an assertion. An authentication request is an
        <xref target="indirect_comm">indirect request</xref>.
      </t>

      <section title="Request Parameters">
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  This value MUST be present for the request to be a
                  valid OpenID Authentication 2.0 request.
                </t>
                <t>
                  Note: If an OP receives an authentication request
                  with this parameter missing or with a lower version
                  number, it SHOULD still respond to the request.  If
                  it does respond it MUST use <xref
                  target="compat_mode">OpenID Authentication 1.1
                  Compatibility</xref> when communicating with that
                  Relying Party.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>
                  Value: "checkid_immediate" or "checkid_setup"
                </t>
                <t>
                  Note: If the Relying Party wishes the end user to be
                  able to interact with the OP, "checkid_setup"
                  should be used. An example of a situation where
                  interaction between the end user and the OP is not
                  desired is when the authentication request is
                  happening asynchronously in JavaScript.
                </t>
              </list>
            </t>

            <t>
              openid.claimed_id
              <list style='empty'>
                <t>
                  Value: (optional) The Claimed Identifier. MUST be present
                  if, and only if, openid.identity is present.
                </t>
                <t>
                  Note: The Claimed Identifier is the same as the
                  OP-Specific Identifier if a different OP-Specific
                  Identifier is not supplied. If neither value is
                  present, the assertion is not about an identifier,
                  and will contain other information in its payload,
                  using <xref target="extensions">extensions</xref>.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The OP-Specific Identifier.
                </t>
                <t>
                  Note: If this is set to the special value
                  "http://openid.net/identifier_select/2.0" then the
                  OP MAY choose an Identifier that belongs to the end
                  user. This parameter MAY be omitted if the request is
                  not about an identifier (for instance if an extension
                  is in use that makes the request meaningful without
                  it; see openid.claimed_id above).
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: (optional) A handle for an association
                  between the Relying Party and the OP that SHOULD be
                  used to sign the response.
                </t>
                <t>
                  Note: If no association handle is sent, the
                  transaction will take place in stateless mode.
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: (optional) URL to which the OP SHOULD return
                  the User-Agent with the response indicating the
                  status of the request.
                </t>
                <t>
                  Note: If this value is not sent in the request it
                  signifies that the Relying Party does not wish to
                  for the end user to be returned to it as something
                  else useful will have been performed via an
                  extension.
                </t>
              </list>
            </t>

            <t>
              openid.realm
              <list style='empty'>
                <t>
                  Value: (optional) URL pattern the OP SHOULD ask the
                  end user to trust. See <xref target="realms" />.
                  This value MUST be sent if openid.return_to is
                  ommitted.
                </t>
                <t>
                  Default: return_to URL
                </t>
              </list>
            </t>
          </list>
        </t>
      </section>
      
      <section title="Realms" anchor="realms">
        <t>
          A "realm" is a pattern that represents the part of URL-space
          for which an OpenID Authentication request is valid. A realm
          is designed to give the end user an indication of the scope
          of the authentication request. OPs SHOULD present the realm
          when requesting the end user's approval for an
          authentication request. OPs MAY use the realm to allow the
          end user to automate approval of authentication
          requests. The realm SHOULD be used by OPs to uniquely
          identify Relying Parties.
        </t>

        <t>
          A realm pattern is a URL, with the following changes:
          <list style="symbols">
            <t>
              A realm MUST NOT contain a URI fragment
            </t>
            <t>
              A realm MAY contain a wild-card at the beginning of the
              URL authority section.  A wild-card consists of the
              characters "*." prepended to the DNS name in the
              authority section of the URL.
            </t>
          </list>
        </t>

        <t>
          A URL matches a realm if:

          <list style="symbols">
            <t>
              The URL scheme and port of the URL are identical to those
              in the realm.  See <xref target="RFC3986">RFC
              3986</xref>, section 3.1 for rules about URI matching.
            </t>

            <t>
              The URL's path is equal to or a sub-directory of the
              realm's path.
            </t>

            <t>
              Either:
              <list style="numbers">
                <t>
                  The realm's domain contains the wild-card characters
                  "*.", and the trailing part of the URL's domain is
                  identical to the part of the realm following the
                  "*." wildcard, or
                </t>
                <t> 
                  The URL's domain is identical to the realm's domain
                </t>
              </list>
             </t>
          </list>
            
          When present, the "openid.return_to" URL MUST match the
          "openid.realm", or the OP MUST return an error.
        </t>

        <t>
          It is RECOMMENDED that OP's protect their end users from
          requests with overly-general realms, like http://*.com/ or
          http://*.co.uk/. Determining if a realm is overly-general is
          at the discretion of the OP.
        </t>
      </section>

      <section title="Immediate Requests">
        <t>
          When requesting authentication, the Relying Party MAY
          request that the OP not interact with the end user.  In
          this case the OP MUST respond immediately with either an
          assertion that authentication is successful, or a response
          indicating that the request cannot be completed without
          further user interaction.  This is accomplished by an
          authentication request with "openid.mode" set to
          "checkid_immediate".
        </t>
      </section>
    </section>

    <section title="Responding to Authentication Requests"
             anchor="responding_to_authentication">
      <t>
        When an authentication request comes from the User-Agent via
        <xref target="indirect_comm">indirect communication</xref>,
        the OP SHOULD identify the User-Agent, and determine whether
        the end user wishes to complete the authentication.  If the
        end user can be identified and wishes to complete the
        authentication, the OP should send a <xref
        target="positive_assertions">positive assertion</xref> to the
        Relying Party.
      </t>
      <t>
        Methods of identifying and authenticating the end user and
        obtaining approval to return an OpenID Authentication
        assertion are beyond the scope of this specification.
      </t>
      <t>
        If no Identifier was specified in the request and there are
        Identifiers in the control of the end user, the OP SHOULD
        allow the end user to choose which Identifier to use.  If an
        Identifier was specified, the OP SHOULD only issue assertions
        about the specified Identifier.
      </t>
      <t>
        If the Relying Party supplied an association handle with the
        authentication request, the OP SHOULD attempt to look up an
        association based on that handle.  If the association is
        missing or expired, the OP SHOULD send the
        "openid.invalidate_handle" parameter as part of the response
        with the value of the request's "openid.assoc_handle"
        parameter, and SHOULD proceed as if no association handle was
        specified.
      </t>
      <t>
        If no association handle is specified, the OP SHOULD create a
        private association for signing the response.  The OP MUST
        store this association and MUST respond to later requests to
        check the signature of the response in <xref
        target="verifying_signatures">stateless mode</xref>.
      </t>
      <t>
        If the "openid.return_to" value is ommitted in the request, it
        signifies that the initiating server does not wish to for the
        end user to be returned to it as something else useful will
        have been performed via an extension.
      </t>

      <section title="Positive Assertions" anchor="positive_assertions">
        <t>
          Positive assertions are <xref target="indirect_comm">
          indirect responses</xref> with the following fields:
        </t>
        <t>
          <list style='symbols'>
            <t>
              openid.ns
              <list style='empty'>
                <t>
                  Value: "http://openid.net/signon/2.0"
                </t>
                <t>
                  Note: This defines the interpretation of the OpenID
                  Authentication arguments without a namespace.  To be
                  an OpenID Authentication 2.0 response, the given
                  value MUST be present.
                </t>
              </list>
            </t>

            <t>
              openid.mode
              <list style='empty'>
                <t>Value: "id_res"</t>
              </list>
            </t>

            <t>
              openid.claimed_id
              <list style='empty'>
                <t>
                  Value: (optional) The Claimed Identifier. Verbatim copy
                  of the openid.claimed_id received in the authentication
                  request (if present). MUST be present if, and only if,
                  openid.identity is present.
                </t>
                <t>
                  Note: The Claimed Identifier is the same as the
                  OP-Specific Identifier if a different OP-Specific
                  Identifier is not supplied. If neither value is
                  present, the assertion is not about an identifier,
                  and will contain other information in its payload,
                  using <xref target="extensions">extensions</xref>.
                </t>
              </list>
            </t>

            <t>
              openid.identity
              <list style='empty'>
                <t>
                  Value: (optional) The OP-Specific Identifier
                </t>
                <t>
                  Note: The openid.identity field MAY be omitted if an
                  extension is in use that makes the response
                  meaningful without it (see openid.claimed_id above).
                </t>
              </list>
            </t>

            <t>
              openid.return_to
              <list style='empty'>
                <t>
                  Value: Verbatim copy of the return_to URL parameter
                  sent in the request.
                </t>

                <t>
                  Note: Because the "openid.return_to" URL is signed
                  by the OP, a Relying Party can make sure outside
                  parties haven't sent responses with query parameters
                  that were not included in the "openid.return_to"
                  URL.
                </t>

              </list>
            </t>

            <t>
              openid.response_nonce
              <list style='empty'>
                <t>
                  Value: A string that MUST be unique to this
                  particular successful authentication response. The
                  nonce MUST start with the current time on the
                  server, and MAY have additional characters appended
                  to the end as necessary to make each response
                  unique. The date and time MUST be formatted as
                  specified in section 5.6 of <xref target="RFC3339"
                  />, with the following restrictions:

                  <list style="symbols">
                    <t>
                      All times must be in the UTC
                      timezone, indicated with a "Z".
                    </t>
                    <t>
                      No fractional seconds are allowed
                    </t>
                  </list>

                  For example: 2005-05-15T17:11:51ZUNIQUE
                </t>
              </list>
            </t>

            <t>
              openid.invalidate_handle
              <list style='empty'>
                <t>
                  Value: (optional) If the Relying Party sent an
                  invalid association handle with the request, it
                  SHOULD be included here.
                </t>
              </list>
            </t>

            <t>
              openid.assoc_handle
              <list style='empty'>
                <t>
                  Value: The handle for the association that was used
                  to sign this assertion.
                </t>
              </list>
            </t>

            <t>
              openid.signed
              <list style='empty'>
                <t>
                  Value: Comma-separated list of signed fields.
                </t>
                <t>
                  Note: This entry consists of the fields without the
                  "openid." prefix that the signature covers. This
                  list MUST contain at least "return_to" and
                  "response_nonce", and if present in the response,
                  "claimed_id" and "identity". For example,
                  "identity,claimed_id,return_to,response_nonce".
                </t>
              </list>
            </t>

            <t>
              openid.sig
              <list style='empty'>
                <t>
                  Value: Base 64 encoded signature calculated as
                  specified in <xref target="generating_signatures"/>.
                </t>

                <t>
                  Note: Successful authentication messages from the
                  OP to the Relying Party MUST be signed.
                </t>
              </list>
            </t>

          </list>
 
        </t>
      </section>

      <section title="Negative Assertions" anchor="negative_assertions">
        <t>
          If the OP is unable to identify the end user or the end
          user does not or cannot approve the authentication request,
          the OP SHOULD send a negative assertion to the Relying
          Party as an <xref target="indirect_comm">indirect
          response</xref>.
        </t>

        <t>
          When receiving a negative assertion in response to an
          immediate mode request, Relying Parties SHOULD
          construct a new authentication request using the
          "checkid_setup" mode to complete the transaction.  This is a
          change from OpenID Authentication 1.1 and more details can
          be found in <xref target="compat_mode" />.
        </t>

        <section title="In Response to Immediate Requests">
          <t>
            If the request was an immediate request, there is no chance
            for the end user to interact with pages on the OP to provide
            identifying credentials or approval of a request.
            A negative assertion of an immediate request takes the
            following form:
            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 immediate negative assertion.
                  </t>
                </list>
              </t>
              <t>
                openid.mode
                <list style='empty'>
                  <t>Value: "id_res"</t>
                </list>
              </t>

              <t>
                openid.user_setup_url
                <list style='empty'>
                  <t>
                    Value: A URL that the end user may visit to
                    complete the request. The Relying Party may
                    redirect the end user to this URL, or provide the
                    end user with a link that points to this URL.  The
                    request is no longer immediate.
                  </t>
                </list>
              </t>
            </list>
          </t>
        </section>

        <section title="In Response to Non-Immediate Requests">
          <t>
            Since the OP may display pages to the end user and
            request credentials from the end user, a negative response
            to a request that is not immediate is definitive.  It
            takes the following form:

            <list style='symbols'>
              <t>
                openid.ns
                <list style='empty'>
                  <t>
                    Value: "http://openid.net/signon/2.0"
                  </t>
                  <t>
                    This value MUST be present for the response to
                    be a valid OpenID 2.0 non-immediate negative assertion.
                  </t>
                </list>
              </t>
              <t>
                openid.mode
                <list style='empty'>
                  <t>
                    Value: "cancel"
                  </t>
                </list>
              </t>
            </list>
          </t>

          <t>
            In a lot of cases, the Relying Party won't get a cancel
            mode response; the end user will just quit or press back
            within their User-Agent. But if it is returned, the
            Relying Party SHOULD return to what it was doing.
          </t>
        </section>
      </section>
    </section>

    <section title="Verifying Assertions" anchor="verification">
      <t>
        When the Relying Party receives a positive assertion, it MUST
        verify the following before accepting the assertion:

        <list style="symbols">
          <t>
            An assertion has not yet been accepted from this
            OP with the same value for "openid.response_nonce"
          </t>
          <t>
            The signature on the assertion is valid
          </t>
          <t>
            Discovered information from the Identifier matches the
            information in the assertion.
          </t>
        </list>

        If all three of these conditions are met, the Claimed
        Identifier in the response is now verified.
      </t>

      
      <section title="Checking the Nonce">
        <t>
          To prevent replay attacks, the agent checking the signature
          SHOULD keep track of the nonce values included in positive
          assertions and never accept the same value more than once
          for the same OP Endpoint URL. When using
          "check_authentication", the OP is responsible for
          preventing replay attacks. When the Relying Party checks the
          signature on an assertion, it is responsible for preventing
          replay attacks.
        </t>
        <t>
          The time-stamp may be used to reject responses that are too
          far away from the current time, limiting the amount of time
          that nonces must be stored to prevent attacks. The
          acceptable range is implementation dependent. A larger range
          requires storing more nonces for a longer time. A shorter
          range increases the chance that clock-skew and transaction
          time will cause a spurious rejection.
        </t>
      </section>

      <section title="Verifying Signatures"
               anchor="verifying_signatures">
        <t>
          If the Relying Party has stored an association with the
          association handle specified in the assertion, it MUST check
          the signature on the assertion itself. If it does not have
          an association stored, it MUST <xref
          target="check_auth">request that the OP verify the
          signature</xref> via Stateless mode.
        </t>

        <section title="Verifying with an Association" toc="exclude">
          <t>
            The Relying Party follows the same procedure that the
            OP followed in <xref target= "generating_signatures">
            generating the signature</xref>, and then compares the
            signature in the response to the signature it
            generated. If the signatures do not match, the assertion
            is invalid.
          </t>

          <t>
            If an authentication request included an association
            handle for an association between the OP and the Relying
            party, and the OP no longer wishes to use that handle
            (because it has expired or the secret has been
            compromised, for instance), the OP will send a response
            that must be verified directly with the OP, as specified
            in <xref target="check_auth" />. In that instance, the OP
            will include the field "openid.invalidate_handle" set to
            the association handle that the Relying Party included
            with the original request.
          </t>
        </section>

        <section title="Verifying Directly with the OpenID Provider"
                 toc="exclude" anchor="check_auth">
          <t>
            To verify a signature directly with the OP, the Relying
            Party sends a <xref target="direct_request">direct
            request</xref> to the OP. This is known as Stateless
            mode.
          </t>

          <section title='Request Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  openid.mode
                  <list style='empty'>
                    <t>Value: "check_authentication"</t>
                   </list>
                </t>

                <t>
                  Exact copies of all fields from the authentication
                  response, except for "openid.mode".
                </t>
              </list>
            </t>
          </section>

          <section title='Response Parameters' toc="exclude">
            <t>
              <list style='symbols'>
                <t>
                  ns
                  <list style="empty">
                    <t>
                      Value: "http://openid.net/signon/2.0"
                    </t>
                    <t>
                      This value MUST be present for the response to
                      be a valid OpenID 2.0 verification response.
                    </t>
                  </list>
                </t>

                <t>
                  mode
                  <list style='empty'>
                    <t>Value: "id_res"</t>
                   </list>
                </t>

                <t>
                  is_valid
                  <list style='empty'>
                    <t>Value: "true" or "false"</t>
                    <t>Description: Boolean; whether the signature is
                    valid.</t>
                  </list>
                </t>

                <t>
                  invalidate_handle
                  <list style='empty'>
                    <t>
                      Value: (optional) An association handle
                    </t>
                    <t>
                      Description: The association handle sent in
                      the request, if the server confirms that it is
                      invalid. 
                    </t>
                  </list>
                </t>
              </list>
            </t>
            <t>
              An OP MUST NOT verify signatures for associations that
              have shared MAC keys. If an OP did verify signatures
              for associations with shared MAC keys, it would be
              possible for parties other than the OP to create valid
              assertions that seemed to come from the OP.
            </t>

            <t>
              The OP SHOULD only return "is_valid" once for each
              authentication response. An authentication response may
              be identified by its "openid.response_nonce" value.
            </t>

            <t>
              If the OP responds with "is_valid" set to
              "true", and "invalidate_handle" is present, the Relying
              Party SHOULD NOT send further authentication requests
              with that handle.  "invalidate_handle" will only be
              present when the original authentication request to the
              OP included an association that the OP deemed
              invalid. This implies that it will only be present in
              this response if it was also present in the <xref
              target="positive_assertions">"id_res"
              response</xref>. Including "invalidate_handle" in the
              direct verification is necessary to prevent an attacker
              from invalidating an association at will by adding it to
              an authentication response.
            </t>

          </section>
        </section>
      </section>

      <section title="Verifying Discovered Information">
        <t>
          The Claimed Identifier MUST have been <xref
          target="discovery">discovered</xref> by the Relying Party
          and the information in the assertion MUST exactly match the
          discovered information.
        </t>
        <t>
          If the Claimed Identifier was not present in the request
          ("openid.identity" was
          "http://openid.net/identifier_select/2.0"), the Relying
          Party MUST perform discovery on the Identifier in the
          response to make sure that the OP is authorized to make
          assertions about the Claimed Identifier.
        </t>
      </section>

      <section title="Identifying the end user" anchor="identifying">
        <t>
          The Claimed Identifier in a successful authentication
          response MAY be used as a user-visible Identifier. The
          Relying Party SHOULD use it as a key for local storage of
          information about the end user.
        </t>

        <t>
          If an assertion is made for a Claimed Identifier which
          has not been discovered, the Relying Party MUST
          perform discovery on that Identifier and verify that the
          discovered information matches that in the assertion,
          including that the OP is authoritative for the Identifier.
        </t>

        <section title="HTTP and HTTPS URL Identifiers" anchor="http_s_identifiers">
          <t>
            Relying Parties MUST differentiate between URL Identifiers
            that have different schemes. When user input is processed
            into a URL, it is processed into a HTTP URL. If the same
            end user controls the same URL, differing only by scheme,
            and it is desired that the Identifier be the HTTPS URL, it
            is RECOMMENDED that a redirect be issued from the HTTP URL
            to the HTTPS URL. Because the HTTP and HTTPS URLs are not
            equivalent and the Identifier that is used is the URL
            after following redirects, there is no reduction in
            security when using this scheme. If an attacker could gain
            control of the HTTP URL, it would have no effect on the
            HTTPS URL, since the HTTP URL is not ever used as an
            Identifier.
          </t>
        </section>
      </section>
    </section>


    <section title="OpenID Authentication 1.1 Compatibility"
             anchor="compat_mode">
      <t>
        OpenID Authentication 2.0 attempts to retain maximum
        compatibility with earlier versions of the OpenID
        Authentication specification, but this is not universally
        possible.  This section lists the behavioral changes required
        of an OpenID Authentication 2.0 OP or Relying Party when
        communicating with another party using OpenID Authentication
        1.1.
      </t>

      <t>
        OpenID Authentication 2.0 implementations SHOULD support
        OpenID Authentication 1.1 compatibility, unlesss security
        considerations make it undesirable.
      </t>

      <t>
        All messages in OpenID Authentication 1.1 omit the "openid.ns"
        parameter, which is an easy way for an RP to determine if the
        message is from an OpenID Authentication 1.1 endpoint. OpenID
        Authentication 1.1 in practice only supports HMAC-SHA1
        associations.
      </t>

      <section title="Relying Parties">
      <t>
        <list style="symbols">
          <t>
            Relying Parties MUST implement <xref
            target="html_disco">HTML-Based Discovery</xref>.
          </t>

          <t>
            Relying Parties MUST send a blank session_type parameter
            in "no-encryption" association requests.
          </t>

          <t>
            Relying Parties MUST accept a "no-encryption" association
            response with a blank or missing session_type parameter,
            if they choose to accept "no-encryption" sessions.
          </t>

          <t>
            In <xref target="requesting_authentication">authentication
            requests</xref>, the "openid.identity" parameter MUST NOT
            be the special value
            "http://openid.net/identifier_select/2.0", because OpenID
            Authentication 1.1 does not support the use of OP
            Identifiers.
          </t>

          <t>
            The "openid.realm" parameter in authentication requests
            was known as "openid.trust_root". The syntax and meaning
            are identical.
          </t>

          <t>
            When responding with a negative assertion to a
            "checkid_immediate" mode authentication request, the
            "user_setup_url" paramater MUST be returned. This is a
            URL that the end user may visit to complete the
            request. The OP may redirect the end user to
            this URL, or provide the end user with a link that
            points to this URL.
          </t>

          <t>
            The Relying Party MUST accept an <xref
            target="positive_assertions">authentication
            response</xref> that is missing the
            "openid.response_nonce" parameter.  It SHOULD however
            implement an out-of-band method for preventing replay
            attacks.
          </t> 
        </list>
      </t>
      </section>

      <section title="OpenID Providers">
        <t>
          <list style="symbols">
            <t>
              "openid.identity" MUST be sent in a <xref
                  target="positive_assertions">positive authentication
              assertion</xref>.
            </t>

            <t>
              OPs MUST accept a "no-encryption" association request
              with a blank session_type parameter, if they choose to
              accept "no-encryption" sessions.
            </t>

            <t>
              OPs MUST accept association requests with no assoc_type
              parameter, and assume them to be of type HMAC-SHA1.
            </t>

            <t>
              <xref target="refuse_assoc">Unsuccessful association
              responses</xref> MUST NOT be sent, since they are not
              part of the OpenID Authentication 1.1 protocol.
            </t>

            <t>
              OPs MAY choose to return a successful "no-encryption"
              response to any association request.
            </t>

            <t>
              Omit or set to blank the "session_type" parameter when
              making "no-encryption" responses to association requests.
            </t>

            <t>
              The "openid.realm" parameter in authentication requests
              was known as "openid.trust_root". The syntax and meaning
              are identical.
            </t>

            <t>
              When responding with a negative assertion to a
              "checkid_immediate" mode authentication request, the
              "user_setup_url" paramater MUST be returned. This is a URL
              that the end user may visit to complete the request. The
              Relying Party may redirect the end user to this URL, or
              provide the end user with a link that points to this
              URL.
            </t>
          </list>
        </t>
      </section>

    </section>

    <section title="Extensions" anchor="extensions">
      <t>
        An Extension to OpenID Authentication is a protocol that
        "piggybacks" on the authentication request and response. Extensions
        are useful for providing extra information about an
        authentication request or response as well as providing extra
        information about the subject of the authentication response.
      </t>

      <t>
        OpenID extensions are identified by a Type URI. The Type URI
        MAY be used as the value of an &lt;xrd:Type&gt; element of an
        OpenID &lt;xrd:Service&gt; element in an XRDS document
        associated with a Claimed Identifier.  The Type URI is also
        used to associate key-value pairs in messages with the extension.
      </t>
      
      <t>
        <!-- XXX: openid. only for indirect messages -->
        To associate keys and values in a message with an extension,
        the key MUST be associated with the Type URI. To associate
        keys with a Type URI, establish an alias by adding a key
        prefixed with "openid.ns." and ending with the alias text
        whose value is the Type URI. Once an alias has been
        established, all pairs in the message whose keys start with
        "openid." followed by the alias text, followed by a period or
        the end of the key are associated with that extension.
      </t>

      <t>
        A namespace alias MUST NOT contain a period, MUST NOT be the
        name of a field in a message defined in this specification,
        and MUST NOT be the same as another namespace alias in the
        same message. A namespace MUST NOT be assigned more than one
        alias in the same message. If a message is a response to
        another message, the response MAY use a different alias to
        refer to the same namespace.
      </t>

      <t>Non-normative example:</t>
      <t>An extension's type URI is
      "&lt;http://example.com/ext/1.0&gt;".
        
      <list style="empty">
        <t>openid.ns.x=http://example.com/ext/1.0</t>
        <t>openid.x=example</t>
        <t>openid.x.foo=bar</t>
        <t>openid.xx=notx</t>
      </list>
        
        In this example, the keys openid.x and openid.x.foo are
        associated with the extension; the openid.xx key is not.
      </t>

      <t>
        Extensions MUST NOT define parameters with the same name. It
        is RECOMMENDED that commas are used as value delimiters,
        though other characters may be better suited in
        certain situations.  Another approach is to append a
        numeric value to each key to differentiate between each value.
      </t>
    </section>

    <section title="Discovering OpenID Relying Parties">
      <t>
        Relying Parties are RECOMMENDED to use the Yadis protocol to
        publish their return_to URL. This allows for automated
        discovery of OpenID Relying Parties.
      </t>
      
      <t>
        In this case, the XRDS document published by the Relying
        Party, SHOULD have an &lt;xrd:Service&gt; element where the
        content of the &lt;xrd:URI&gt; tag is the return_to URL and
        the content of the &lt;xrd:Type&gt; tag is
        "http://openid.net/return_to/2.0".
      </t>
      
      <figure>
        <preamble>For example:</preamble>
        <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/return_to/2.0</Type>
  <URI>http://consumer.example.com/return</URI>
</Service>
]]></artwork>
      </figure>
    </section>
    
    <section title="Security Considerations">
      <section title="Preventing Attacks">
        <section title="Eavesdropping Attacks"
                 anchor="preventing_eavesdropping">
          <t>
            There are two places in this protocol that are vulnerable
            to eavesdropping attacks. An eavesdropper could intercept
            an unencrypted association session and recover the shared
            secret, allowing an attacker to masquerade as the OP to
            that relying party. An eavesdropper could also intercept a
            successful authentication assertion and re-use it, if the
            nonce is not checked.
          </t>

          <t>
            Both of these attacks can be prevented by using SSL for
            these connections. The association session can also use
            Diffie-Hellman Key Exchange instead of "no-encryption" to
            protect from eavesdropping. If the nonce is checked in
            message verification, the positive authentication
            assertion cannot be re-used.
          </t>
        </section>

        <section title="Man-in-the-Middle Attcks">
          <t>
            Associations prevent tampering of signed fields by a man
            in the middle, except during discovery, association
            sessions and stateless mode. Altering signed fields
            without the shared secret requires breaking the
            MAC. Currently, no tractable attack is known on the MACs
            used in this protocol. The quality of the protection
            provided by the MAC depends on the randomness of the
            shared MAC key, so it is important that an unguessable
            value be used.
          </t>

          <t>
            If DNS resolution or the transport layer is compromised,
            signatures on messages are not adequate, since the
            attacker can impersonate the OP and issue its own
            associations, or its own decisions in stateless mode. If
            an attacker can tamper with the discovery process, he can
            specify any OP, and so does not have to impersonate the
            OP.
          </t>

          <t>
            Using SSL with certificates signed by a trusted authority
            prevents these kinds of attacks by verifying the results
            of the DNS look-up against the certificate. Once the
            validity of the certificate has been established,
            tampering is not possible. Impersonating an SSL server
            requires forging or stealing a certificate, which is
            significantly harder than the network attacks.
          </t>

          <t>
            In order to get protection from SSL, SSL must be used for
            all parts of the interaction, including interaction with
            the end user through the User-Agent.  While the protocol
            does not require SSL be used, its use is strongly
            RECOMMENDED.  Current best practicies dictate that an OP
            SHOULD use SSL, with a certificate signed by a trusted
            authority, to secure its service endpoint.  In addition,
            SSL, with a certificate signed by a trusted authority,
            SHOULD be used so that a Relying Party can fetch the
            end user's URL in a secure manner.  Following its own
            security policies, a Relying Party MAY choose to not
            complete, or even begin, a transaction if SSL is not being
            correctly used at these various endpoints.
          </t>
        </section>
      </section>

      <section title="User-Agents">
        <t>
          Since this protocol is intended to be used interactively,
          User-Agents will primarily be common Web browsers. Web
          browsers or their hosts may be infected with spyware or
          other malware, which limits the strength of the
          authentication assertion, since untrusted software makes it
          impossible to know whether the authentication decision has
          been made with the end user's approval. With that said, many
          web applications and protocols today rely on the security of
          the Web browser and their hosts.
        </t>

        <t>
          Cross-site-scripting attacks against OPs may be used to the
          same effect. For the best security, OPs should not depend
          on scripting.  This enables User-Agents that do not support
          scripting, or have scripting disabled, to still employ the
          protocol.
        </t>
      </section>

      <section title="User Interface Considerations">
        <t>
          The Relying Party SHOULD redirect the end user to the OP
          Endpoint URL in a top-level browser window with all controls
          visible. This allows better protection for the end user
          against OP look-alike sites (phishing).
        </t>

        <t>
          OPs SHOULD educate their end users about the potential for
          OpenID phishing attacks and SHOULD equip their end users
          with the tools to defeat such attacks, for example browser
          plugins that verify the authenticity of the OP's
          Authentication Service Endpoint URL.
        </t>
      </section>
    </section>

    <appendix title="Examples">
      <t>Non-normative</t>

      <appendix title="OP-Specific Identifiers">
        <t>
          An end user wants to use "http://www.example.com/" as their
          Claimed Identifier. The end user has an account with
          Example Provider, which functions as an OpenID Provider.  The
          end user's OP-Specific Identifier is
          "https://exampleuser.exampleprovider.com/".
        </t>

        <t>
          In this scenerio, with the proper configuration of Yadis or
          HTML-based Discovery (see <xref target="discovery" /> and
          <xref target="XRDS Sample" /> below), a Relying Party will
          discover the following information about the end user:

          <list style="hanging">
            <t hangText="Claimed Identifier">
              http://www.example.com/
            </t>
            <t hangText="OP-Specific Identifier">
              https://exampleuser.exampleprovider.com/
            </t>
          </list>
        </t>
      </appendix>

      <appendix title="XRDS" anchor="XRDS Sample">
        <t>
          <figure>
            <preamble>
              For an end user to use "http://www.example.com/" as
              their Identifier, but have Relying Parties actually
              verify https://exampleuser.exampleprovider.com/ with the OP
              Endpoint URL
              https://www.exampleprovider.com/endpoint/, the
              following XML snippet should be present in the final XRD
              element in the XRDS file when discovery is preformed on
              "http://www.example.com":
            </preamble>
            <artwork><![CDATA[
<Service xmlns="xri://$xrd*($v*2.0)">
  <Type>http://openid.net/signon/2.0</Type>
  <URI>https://www.exampleprovider.com/endpoint/</URI>
  <LocalID>https://exampleuser.exampleprovider.com/</LocalID>
</Service>
]]></artwork>
          </figure> 
        </t>
      </appendix>

      <appendix title="HTML Identifier Markup">
        <figure>
          <preamble>
            To use www.example.com as their Identifier, but have
            Relying Parties actually verify
            http://exampleuser.livejournal.com/ with the OpenID
            Provider located at
            http://www.livejournal.com/openid/server.bml, the
            following markup should be present in the &lt;head&gt;
            of the HTML document located by the identifier URL:
          </preamble>
          <artwork><![CDATA[
<link rel="openid.server"
      href="http://www.livejournal.com/openid/server.bml"/>
<link rel="openid.delegate"
      href="http://exampleuser.livejournal.com/"/>
]]></artwork>
        </figure> 
      </appendix>

      <appendix title="Login Form">
        <t>
          The end user visits a Relying Party site which supports
          OpenID Authentication.  The Relying Party presents the end
          user with a form field for them to enter their Claimed
          Identifier or their OP Identifier.
        </t>

        <t>
          <figure>
            <preamble>For example:</preamble>
            <artwork>
              ----------------------------------
              |[logo]example.com               | [Login Button]
              ----------------------------------
            </artwork>
          </figure>
        </t>
      </appendix>

      <appendix title="XRI CanonicalID">
        <t>
          For example, if the XRI i-names =example and =exmpl both
          yield an XRDS document with the CanonicalID
          xri://(example)!1234 then those Identifiers should be
          treated as equivalent. For applications with user accounts,
          the persistant Canonical ID xri://(example)!1234 should be
          used the the primary key for the account.  Although the
          i-names =example and =exmpl may also be stored for reference
          as display names, they are reassignable identifier and
          should not be used as persistent keys.
        </t>
      </appendix>
    </appendix>

    <appendix title='Diffie-Hellman Key Exchange Default Value' anchor="pvalue">
      <figure>
        <preamble>
          This is a confirmed-prime number, used as the default
          modulus for Diffie-Hellman Key Exchange. In hexadecimal:
        </preamble>
        <artwork>
DCF93A0B883972EC0E19989AC5A2CE310E1D37717E8D9571BB7623731866E61E
F75A2E27898B057F9891C2E27A639C3F29B60814581CD3B2CA3986D268370557
7D45C2E7E52DC81C7A171876E5CEA74B1448BFDFAF18828EFD2519F14E45E382
6634AF1949E5B535CC829A483B8A76223E5D490A257F05BDFF16F2FB22C583AB
        </artwork>
      </figure>
    </appendix>

    <!-- XXX: An example for Generating Signatures might be nice. -->

    <appendix title="Changes from the Previous OpenID Authentication Specification">
      <t>
        This specification is based on the original specification for
        OpenID Authentication as written by Brad Fitzpatrick. That
        specification did not have a version number, but was called
        OpenID 1.0, and then OpenID 1.1 when it was revised.  The
        protocol outlined in this specification is intended to be
        backwards-compatible with the revised OpenID protocol.  The
        most significant changes to the specification are outlined in
        this section.
      </t>
      <appendix title="Updated Initiation and Discovery">
        <t>
          <list style="symbols">
            <t>
              Supports OP Identifiers. This new variation of the
              protocol flow is initiated by an end user entering an OP
              Identifier instead of a Public Identifier.  This allows
              the OP to assist the end user in selecting an
              Identifier, which may be either a Public Identifier (one
              of multiple "personas"), or a Private Identifier (which
              may be generated by the OP to be used only in the
              context of a single RP).
            </t>
            <t>
              Supports the use of XRIs as Identifiers. XRIs may be
              used as Identifiers for both end users and OPs, and
              provide automatic mapping from one or more reassignable
              i-names to a synonymous persistent Canonical ID that
              will never be reassigned.
            </t>
            <t>
              When URLs are used as Identifiers, they are normalized
              according to the guidelines in <xref target='RFC3986'
              />, for better compatibility with existing Web infrastructure.
            </t>
            <t>
              Uses the Yadis protocol for discovery. This allows for
              using multiple OPs for a single Identifier, for
              load-balancing and fallback in the case of OP
              failure. Additionally, it allows for discovery of
              supported extensions and other associated services.
            </t>
          </list>
        </t>
      </appendix>

      <appendix title="Security improvements">
        <t>
          A nonce is now part of the protocol for built-in protection
          against replay attacks, which was previously implemented out of
          band by each library or application.
        </t>
        <t>
          A new association type, HMAC-SHA256, and a new association
          session type, DH-SHA256, allow for stronger signatures on
          authentication assertions.
        </t>
      </appendix>

      <appendix title="Extensions">
        <t>
          Extensions are now an officially supported mechanism to
          support data exchange and other Relying Party-OP
          communication along with the authentication
          exchange. Extensions allow for the exchange of arbitrary
          attributes, as well as for protocol extensions,
          such as the inclusion of additional information about the
          Relying Party in the authentication request.
        </t>
        <t>
          Because extensions can transfer arbitrary data, the
          Identifier is now optional in the response.
        </t>
      </appendix>
    </appendix>
  </middle>

  <back>
    <references title='Normative References'>
      <reference anchor='RFC3629'>
        <front>
          <title>
            UTF-8, a transformation format of Unicode and ISO 10646
          </title>
          <author initials='F.Y' surname='Yergeau' fullname='Francois Yergeau'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3629" />
      </reference>
      <reference anchor='RFC2119'>
        <front>
          <title>
            Key words for use in RFCs to Indicate Requirement Levels
          </title>
          <author initials='B.S' surname='Bradner' fullname='Scott Bradner'>
            <organization>Alis Technologies</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2119" />
      </reference>
      <reference anchor='RFC3986'>
        <front>
          <title>Uniform Resource Identifiers (URI): Generic Syntax</title>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3986" />
      </reference>
      <reference anchor='RFC1750'>
        <front>
          <title>Randomness Recommendations for Security</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Digital Equipment Corporation</organization>
          </author>
          <author initials='S.C' surname='Crocker'
                  fullname='Stephen D. Crocker'>
            <organization>CyberCash, Inc.</organization>
          </author>
          <author initials='J.S' surname='Schiller'
                  fullname='Jeffery I. Schiller'>
            <organization>Massachusetts Institute of Technology</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="1750" />
      </reference>
      <reference anchor='RFC2631'>
        <front>
          <title>Diffie-Hellman Key Agreement Method</title>
          <author initials='E.R' surname='Rescorla'
                  fullname='Eric Rescorla'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="2631" />
      </reference>
      <reference anchor='RFC3548'>
        <front>
          <title>The Base16, Base32, and Base64 Data Encodings</title>
          <author initials='S.J' surname='Josefsson'
                  fullname='Simon Josefsson'>
            <organization />
          </author>
        </front>
        <seriesInfo name="RFC" value="3548" />
      </reference>
      <reference anchor='RFC2104'>
        <front>
          <title>HMAC: Keyed-Hashing for Message Authentication</title>
          <author initials='H.K' surname='Krawczyk' fullname='Hugo Krawczyk'>
            <organization>IBM</organization>
          </author>
          <author initials='M.B' surname='Bellare' fullname='Mihir Bellare'>
            <organization>UCSD</organization>
          </author>
          <author initials='R.C' surname='Canetti' fullname='Ran Canetti'>
            <organization>IBM</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2104" />
      </reference>
      <reference anchor='FIPS180-2'>
        <front>
          <title>Secure Hash Signature Standard</title>
          <author>
            <organization>U.S. Department of Commerce</organization>
          </author>
          <author>
            <organization>National Institute of Standards 
              and Technology</organization>
          </author>
        </front>
        <seriesInfo name="FIPS" value="180-2" />
        <format type="PDF" target="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf" />
        <annotation>Defines Secure Hash Algorithm 256 (SHA256)</annotation>
      </reference>
      <reference anchor='HTML401'>
        <front>
          <title>HTML 4.01 Specification</title>
          <author>
            <organization>W3C</organization>
          </author>
        </front>
        <format type="HTML" target="http://www.w3.org/TR/html401" />
      </reference>
      <reference anchor='RFC2616'>
        <front>
          <title>Hypertext Transfer Protocol -- HTTP/1.1</title>
          <author initials='R.F' surname='Fielding' fullname='R. Fielding'>
            <organization>UC Irvine</organization>
          </author>
          <author initials='J.G' surname='Gettys' fullname='J. Gettys'>
            <organization>Compaq/W3C</organization>
          </author>
          <author initials='J.M' surname='Mogul' fullname='J. Mogul'>
            <organization>Compaq</organization>
          </author>
          <author initials='H.F' surname='Frystyk' fullname='H. Frystyk'>
            <organization>W3C/MIT</organization>
          </author>
          <author initials='L.M' surname='Masinter' fullname='L. Masinter'>
            <organization>Xerox</organization>
          </author>
          <author initials='P.L' surname='Leach' fullname='P. Leach'>
            <organization>Microsoft</organization>
          </author>
          <author initials='T.L' surname='Berners-Lee'
                  fullname='T. Berners-Lee'>
            <organization>W3C/MIT</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="2616" />
      </reference>
      <reference anchor='RFC3174'>
        <front>
          <title>US Secure Hash Algorithm 1 (SHA1)</title>
          <author initials='D.E' surname='Eastlake'
                  fullname='Donald E. Eastlake, 3rd'>
            <organization>Motorola</organization>
          </author>
          <author initials='P.J' surname='Jones' fullname='Paul E. Jones'>
            <organization>Cisco Systems, Inc.</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor='RFC3339'>
        <front>
          <title>Date and Time on the Internet: Timestamps</title>
          <author initials='C.N' surname='Newman'
                  fullname='Chris Newman'>
            <organization>Sun Microsystems</organization>
          </author>
          <author initials='G.K' surname='Klyne' fullname='Graham Klyne'>
            <organization>Clearswift Corporation</organization>
          </author>
        </front>
        <seriesInfo name="RFC" value="3174" />
      </reference>
      <reference anchor="XRI Syntax 2.0"
                 target="http://www.oasis-open.org/committees/download.php/15376" >

        <front>
          <title>Extensible Resource Identifier (XRI) Syntax V2.0</title>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='D.M' surname='McAlpin' fullname="Dave McAlpin">
            <organization>Epok</organization>
          </author>
        </front>
        <format type="HTML" target=
                "http://www.oasis-open.org/committees/download.php/15376" />
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/15377" />
      </reference>

      <reference anchor="XRI Resolution 2.0"
                 target="http://www.oasis-open.org/committees/download.php/17293" >
        <front>
          <title>Extensible Resource Identifier (XRI) Resolution V2.0
          - Working Draft 10</title>
          <author initials='G.W' surname='Wachob' fullname="Gabe Wachob">
            <organization>Visa International</organization>
          </author>
          <author initials='D.R' surname='Reed' fullname="Drummond Reed">
            <organization>Cordance</organization>
          </author>
          <author initials='L.C' surname='Chasen' fullname="Les Chasen">
            <organization>NeuStar</organization>
          </author>
          <author initials='W.T' surname='Tan' fullname="William Tan">
            <organization>NeuStar</organization>
          </author>
          <author initials='S.C' surname='Churchill' fullname="Steve Churchill">
            <organization>XDI.ORG</organization>
          </author>
        </front>
        <format type="PDF" target=
                "http://www.oasis-open.org/committees/download.php/17293" />
      </reference>

      <reference anchor="Yadis">
        <front>
          <title>Yadis Specification 1.0</title>
          <author initials='J.M' surname='Miller' fullname="Joaquin Miller">
            <organization>NetMesh</organization>
          </author>
        </front>
        <format type='PDF' target="http://yadis.org/papers/yadis-v1.0.pdf" />
        <format type='ODT' target="http://yadis.org/papers/yadis-v1.0.odt" />
      </reference>
    </references>
  </back>
</rfc>
